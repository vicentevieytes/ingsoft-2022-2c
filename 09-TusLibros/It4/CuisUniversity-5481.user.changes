

----QUIT----(11 September 2022 19:10:09) CuisUniversity-5481.image priorSource: 2810882!

----STARTUP---- (11 September 2022 19:10:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5481.image!


----QUIT----(11 September 2022 19:10:10) CuisUniversity-5481.image priorSource: 7059465!

----STARTUP---- (10 November 2022 00:08:39) as /home/vicente/Escritorio/linux64/CuisUniversity-5481.image!


----End fileIn of /home/vicente/Escritorio/linux64/TusLibrosREST Ejercicio it4.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/System/Collections-CompactArrays.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Compression.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Sound.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Cryptography-DigitalSignatures.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Identities-UUID.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/System/Network-Kernel.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/WebClient.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/TusLibros-Tests Ejercicio it4.st----!

----End fileIn of /home/vicente/Escritorio/linux64/TusLibros-Model Ejercicio it4.st----!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:12:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:12:05'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:12:07'!
FAILURE!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'VV 11/10/2022 00:21:24' prior: 50591638!
bookPerformance: anItem

	|readySemaphore bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	
	readySemaphore := Semaphore new.	 
	[totalSales := self totalSalesOf: anItem. readySemaphore signal] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	readySemaphore wait.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:21:25'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:21:26'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:21:28'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:21:30'!
FAILURE!

Object subclass: #ForkerJoiner10_000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #ForkerJoiner10_000 category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:23:48'!
Object subclass: #ForkerJoiner10_000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!ForkerJoiner10_000 methodsFor: 'no messages' stamp: 'VV 11/10/2022 00:29:11'!
fork: aBlock

	[aBlock value.] fork. ! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'VV 11/10/2022 00:34:48' prior: 50591927!
bookPerformance: anItem

	|readySemaphore bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	"
	readySemaphore := Semaphore new.	 
	[totalSales := self totalSalesOf: anItem. readySemaphore signal] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	readySemaphore wait.
	"
	ForkerJoiner10_000 new fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	ForkerJoiner10_000 new join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!classDefinition: #TusLibrosSystemFacade category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:35:17'!
Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions forkerJoiner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'VV 11/10/2022 00:35:16' prior: 50592049!
bookPerformance: anItem

	|bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	"
	readySemaphore := Semaphore new.	 
	[totalSales := self totalSalesOf: anItem. readySemaphore signal] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	readySemaphore wait.
	"
	forkerJoiner = ForkerJoiner10_000 new
	 fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:22'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:35:22'!
ERROR!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:35:24'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:35:27'!
ERROR!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'VV 11/10/2022 00:35:47' prior: 50592086!
bookPerformance: anItem

	|bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	"
	readySemaphore := Semaphore new.	 
	[totalSales := self totalSalesOf: anItem. readySemaphore signal] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	readySemaphore wait.
	"
	forkerJoiner = ForkerJoiner10_000 new fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'VV 11/10/2022 00:35:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:35:55'!
ERROR!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:35:57'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:36:00'!
ERROR!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'VV 11/10/2022 00:36:14' prior: 50592196!
bookPerformance: anItem

	|bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	"
	readySemaphore := Semaphore new.	 
	[totalSales := self totalSalesOf: anItem. readySemaphore signal] fork.
	totalMoney := self totalMoneyRaisedBy: anItem.
	readySemaphore wait.
	"
	forkerJoiner := ForkerJoiner10_000 new fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'VV 11/10/2022 00:36:20'!
ERROR!
!ForkerJoiner10_000 methodsFor: 'as yet unclassified' stamp: 'VV 11/10/2022 00:36:28'!
join
	self shouldBeImplemented.! !

!classDefinition: #ForkerJoiner10_000 category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:42:58'!
Object subclass: #ForkerJoiner10_000
	instanceVariableNames: 'numberOfActiveForks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!ForkerJoiner10_000 methodsFor: 'as yet unclassified' stamp: 'VV 11/10/2022 00:42:57' prior: 50592336!
join

	[numberOfActiveForks = 0] whileFalse:[]! !

----STARTUP---- (10 November 2022 00:43:55) as /home/vicente/Escritorio/linux64/CuisUniversity-5481.image!


!classDefinition: #TusLibrosClientTestWindow category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:15'!
SystemWindow subclass: #TusLibrosClientTestWindow
	instanceVariableNames: 'cartIdsListMorph booksCatalogListMorph cartContentListMorph addToCartButtonMorph listCartButtonMorph selectedCartLabelMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #TusLibrosClientTestWindow category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:15'!
SystemWindow subclass: #TusLibrosClientTestWindow
	instanceVariableNames: 'cartIdsListMorph booksCatalogListMorph cartContentListMorph addToCartButtonMorph listCartButtonMorph selectedCartLabelMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'NR 6/13/2022 07:06:24'!
informBook: bookIsbn addedToCart: cartId

	self inform: bookIsbn,' added to CartId: ', cartId asString
	
! !
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'NR 6/13/2022 07:06:29'!
refreshCartButtonsLabels: anIndex

	self refreshButton: listCartButtonMorph withLabel: 'List CartId: '  onIndex: anIndex.
	self refreshButton: addToCartButtonMorph withLabel: 'Add to CartId: '  onIndex: anIndex.
	
	
	! !
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'NR 6/13/2022 07:06:35'!
refreshCurrentSelectedCartContent: cartId

	cartContentListMorph updateList.
	selectedCartLabelMorph contents: 'Books in CartId: ', cartId
	
	
	! !
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'NR 6/13/2022 07:06:39'!
refreshListOfCartIds

	cartIdsListMorph updateList
	! !
!TusLibrosClientTestWindow methodsFor: 'private' stamp: 'NR 6/13/2022 07:06:48'!
refreshButton: aButton withLabel: aLabel onIndex: anIndex

	| newLabel |

	newLabel := aLabel.
	(anIndex ~= 0) ifTrue: [newLabel := newLabel,  (self model cartIds at: anIndex) asString].
	aButton label: newLabel.
	aButton morphHeight: self heightOfButtons.
	aButton redrawNeeded 
	
	! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/13/2022 07:05:51'!
build1stRow

	| createCartButtonMorph firstRowLayoutMorph |
	
	createCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #createCart label: 'Create Cart'.	
	addToCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #addToCart label: 'Add To Cart'.	
	
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: createCartButtonMorph;
	addMorph: self build2ndColumn1stRow;
	addMorph: self build3rdColumn1stRow;
	addMorph:  addToCartButtonMorph.
	
	
	^firstRowLayoutMorph.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/9/2022 08:11:48'!
build2ndColumn1stRow

	| secondColumnLayoutMorphOfFirstRow |
	
	cartIdsListMorph := PluggableListMorph model: self model listGetter: #cartIds indexGetter: #cartIdsIndex indexSetter: #cartIdsIndex:.
	cartIdsListMorph  borderColor: Color lightBlue; borderWidth: 1; morphWidth:300.
		
	secondColumnLayoutMorphOfFirstRow := LayoutMorph newColumn.
	secondColumnLayoutMorphOfFirstRow separation: 5; 
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Carts Created');
	addMorph: cartIdsListMorph.
	
	secondColumnLayoutMorphOfFirstRow layoutSpec fixedWidth: 390.
	cartIdsListMorph layoutSpec proportionalWidth: 1.
	cartIdsListMorph layoutSpec proportionalHeight: 1.
		
	^secondColumnLayoutMorphOfFirstRow.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/13/2022 07:05:59'!
build2ndColumn2ndRow

	| secondColumnLayoutMorphOfSecondRow |

	cartContentListMorph := PluggableListMorph model: self model listGetter: #cartContent indexGetter: nil indexSetter: nil.
	cartContentListMorph  borderColor: Color lightBlue; borderWidth: 1; morphWidth:300.
	
	selectedCartLabelMorph := LabelMorph contents:'Books in CartId: '.
		
	secondColumnLayoutMorphOfSecondRow := LayoutMorph newColumn.
	secondColumnLayoutMorphOfSecondRow separation: 5; 
	axisEdgeWeight: 0.5;
	addMorph: selectedCartLabelMorph;
	addMorph: cartContentListMorph.
	
	secondColumnLayoutMorphOfSecondRow layoutSpec fixedWidth: 390.
	cartContentListMorph layoutSpec proportionalWidth: 1.
	cartContentListMorph layoutSpec proportionalHeight: 1.
		
	^secondColumnLayoutMorphOfSecondRow.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/13/2022 07:06:04'!
build2ndRow

	| secondRowLayoutMorph |

	listCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #listCart label: 'List CartId: '.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: listCartButtonMorph;
	addMorph: self build2ndColumn2ndRow.
	
	^secondRowLayoutMorph

		! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/9/2022 08:12:04'!
build3rdColumn1stRow

	| thirdColumnLayoutMorphOfFirstRow |
	
	booksCatalogListMorph := PluggableListMorph model: self model listGetter: #booksCatalog indexGetter: #booksCatalogIndex indexSetter: #booksCatalogIndex:.
	booksCatalogListMorph borderColor: Color lightBlue; borderWidth: 1; morphWidth:300.
		
	thirdColumnLayoutMorphOfFirstRow  := LayoutMorph newColumn.
	thirdColumnLayoutMorphOfFirstRow  separation: 5; 
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Book Catalog');
	addMorph: booksCatalogListMorph.
	
	thirdColumnLayoutMorphOfFirstRow layoutSpec fixedWidth: 390.
		
	^thirdColumnLayoutMorphOfFirstRow.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/9/2022 08:12:08'!
buildMorphicWindow

	self layoutMorph beColumn;
	separation: 15;
	axisEdgeWeight: 0;
	addMorph: self build1stRow;
	addMorph: self build2ndRow.
	! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/9/2022 08:12:11'!
defaultExtent

	^ 1035@485
	! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'NR 6/13/2022 07:06:16'!
heightOfButtons

	^ 66! !
!TusLibrosClientTestWindow methodsFor: 'initialization' stamp: 'NR 6/13/2022 07:07:04'!
initializeWith: aTitle

	self setLabel: aTitle.
	self model: (TusLibrosClientTestWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
			
	self model when: #newCartIdArrived send: #refreshListOfCartIds to: self.		
	self model when: #selectedCartChanged send: #refreshCartButtonsLabels: to: self.	
	self model when: #bookAddedToCart send: #informBook:addedToCart: to: self.
	self model when: #newCurrentSelectedCartContentArrived send: #refreshCurrentSelectedCartContent: to: self! !

!classDefinition: 'TusLibrosClientTestWindow class' category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:15'!
TusLibrosClientTestWindow class
	instanceVariableNames: ''!

!classDefinition: 'TusLibrosClientTestWindow class' category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:15'!
TusLibrosClientTestWindow class
	instanceVariableNames: ''!
!TusLibrosClientTestWindow class methodsFor: 'instance creation' stamp: 'NR 6/9/2022 02:07:29'!
open
	
	^self new initializeWith: 'TusLibros Client Test Window'.! !

!classDefinition: #RealTimeClock category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
ProtoObject subclass: #RealTimeClock
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #RealTimeClock category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
ProtoObject subclass: #RealTimeClock
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!RealTimeClock methodsFor: 'time' stamp: 'HAW 5/5/2020 17:07:39'!
now

	^DateAndTime now! !
!RealTimeClock methodsFor: 'time' stamp: 'HAW 5/5/2020 17:07:48'!
today

	^Date today! !

!classDefinition: #DefaultMerchantProcessor category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
ProtoObject subclass: #DefaultMerchantProcessor
	instanceVariableNames: 'transactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #DefaultMerchantProcessor category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
ProtoObject subclass: #DefaultMerchantProcessor
	instanceVariableNames: 'transactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!DefaultMerchantProcessor methodsFor: 'debit' stamp: 'HAW 5/5/2020 17:13:16'!
debit: anAmount from: aCreditCard 

	transactionId := transactionId + 1.
	^transactionId! !
!DefaultMerchantProcessor methodsFor: 'initialization' stamp: 'HAW 5/5/2020 17:13:31' overrides: 16920235!
initialize

	super initialize.
	transactionId := 0! !

!classDefinition: #TusLibrosClientRestInterface category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosClientRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #TusLibrosClientRestInterface category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosClientRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'NR 6/13/2022 07:05:17'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'NR 6/9/2022 08:11:20'!
createCartFor: aUser password: aPassword

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'NR 6/9/2022 08:11:24'!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'initialization' stamp: 'NR 6/9/2022 08:11:33'!
port

	^port ifNil: [port:=9999].! !
!TusLibrosClientRestInterface methodsFor: 'initialization' stamp: 'NR 6/9/2022 08:11:37'!
url

	^'http://localhost:', self port asString! !

!classDefinition: #TusLibrosClientTestWindowModel category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosClientTestWindowModel
	instanceVariableNames: 'cartIds selectedCartIdsIndex selectedBookCatalogIndex currentSelectedCartContent restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #TusLibrosClientTestWindowModel category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosClientTestWindowModel
	instanceVariableNames: 'cartIds selectedCartIdsIndex selectedBookCatalogIndex currentSelectedCartContent restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientTestWindowModel methodsFor: 'accessing' stamp: 'NR 6/13/2022 07:09:38'!
selectedBook

	^self booksCatalog at: selectedBookCatalogIndex! !
!TusLibrosClientTestWindowModel methodsFor: 'accessing' stamp: 'NR 6/13/2022 07:09:42'!
selectedCartId

	^self cartIds at: selectedCartIdsIndex! !
!TusLibrosClientTestWindowModel methodsFor: 'testing' stamp: 'NR 6/13/2022 07:09:49'!
areCartIdAndBookSelected

	^selectedCartIdsIndex  ~= 0 and: [selectedBookCatalogIndex  ~= 0]! !
!TusLibrosClientTestWindowModel methodsFor: 'testing' stamp: 'NR 6/13/2022 07:09:52'!
isCartIdSelected

	^selectedCartIdsIndex ~= 0! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/13/2022 07:10:01'!
booksCatalog

	^self defaultCatalog keys! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/9/2022 08:12:38'!
booksCatalogIndex

	^selectedBookCatalogIndex! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/9/2022 08:12:41'!
booksCatalogIndex: anIndex

	selectedBookCatalogIndex  := anIndex! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/9/2022 08:12:45'!
cartContent

	^currentSelectedCartContent! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/9/2022 08:12:57'!
cartIds

	^cartIds! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/13/2022 07:10:15'!
cartIdsIndex

	^selectedCartIdsIndex! !
!TusLibrosClientTestWindowModel methodsFor: 'listSelectors' stamp: 'NR 6/13/2022 07:10:19'!
cartIdsIndex: anIndex

	selectedCartIdsIndex  := anIndex. 
		
	self triggerEvent: #selectedCartChanged with: selectedCartIdsIndex
	! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'NR 6/13/2022 07:07:36'!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'NR 6/9/2022 08:13:07'!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'NR 6/13/2022 07:08:06'!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].! !
!TusLibrosClientTestWindowModel methodsFor: 'initialization' stamp: 'NR 6/9/2022 08:13:11'!
defaultCatalog 

	^Dictionary new
		at: 'GreenBook' put: 10*dollar;
		at: 'BlueBook' put: 15*dollar;
		at: 'MartinFierro' put: 350*peso;
		yourself! !
!TusLibrosClientTestWindowModel methodsFor: 'initialization' stamp: 'NR 6/9/2022 08:13:15' overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.! !

!classDefinition: #TusLibrosServerRestInterface category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosServerRestInterface
	instanceVariableNames: 'systemFacade'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!

!classDefinition: #TusLibrosServerRestInterface category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #TusLibrosServerRestInterface
	instanceVariableNames: 'systemFacade'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosServerRestInterface methodsFor: 'initialization' stamp: 'HAW 5/5/2020 17:18:31'!
initializeOn: aTusLibrosSystemFacade 
	
	systemFacade := aTusLibrosSystemFacade.! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'NR 6/9/2022 08:15:16'!
answer: aBlock to: aRequest 

	| response |
	
	[ response := aBlock value.
	aRequest send200Response: (WebUtils jsonEncode: (response))]
		on: Error
		do: [ :anError | aRequest send400Response: anError messageText ]! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'NR 11/7/2022 07:07:51'!
bookIsbnFrom: requestFields

	^ requestFields at: 'bookIsbn'! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'NR 11/7/2022 07:07:47'!
bookQuantityFrom: requestFields

	^ (requestFields at: 'bookQuantity') asNumber! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'HAW 7/23/2020 16:18:57'!
cartIdFrom: requestFields

	^ (requestFields at: 'cartId') asNumber! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'HAW 7/23/2020 16:20:08'!
clientIdFrom: requestFields

	^ requestFields at: 'clientId'! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'HAW 7/23/2020 16:20:19'!
passwordFrom: requestFields

	^ requestFields at: 'password'! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'NR 11/7/2022 07:07:39'!
withFieldsOf: aRequest do: aBlock

	[ aBlock value: aRequest fields ]
		on: Error
		do: [ :anError | aRequest 
			sendResponseCode: 400 
			content: ('Invalid request: ', anError messageText) asUtf8Bytes
			type: 'text/plain; charset=utf-8'
			close: true ]! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'NR 11/7/2022 06:14:02'!
addToCart: aRequest

	| bookIsbn cartId quantity |

	(Delay forSeconds: 3) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields.
		bookIsbn := self bookIsbnFrom: requestFields.
		quantity := self bookQuantityFrom: requestFields].
		
	self 
		answer: [
			systemFacade add: quantity of: bookIsbn toCartIdentifiedAs: cartId.
			'OK' ]
		to: aRequest 
	! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'HAW 7/23/2020 16:19:16'!
checkOutCart: aRequest

	| cartId creditCardNumber creditCardOwner creditCartExpirationDate creditCartExpirationDateString transactionId |
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields.
		creditCardNumber := requestFields at: 'ccn'.
		creditCartExpirationDateString := requestFields at: 'cced'.
		creditCartExpirationDate := Month 
			month: (creditCartExpirationDateString first: 2) asNumber 
			year: (creditCartExpirationDateString last: 4) asNumber.
		creditCardOwner := requestFields at: 'cco' ].
	
	self 
		answer: [
			transactionId := systemFacade 
					checkOutCartIdentifiedAs: cartId 
					withCreditCardNumbered: creditCardNumber 
					ownedBy: creditCardOwner 
					expiringOn: creditCartExpirationDate. 
			transactionId printString ]
		to: aRequest ! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'NR 6/13/2022 07:11:38'!
createCart: aRequest

	| clientId password |

	(Delay forSeconds: 1) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		clientId := self clientIdFrom: requestFields.
		password := self passwordFrom: requestFields ].
	
	self 
		answer: [ | cartId | 
			cartId := systemFacade createCartFor: clientId authenticatedWith: password.
			cartId printString ]
		to: aRequest ! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'NR 6/13/2022 07:11:31'!
listCart: aRequest

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'HAW 7/23/2020 16:20:19'!
listPurchases: aRequest

	| clientId password purchases response |
	
	self withFieldsOf: aRequest do: [ :requestFields |
		clientId := self clientIdFrom: requestFields.
		password := self passwordFrom: requestFields ].
	
	self 
		answer: [ | soldItems total |
			purchases := systemFacade listPurchasesOf: clientId authenticatingWith: password.
			soldItems := purchases first.
			total := purchases second.
			response := String streamContents: [:stream | 
				soldItems keysAndValuesDo: [ :isbn :amount |
					stream nextPutAll: isbn; nextPut: $|; print: amount; nextPut: $| ].
				stream print: total ].
			response ]
		to: aRequest ! !

!classDefinition: 'TusLibrosServerRestInterface class' category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
TusLibrosServerRestInterface class
	instanceVariableNames: ''!

!classDefinition: 'TusLibrosServerRestInterface class' category: 'TusLibrosREST' stamp: 'VV 11/10/2022 00:44:16'!
TusLibrosServerRestInterface class
	instanceVariableNames: ''!
!TusLibrosServerRestInterface class methodsFor: 'default objects' stamp: 'HAW 5/5/2020 17:11:42'!
createSalesBook
	
	^OrderedCollection new! !
!TusLibrosServerRestInterface class methodsFor: 'default objects' stamp: 'HAW 5/5/2020 17:47:11'!
defaultCatalog 
	
	^Dictionary new
		at: 'GreenBook' put: 10*dollar;
		at: 'BlueBook' put: 15*dollar;
		at: 'MartinFierro' put: 350*peso;
		yourself! !
!TusLibrosServerRestInterface class methodsFor: 'default objects' stamp: 'HAW 5/5/2020 17:13:55'!
defaultMerchantProcessor 
	
	^DefaultMerchantProcessor new! !
!TusLibrosServerRestInterface class methodsFor: 'default objects' stamp: 'HAW 5/5/2020 17:13:46'!
defaultSystem

	| clock systemFacade |
	
	clock := RealTimeClock new.
	systemFacade := TusLibrosSystemFacade 
		authenticatingWith: self validUsersAndPasswords 
		acceptingItemsOf: self defaultCatalog 
		registeringOn: self createSalesBook
		debitingThrought: self defaultMerchantProcessor 
		measuringTimeWith: clock.

	^systemFacade ! !
!TusLibrosServerRestInterface class methodsFor: 'default objects' stamp: 'HAW 5/5/2020 17:10:11'!
validUsersAndPasswords 
	
	^Dictionary new
		at: 'hernan' put: 'smalltalk';
		at: 'maximo' put: 'ruby';
		yourself! !
!TusLibrosServerRestInterface class methodsFor: 'instance creation' stamp: 'HAW 5/5/2020 17:18:06'!
on: aTusLibrosSystemFacade 

	^self new initializeOn: aTusLibrosSystemFacade ! !
!TusLibrosServerRestInterface class methodsFor: 'installation' stamp: 'HAW 7/24/2020 11:07:02'!
installForDefaultSystem

	"self installForDefaultSystem"
	
	| server port interface |
	
	interface := self on: self defaultSystem.
	
	"Esto es para poder acceder a la interface de manera global - Hernan"
	Smalltalk at: #CurrentTusLibrosRestInterface put: interface.
	
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server 
		addService: '/createCart' 
		action: [:request | interface createCart: request ].
	server 
		addService: '/addToCart' 
		action: [:request | interface addToCart: request ].
	server
		addService: '/listCart' 
		action: [:request | interface listCart: request ].
	server
		addService: '/checkOutCart' 
		action: [:request | interface checkOutCart: request ].
	server
		addService: '/listPurchases' 
		action: [:request | interface listPurchases: request ].
	server useDebugErrorHandler ! !

!classDefinition: #Float32PointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
Float32Array variableWordSubclass: #Float32PointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #Float32PointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
Float32Array variableWordSubclass: #Float32PointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'Float32PointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
Float32PointArray class
	instanceVariableNames: ''!

!classDefinition: 'Float32PointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
Float32PointArray class
	instanceVariableNames: ''!

!classDefinition: #PointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
IntegerArray variableWordSubclass: #PointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #PointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
IntegerArray variableWordSubclass: #PointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'PointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
PointArray class
	instanceVariableNames: ''!

!classDefinition: 'PointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
PointArray class
	instanceVariableNames: ''!

!classDefinition: #ShortIntegerArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ArrayedCollection variableWordSubclass: #ShortIntegerArray
	instanceVariableNames: ''
	classVariableNames: 'LastSaveOrder'
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #ShortIntegerArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ArrayedCollection variableWordSubclass: #ShortIntegerArray
	instanceVariableNames: ''
	classVariableNames: 'LastSaveOrder'
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'ShortIntegerArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray class
	instanceVariableNames: ''!

!classDefinition: 'ShortIntegerArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray class
	instanceVariableNames: ''!

!classDefinition: #ShortPointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray variableWordSubclass: #ShortPointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #ShortPointArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray variableWordSubclass: #ShortPointArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'ShortPointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortPointArray class
	instanceVariableNames: ''!

!classDefinition: 'ShortPointArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortPointArray class
	instanceVariableNames: ''!

!classDefinition: #ShortWordArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray variableWordSubclass: #ShortWordArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #ShortWordArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortIntegerArray variableWordSubclass: #ShortWordArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'ShortWordArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortWordArray class
	instanceVariableNames: ''!

!classDefinition: 'ShortWordArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortWordArray class
	instanceVariableNames: ''!

!classDefinition: #ShortRunArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ArrayedCollection variableWordSubclass: #ShortRunArray
	instanceVariableNames: ''
	classVariableNames: 'LastSaveOrder'
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: #ShortRunArray category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ArrayedCollection variableWordSubclass: #ShortRunArray
	instanceVariableNames: ''
	classVariableNames: 'LastSaveOrder'
	poolDictionaries: ''
	category: 'Collections-CompactArrays'!

!classDefinition: 'ShortRunArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortRunArray class
	instanceVariableNames: ''!

!classDefinition: 'ShortRunArray class' category: 'Collections-CompactArrays' stamp: 'VV 11/10/2022 00:44:16'!
ShortRunArray class
	instanceVariableNames: ''!
!Float32PointArray commentStamp: '<historical>' prior: 0!
This class stores points with 32 bit Floating point elements.

{1@2. 3@4} as: Float32PointArray!
!PointArray commentStamp: '<historical>' prior: 0!
This class stores 32bit Integer points in place. It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!
!ShortIntegerArray commentStamp: '<historical>' prior: 0!
ShortIntegerArray is an array for efficiently representing signed integers in the 16bit range, i.e. between -16r8000 and 16r7FFF.

Additionaly, using #unsignedAt:put: and #signedAt:put:, it supports unsigned 16 bits integers, between 0 and 16rFFFF. You can also alternatively ShortWordArray to store unsigned 16 bit integers with the usual #at: and #at:put: protocol.

Array size must be even, as two vales are stored in each word.!
!ShortPointArray commentStamp: '<historical>' prior: 0!
This class stores points that are in short integer range (e.g., -32767 <= value <= 32768). It is used to pass data efficiently to the primitive level during high-bandwidth 2D graphics operations.!
!ShortWordArray commentStamp: '<historical>' prior: 0!
ShortWordArrays store 16-bit unsigned Integer values, between 0 and 16rFFFF.!
!ShortRunArray commentStamp: '<historical>' prior: 0!
This class is run-length encoded representation of short integer (e.g., 16bit signed integer values)!
!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'jmv 12/18/2015 15:29' overrides: 16787193!
initClassCachedState
	"Check if the word order has changed from the last save"

	((LastSaveOrder at: 1) = 42 and:[(LastSaveOrder at: 2) = 13]) 
		ifTrue:[^self]. "Okay"
	((LastSaveOrder at: 2) = 42 and:[(LastSaveOrder at: 1) = 13]) 
		ifTrue:[^self swapShortObjects]. "Reverse guys"
	^self error:'This must never happen'! !
!ShortRunArray class methodsFor: 'class initialization' stamp: 'jmv 12/18/2015 15:29' overrides: 16787193!
initClassCachedState
	"Check if the word order has changed from the last save"

	((LastSaveOrder valueAtRun: 1) = 42 and:[(LastSaveOrder lengthAtRun: 1) = 3]) 
		ifTrue:[^self]. "Okay"
	((LastSaveOrder lengthAtRun: 1) = 42 and:[(LastSaveOrder valueAtRun: 1) = 3]) 
		ifTrue:[^self swapRuns]. "Reverse guys"
	^self error:'This must never happen'! !
!ShortRunArray methodsFor: 'printing' stamp: 'ar 11/3/1998 17:41' overrides: 16823635!
printOn: aStream
	aStream nextPutAll: self class name; nextPutAll:' ( '.
	self lengthsAndValuesDo:[:runLength :runValue |
		aStream
			nextPutAll:' (';
			print: runLength;
			space;
			print: runValue;
			nextPut:$).
	].
	aStream nextPutAll:' )'.! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:11:30' overrides: 16859850!
at: index
	"Return the element (e.g., point) at the given index"
	^(self floatAt: index * 2 - 1) @ (self floatAt: index * 2)! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:11:49' overrides: 16859854!
at: index put: aPoint
	"Store the argument aPoint at the given index"
	self floatAt: index * 2 - 1 put: aPoint x.
	self floatAt: index * 2 put: aPoint y.
	^aPoint! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:11:57'!
at: index putX: aNumber
	"Store the argument aPoint at the given index"
	self floatAt: index * 2 - 1 put: aNumber! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:12:05'!
at: index putY: aNumber
	"Store the argument aPoint at the given index"
	self floatAt: index * 2 put: aNumber! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:04:36' overrides: 16781647!
bytesPerElement

	^ 8! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:02:36' overrides: 16859858!
defaultElement
	"Return the default element of the receiver"
	^`0.0@0.0`! !
!Float32PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:12:17' overrides: 16781372!
size
	"Return the number of elements in the receiver"
	^ super size // 2! !
!Float32PointArray methodsFor: 'printing' stamp: 'jmv 2/28/2020 14:59:07' overrides: 50364728!
printElementsOn: aStream
	"FloatArray elements are answered as 64 bit Float, but are really 32 bit Float.
	When printing, print them as 32 bit Float."
	aStream nextPut: ${.
	self do: [ :point |
		point x printAsIEEE32BitPrecisionFloatOn: aStream base: 10.
		aStream nextPut: $@.
		point y printAsIEEE32BitPrecisionFloatOn: aStream base: 10.
		aStream nextPut: $..
		aStream space].
	self isEmpty ifFalse: [aStream skip: -2].
	aStream nextPut: $}! !
!Float32PointArray class methodsFor: 'instance creation' stamp: 'jmv 2/28/2020 12:13:28' overrides: 16785654!
new: n
	^super new: n*2! !
!PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:26:03' overrides: 16876581!
at: index
	"Return the element (e.g., point) at the given index"
	^(self integerAt: index * 2 - 1) @ (self integerAt: index * 2)! !
!PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:26:16' overrides: 16876585!
at: index put: aPoint
	"Store the argument aPoint at the given index"
	self integerAt: index * 2 - 1 put: aPoint x asInteger.
	self integerAt: index * 2 put: aPoint y asInteger.
	^aPoint! !
!PointArray methodsFor: 'accessing' stamp: 'jmv 5/16/2019 16:20:10'!
at: index putX: aNumber
	"Store the argument aPoint at the given index"
	super at: index * 2 - 1 put: aNumber asInteger! !
!PointArray methodsFor: 'accessing' stamp: 'jmv 5/16/2019 16:19:55'!
at: index putY: aNumber
	"Store the argument aPoint at the given index"
	super at: index * 2 put: aNumber asInteger! !
!PointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!
bounds
	| min max |
	min _ max _ self at: 1.
	self do:[:pt|
		min _ min min: pt.
		max _ max max: pt].
	^min corner: max
		! !
!PointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:04:33' overrides: 16781647!
bytesPerElement

	^ 8! !
!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19' overrides: 16876599!
defaultElement
	"Return the default element of the receiver"
	^0@0! !
!PointArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:21' overrides: 16781372!
size
	"Return the number of elements in the receiver"
	^super size // 2! !
!PointArray class methodsFor: 'instance creation' stamp: 'ar 10/16/1998 00:04' overrides: 16785654!
new: n
	^super new: n*2! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/27/2013 07:21' overrides: 16901507!
at: index
	"Return the 16-bit signed integer value at the given index of the receiver."

	^self signedAt: index! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:31:26' overrides: 16901525!
at: index put: value
	"Store the given 16-bit signed integer at the given index in the receiver."

	^self signedAt: index put: value! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41' overrides: 16781406!
defaultElement
	^0! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/27/2013 07:21'!
signedAt: index
	"Return the 16-bit signed integer value at the given index of the receiver."

	<primitive: 143>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber ifTrue: [^ self at: index truncated].
	self errorNonIntegerIndex.
! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:30:51'!
signedAt: index put: value
	"Store the given 16-bit signed integer at the given index in the receiver."

	<primitive: 144>
	index isInteger
		ifTrue: [
			(index >= 1 and: [index <= self size])
				ifTrue: [self errorImproperStore]
				ifFalse: [self errorSubscriptBounds: index]].
	index isNumber ifTrue: [^ self at: index truncated put: value].
	self errorNonIntegerIndex.
! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41' overrides: 16781372!
size
	^super size * 2! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/28/2013 16:52'!
unsignedAt: index
	"Return the 16-bit unsigned integer value at the given index of the receiver."

	| primValue |
	primValue _ self signedAt: index.
	^primValue < 0
		ifTrue: [
			primValue + 16r10000.		"Faster. No need for LargeInteger arithmetic"
			"(primValue + 1) negated bitInvert16" ]
		ifFalse: [ primValue ]! !
!ShortIntegerArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:33:29'!
unsignedAt: index put: value
	"Store the given 16-bit unsigned integer at the given index in the receiver."

	| primValue |
	value < 0 ifTrue: [ self errorImproperStore ].
	value > 16rFFFF ifTrue: [ self errorImproperStore ].
	primValue _ value > 16r7FFF
			ifTrue: [
				value - 16r10000.		"Faster. No need for LargeInteger arithmetic"
				"(value bitInvert16 + 1) negated" ]
			ifFalse: [ value ].
	self signedAt: index put: primValue.
	^value! !
!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'nk 3/7/2004 13:54' overrides: 16781647!
bytesPerElement
	^2! !
!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'jmv 2/15/2008 00:48' overrides: 16781652!
restoreEndianness
	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.
	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."

	| hack blt |
	Smalltalk isLittleEndian ifTrue: [
		"The implementation is a hack, but fast for large ranges"
		hack _ Form new hackBits: self.
		blt _ (BitBlt toForm: hack) sourceForm: hack.
		blt combinationRule: Form reverse.  "XOR"
		blt sourceY: 0; destY: 0; height: hack height; width: 1.
		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"
		blt sourceX: 1; destX: 0; copyBits.
		blt sourceX: 0; destX: 1; copyBits.
		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"
		blt sourceX: 3; destX: 2; copyBits.
		blt sourceX: 2; destX: 3; copyBits
	].
! !
!ShortIntegerArray methodsFor: 'objects from disk' stamp: 'jmv 2/26/2016 17:08' overrides: 16781668!
writeOn: aStream 

	| w |
	aStream nextSignedInt32Put: self basicSize bigEndian: true.

	1 to: self basicSize do: [ :i |
		w _ self basicAt: i.
		Smalltalk isLittleEndian
			ifFalse: [ aStream nextUnsignedInt32Put: w bigEndian: true ]
			ifTrue: [ aStream
				nextPut: (w digitAt: 2);
				nextPut: (w digitAt: 1);
				nextPut: (w digitAt: 4);
				nextPut: (w digitAt: 3) ]].! !
!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'jmv 12/12/2014 16:56' overrides: 16904184!
initialize
	"
	ShortIntegerArray initialize.
	SystemDictionary initialize.
	"
	LastSaveOrder _ self new: 2.
	LastSaveOrder at: 1 put: 42.
	LastSaveOrder at: 2 put: 13! !
!ShortIntegerArray class methodsFor: 'class initialization' stamp: 'jmv 2/25/2016 10:51'!
swapShortObjects
	self allSubInstancesDo: [ :inst |
		BitBlt swapHalvesIn32BitWords: inst ]! !
!ShortIntegerArray class methodsFor: 'instance creation' stamp: 'jmv 9/4/2015 13:09' overrides: 16785654!
new: n
	"Instances are always of even size. Only accept those."
	n even ifFalse: [
		self error: 'ShortIntegerArray>>#new: must be called with an even argument' ].
	^ super new: n // 2! !
!ShortPointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:14:47' overrides: 50593457!
at: index
	"Return the element (e.g., point) at the given index"
	^(self signedAt: index * 2 - 1) @ (self signedAt: index * 2)! !
!ShortPointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:31:56' overrides: 50593464!
at: index put: aPoint
	"Store the argument aPoint at the given index"
	self signedAt: index * 2 - 1 put: aPoint x asInteger.
	self signedAt: index * 2 put: aPoint y asInteger.
	^aPoint! !
!ShortPointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:32:06'!
at: index putX: aNumber
	"Store the argument aPoint at the given index"
	self signedAt: index * 2 - 1 put: aNumber asInteger! !
!ShortPointArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:32:13'!
at: index putY: aNumber
	"Store the argument aPoint at the given index"
	self signedAt: index * 2 put: aNumber asInteger! !
!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/10/1998 19:41'!
bounds
	| min max |
	min _ max _ self at: 1.
	self do:[:pt|
		min _ min min: pt.
		max _ max max: pt].
	^min corner: max
		! !
!ShortPointArray methodsFor: 'accessing' stamp: 'yo 3/6/2004 12:56' overrides: 50593536!
bytesPerElement

	^ 4.
	! !
!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43' overrides: 50593472!
defaultElement
	"Return the default element of the receiver"
	^0@0! !
!ShortPointArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:43' overrides: 50593501!
size
	^self basicSize! !
!ShortPointArray class methodsFor: 'instance creation' stamp: 'ar 1/15/1999 17:40' overrides: 50593606!
new: n
	^super new: n * 2! !
!ShortWordArray methodsFor: 'accessing' stamp: 'jmv 2/27/2013 07:23' overrides: 50593457!
at: index
	"Return the 16-bit unsigned integer value at the given index of the receiver."

	^self unsignedAt: index! !
!ShortWordArray methodsFor: 'accessing' stamp: 'jmv 2/28/2020 12:33:43' overrides: 50593464!
at: index put: value
	"Store the given 16-bit unsigned integer at the given index in the receiver."

	^self unsignedAt: index put: value! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:26' overrides: 16901507!
at: index
	"Return the short value at the given index"
	| rlIndex |
	index < 1 ifTrue:[^self errorSubscriptBounds: index].
	rlIndex _ index.
	self lengthsAndValuesDo:[:runLength :runValue|
		rlIndex <= runLength ifTrue:[^runValue].
		rlIndex _ rlIndex - runLength].
	"Not found. Must be out of range"
	^self errorSubscriptBounds: index! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:18' overrides: 16901525!
at: index put: value
	"ShortRunArrays are read-only"
	^self shouldNotImplement.! !
!ShortRunArray methodsFor: 'accessing' stamp: 'yo 3/6/2004 14:19' overrides: 16781647!
bytesPerElement

	^ 4
! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:39'!
compressionRatio
	"Return the compression ratio.
	The compression ratio is computed based
	on how much space would be needed to
	store the receiver in a ShortIntegerArray"
	^(self size asFloat * 0.5) "Would need only half of the amount in ShortIntegerArray"
		/ (self runSize max: 1)! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:21'!
lengthAtRun: index
	"Return the length of the run starting at the given index"
	^(self basicAt: index) bitShift: -16! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28'!
runSize
	"Return the number of runs in the receiver"
	^self basicSize! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:28' overrides: 16781372!
size
	"Return the number of elements stored in the receiver"
	| n |
	n _ 0.
	"Note: The following loop is open-coded for speed"
	1 to: self basicSize do:[:i|
		n _ n + ((self basicAt: i) bitShift: -16).
	].
	^n! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:29' overrides: 16823689!
species
	"Answer the preferred class for reconstructing the receiver."
	^ShortIntegerArray! !
!ShortRunArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 17:22'!
valueAtRun: index
	"Return the value of the run starting at the given index"
	| uShort |
	uShort _ (self basicAt: index) bitAnd: 16rFFFF.
	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !
!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 17:31' overrides: 16934379!
do: aBlock
	"Evaluate aBlock with all elements of the receiver"
	self lengthsAndValuesDo:[:runLength :runValue|
		"Use to:do: instead of timesRepeat: for compiler optimization"
		1 to: runLength do:[:i|
			aBlock value: runValue.
		].
	].! !
!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:44'!
lengthsAndValuesDo: aBlock
	"Evaluate aBlock with the length and value of each run in the receiver"
	^self runsAndValuesDo: aBlock! !
!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:44'!
runsAndValuesDo: aBlock
	"Evaluate aBlock with the length and value of each run in the receiver"
	| basicValue length value |
	1 to: self basicSize do:[:i|
		basicValue _ self basicAt: i.
		length _ basicValue bitShift: -16.
		value _ basicValue bitAnd: 16rFFFF.
		value _ (value bitAnd: 16r7FFF) - (value bitAnd: 16r8000).
		aBlock value: length value: value.
	].! !
!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/3/1998 21:05'!
valuesCollect: aBlock
	"Evaluate aBlock with each of the receiver's values as the argument. 
	Collect the resulting values into a collection like the receiver. Answer 
	the new collection."
	| newArray newValue |
	newArray _ self class basicNew: self basicSize.
	1 to: self runSize do:[:i|
		newValue _ aBlock value: (self valueAtRun: i).
		newArray setRunAt: i toLength: (self lengthAtRun: i) value: newValue.
	].
	^newArray! !
!ShortRunArray methodsFor: 'enumerating' stamp: 'ar 11/15/1998 17:22'!
valuesDo: aBlock
	self lengthsAndValuesDo:[:runLength :runValue| aBlock value: runValue]! !
!ShortRunArray methodsFor: 'objects from disk' stamp: 'jmv 2/15/2008 00:49' overrides: 16781652!
restoreEndianness
	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.
	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."

	| w b1 b2 b3 b4 |
	Smalltalk isLittleEndian ifTrue: [
		1 to: self basicSize do: [:i |
			w _ self basicAt: i.
			b1 _ w digitAt: 1.
			b2 _ w digitAt: 2.
			b3 _ w digitAt: 3.
			b4 _ w digitAt: 4.
			w _ (b1 << 24) + (b2 << 16) + (b3 << 8) + b4.
			self basicAt: i put: w.
		]
	].

! !
!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:02'!
setRunAt: i toLength: runLength value: value
	(value < -16r7FFF or:[value > 16r8000]) ifTrue:[^self errorImproperStore].
	(runLength < 0 or:[runLength > 16rFFFF]) ifTrue:[^self errorImproperStore].
	self basicAt: i put: (runLength bitShift: 16) + 
		((value bitAnd: 16r7FFF) - (value bitAnd: -16r8000)).! !
!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:00'!
setRuns: runArray values: valueArray
	| runLength value |
	1 to: runArray size do:[:i|
		runLength _ runArray at: i.
		value _ valueArray at: i.
		self setRunAt: i toLength: runLength value: value.
	].! !
!ShortRunArray class methodsFor: 'class initialization' stamp: 'jmv 12/12/2014 16:56' overrides: 16904184!
initialize
	"
	ShortRunArray initialize
	SystemDictionary initialize.
	"
	LastSaveOrder _ #(42 42 42) as: self! !
!ShortRunArray class methodsFor: 'class initialization' stamp: 'jmv 2/25/2016 10:52'!
swapRuns
	self allSubInstancesDo: [ :inst |
		BitBlt swapHalvesIn32BitWords: inst ]! !
!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12' overrides: 16785654!
new: n
	"ShortRunArrays must be created with either
		someCollection as: ShortRunArray
	or by using
		ShortRunArray runs: runCollection values: valueCollection.
	"
	^self shouldNotImplement! !
!ShortRunArray class methodsFor: 'instance creation' stamp: 'jmv 12/12/2014 17:12' overrides: 50379253!
newFrom: aCollection
	"Compress aCollection into a ShortRunArray"
	| lastValue lastRun runs values valueCount |
	aCollection isEmpty ifTrue: [ ^self runs:#() values: #() ].
	runs _ WriteStream on: (WordArray new: 100).
	values _ WriteStream on: (ShortIntegerArray new: 100).
	lastValue _ aCollection first.
	lastRun _ 0.
	valueCount _ 0.
	aCollection do: [ :item |
		(item = lastValue and:[lastRun < 16r8000]) ifTrue:[
			lastRun _ lastRun + 1.
		] ifFalse:[
			runs nextPut: lastRun.
			values nextPut: lastValue.
			lastRun _ 1.
			lastValue _ item.
			valueCount _ valueCount + 1.
		].
	].
	runs nextPut: lastRun.
	values nextPut: lastValue.
	valueCount _ valueCount + 1.
	valueCount odd ifTrue: [
		values nextPut: 0 ].
	^ self runs: runs contents values: values contents! !
!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!
runs: runCollection values: valueCollection
	^(self basicNew: runCollection size) setRuns: runCollection values: valueCollection! !
!Collection methodsFor: '*Collections-CompactArrays' stamp: 'jmv 12/18/2015 15:01'!
asPointArray
	"Answer a PointArray whose elements are the elements of the receiver"

	^self as: PointArray! !

!classDefinition: #GZipConstants category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #GZipConstants
	instanceVariableNames: ''
	classVariableNames: 'GZipAsciiFlag GZipCommentFlag GZipContinueFlag GZipDeflated GZipEncryptFlag GZipExtraField GZipMagic GZipNameFlag GZipReservedFlags'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #GZipConstants category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #GZipConstants
	instanceVariableNames: ''
	classVariableNames: 'GZipAsciiFlag GZipCommentFlag GZipContinueFlag GZipDeflated GZipEncryptFlag GZipExtraField GZipMagic GZipNameFlag GZipReservedFlags'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'GZipConstants class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipConstants class
	instanceVariableNames: ''!

!classDefinition: 'GZipConstants class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipConstants class
	instanceVariableNames: ''!

!classDefinition: #ZipConstants category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #ZipConstants
	instanceVariableNames: ''
	classVariableNames: 'BaseDistance BaseLength BitLengthOrder DistanceCodes DynamicBlock EndBlock ExtraBitLengthBits ExtraDistanceBits ExtraLengthBits FixedBlock FixedDistanceTree FixedLiteralTree HashBits HashMask HashShift MatchLengthCodes MaxBitLengthBits MaxBitLengthCodes MaxBits MaxDistCodes MaxDistance MaxLengthCodes MaxLiteralCodes MaxMatch MinMatch NumLiterals Repeat11To138 Repeat3To10 Repeat3To6 StoredBlock WindowMask WindowSize'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZipConstants category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #ZipConstants
	instanceVariableNames: ''
	classVariableNames: 'BaseDistance BaseLength BitLengthOrder DistanceCodes DynamicBlock EndBlock ExtraBitLengthBits ExtraDistanceBits ExtraLengthBits FixedBlock FixedDistanceTree FixedLiteralTree HashBits HashMask HashShift MatchLengthCodes MaxBitLengthBits MaxBitLengthCodes MaxBits MaxDistCodes MaxDistance MaxLengthCodes MaxLiteralCodes MaxMatch MinMatch NumLiterals Repeat11To138 Repeat3To10 Repeat3To6 StoredBlock WindowMask WindowSize'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZipConstants class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipConstants class
	instanceVariableNames: ''!

!classDefinition: 'ZipConstants class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipConstants class
	instanceVariableNames: ''!

!classDefinition: #ZipFileConstants category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #ZipFileConstants
	instanceVariableNames: ''
	classVariableNames: 'CentralDirectoryFileHeaderSignature CompressionDeflated CompressionLevelDefault CompressionLevelNone CompressionStored DataDescriptorLength DefaultDirectoryPermissions DefaultFilePermissions DeflatingCompressionFast DeflatingCompressionMaximum DeflatingCompressionNormal DeflatingCompressionSuperFast DirectoryAttrib EndOfCentralDirectorySignature FaMsdos FaUnix FileAttrib IfaBinaryFile IfaTextFile LocalFileHeaderSignature'
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ZipFileConstants category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:16'!
SharedPool subclass: #ZipFileConstants
	instanceVariableNames: ''
	classVariableNames: 'CentralDirectoryFileHeaderSignature CompressionDeflated CompressionLevelDefault CompressionLevelNone CompressionStored DataDescriptorLength DefaultDirectoryPermissions DefaultFilePermissions DeflatingCompressionFast DeflatingCompressionMaximum DeflatingCompressionNormal DeflatingCompressionSuperFast DirectoryAttrib EndOfCentralDirectorySignature FaMsdos FaUnix FileAttrib IfaBinaryFile IfaTextFile LocalFileHeaderSignature'
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ZipFileConstants class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:16'!
ZipFileConstants class
	instanceVariableNames: ''!

!classDefinition: 'ZipFileConstants class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:16'!
ZipFileConstants class
	instanceVariableNames: ''!

!classDefinition: #InflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ReadStream subclass: #InflateStream
	instanceVariableNames: 'state bitBuf bitPos source sourcePos sourceLimit litTable distTable sourceStream crc'
	classVariableNames: 'BlockProceedBit BlockTypes FixedDistCodes FixedLitCodes MaxBits StateNewBlock StateNoMoreData'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #InflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ReadStream subclass: #InflateStream
	instanceVariableNames: 'state bitBuf bitPos source sourcePos sourceLimit litTable distTable sourceStream crc'
	classVariableNames: 'BlockProceedBit BlockTypes FixedDistCodes FixedLitCodes MaxBits StateNewBlock StateNoMoreData'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'InflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
InflateStream class
	instanceVariableNames: ''!

!classDefinition: 'InflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
InflateStream class
	instanceVariableNames: ''!

!classDefinition: #FastInflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
InflateStream subclass: #FastInflateStream
	instanceVariableNames: ''
	classVariableNames: 'DistanceMap FixedDistTable FixedLitTable LiteralLengthMap'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #FastInflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
InflateStream subclass: #FastInflateStream
	instanceVariableNames: ''
	classVariableNames: 'DistanceMap FixedDistTable FixedLitTable LiteralLengthMap'
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'FastInflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream class
	instanceVariableNames: ''!

!classDefinition: 'FastInflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream class
	instanceVariableNames: ''!

!classDefinition: #GZipReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #GZipReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'GZipConstants'
	category: 'Compression-System'!

!classDefinition: #GZipReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #GZipReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'GZipConstants'
	category: 'Compression-System'!

!classDefinition: 'GZipReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipReadStream class
	instanceVariableNames: ''!

!classDefinition: 'GZipReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipReadStream class
	instanceVariableNames: ''!

!classDefinition: #ZLibReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #ZLibReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZLibReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #ZLibReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZLibReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZLibReadStream class
	instanceVariableNames: ''!

!classDefinition: 'ZLibReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZLibReadStream class
	instanceVariableNames: ''!

!classDefinition: #ZipReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #ZipReadStream
	instanceVariableNames: 'expectedCrc'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZipReadStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
FastInflateStream subclass: #ZipReadStream
	instanceVariableNames: 'expectedCrc'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZipReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipReadStream class
	instanceVariableNames: ''!

!classDefinition: 'ZipReadStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipReadStream class
	instanceVariableNames: ''!

!classDefinition: #DeflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
WriteStream subclass: #DeflateStream
	instanceVariableNames: 'hashHead hashTail hashValue blockPosition blockStart'
	classVariableNames: ''
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: #DeflateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
WriteStream subclass: #DeflateStream
	instanceVariableNames: 'hashHead hashTail hashValue blockPosition blockStart'
	classVariableNames: ''
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: 'DeflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
DeflateStream class
	instanceVariableNames: ''!

!classDefinition: 'DeflateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
DeflateStream class
	instanceVariableNames: ''!

!classDefinition: #ZipWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
DeflateStream subclass: #ZipWriteStream
	instanceVariableNames: 'literals distances literalFreq distanceFreq litCount matchCount encoder crc crcPosition bytesWritten'
	classVariableNames: 'CrcTable VerboseLevel'
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: #ZipWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
DeflateStream subclass: #ZipWriteStream
	instanceVariableNames: 'literals distances literalFreq distanceFreq litCount matchCount encoder crc crcPosition bytesWritten'
	classVariableNames: 'CrcTable VerboseLevel'
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: 'ZipWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream class
	instanceVariableNames: ''!

!classDefinition: 'ZipWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream class
	instanceVariableNames: ''!

!classDefinition: #GZipWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream subclass: #GZipWriteStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'GZipConstants'
	category: 'Compression-System'!

!classDefinition: #GZipWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream subclass: #GZipWriteStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'GZipConstants'
	category: 'Compression-System'!

!classDefinition: 'GZipWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipWriteStream class
	instanceVariableNames: ''!

!classDefinition: 'GZipWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipWriteStream class
	instanceVariableNames: ''!

!classDefinition: #ZLibWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream subclass: #ZLibWriteStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZLibWriteStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipWriteStream subclass: #ZLibWriteStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZLibWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZLibWriteStream class
	instanceVariableNames: ''!

!classDefinition: 'ZLibWriteStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZLibWriteStream class
	instanceVariableNames: ''!

!classDefinition: #ZipEncoder category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
WriteStream subclass: #ZipEncoder
	instanceVariableNames: 'bitBuffer bitPosition encodedStream'
	classVariableNames: ''
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: #ZipEncoder category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
WriteStream subclass: #ZipEncoder
	instanceVariableNames: 'bitBuffer bitPosition encodedStream'
	classVariableNames: ''
	poolDictionaries: 'ZipConstants'
	category: 'Compression-System'!

!classDefinition: 'ZipEncoder class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipEncoder class
	instanceVariableNames: ''!

!classDefinition: 'ZipEncoder class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipEncoder class
	instanceVariableNames: ''!

!classDefinition: #CRCError category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Error subclass: #CRCError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #CRCError category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Error subclass: #CRCError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'CRCError class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
CRCError class
	instanceVariableNames: ''!

!classDefinition: 'CRCError class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
CRCError class
	instanceVariableNames: ''!

!classDefinition: #GZipSurrogateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #GZipSurrogateStream
	instanceVariableNames: 'gZipStream zippedFileStream bufferStream positionThusFar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #GZipSurrogateStream category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #GZipSurrogateStream
	instanceVariableNames: 'gZipStream zippedFileStream bufferStream positionThusFar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'GZipSurrogateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipSurrogateStream class
	instanceVariableNames: ''!

!classDefinition: 'GZipSurrogateStream class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
GZipSurrogateStream class
	instanceVariableNames: ''!

!classDefinition: #ZipEncoderNode category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #ZipEncoderNode
	instanceVariableNames: 'value frequency height bitLength code parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZipEncoderNode category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
Object subclass: #ZipEncoderNode
	instanceVariableNames: 'value frequency height bitLength code parent left right'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZipEncoderNode class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipEncoderNode class
	instanceVariableNames: ''!

!classDefinition: 'ZipEncoderNode class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:16'!
ZipEncoderNode class
	instanceVariableNames: ''!

!classDefinition: #ZipEncoderTree category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #ZipEncoderTree
	instanceVariableNames: 'bitLengths codes maxCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: #ZipEncoderTree category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #ZipEncoderTree
	instanceVariableNames: 'bitLengths codes maxCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-System'!

!classDefinition: 'ZipEncoderTree class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:17'!
ZipEncoderTree class
	instanceVariableNames: ''!

!classDefinition: 'ZipEncoderTree class' category: 'Compression-System' stamp: 'VV 11/10/2022 00:44:17'!
ZipEncoderTree class
	instanceVariableNames: ''!

!classDefinition: #Archive category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #Archive
	instanceVariableNames: 'members'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #Archive category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #Archive
	instanceVariableNames: 'members'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'Archive class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Archive class
	instanceVariableNames: ''!

!classDefinition: 'Archive class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Archive class
	instanceVariableNames: ''!

!classDefinition: #ZipArchive category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Archive subclass: #ZipArchive
	instanceVariableNames: 'centralDirectorySize centralDirectoryOffsetWRTStartingDiskNumber zipFileComment writeCentralDirectoryOffset writeEOCDOffset'
	classVariableNames: ''
	poolDictionaries: 'ZipFileConstants'
	category: 'Compression-Archives'!

!classDefinition: #ZipArchive category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Archive subclass: #ZipArchive
	instanceVariableNames: 'centralDirectorySize centralDirectoryOffsetWRTStartingDiskNumber zipFileComment writeCentralDirectoryOffset writeEOCDOffset'
	classVariableNames: ''
	poolDictionaries: 'ZipFileConstants'
	category: 'Compression-Archives'!

!classDefinition: 'ZipArchive class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchive class
	instanceVariableNames: ''!

!classDefinition: 'ZipArchive class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchive class
	instanceVariableNames: ''!

!classDefinition: #ArchiveMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #ArchiveMember
	instanceVariableNames: 'fileName isCorrupt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ArchiveMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
Object subclass: #ArchiveMember
	instanceVariableNames: 'fileName isCorrupt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ArchiveMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ArchiveMember class
	instanceVariableNames: ''!

!classDefinition: 'ArchiveMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ArchiveMember class
	instanceVariableNames: ''!

!classDefinition: #ZipArchiveMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ArchiveMember subclass: #ZipArchiveMember
	instanceVariableNames: 'lastModFileDateTime fileAttributeFormat versionMadeBy versionNeededToExtract bitFlag compressionMethod desiredCompressionMethod desiredCompressionLevel internalFileAttributes externalFileAttributes cdExtraField localExtraField fileComment crc32 compressedSize uncompressedSize writeLocalHeaderRelativeOffset readDataRemaining'
	classVariableNames: ''
	poolDictionaries: 'ZipFileConstants'
	category: 'Compression-Archives'!

!classDefinition: #ZipArchiveMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ArchiveMember subclass: #ZipArchiveMember
	instanceVariableNames: 'lastModFileDateTime fileAttributeFormat versionMadeBy versionNeededToExtract bitFlag compressionMethod desiredCompressionMethod desiredCompressionLevel internalFileAttributes externalFileAttributes cdExtraField localExtraField fileComment crc32 compressedSize uncompressedSize writeLocalHeaderRelativeOffset readDataRemaining'
	classVariableNames: ''
	poolDictionaries: 'ZipFileConstants'
	category: 'Compression-Archives'!

!classDefinition: 'ZipArchiveMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember class
	instanceVariableNames: ''!

!classDefinition: 'ZipArchiveMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember class
	instanceVariableNames: ''!

!classDefinition: #ZipFileMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipFileMember
	instanceVariableNames: 'externalFileName stream localHeaderRelativeOffset dataOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ZipFileMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipFileMember
	instanceVariableNames: 'externalFileName stream localHeaderRelativeOffset dataOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ZipFileMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipFileMember class
	instanceVariableNames: ''!

!classDefinition: 'ZipFileMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipFileMember class
	instanceVariableNames: ''!

!classDefinition: #ZipDirectoryMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipFileMember subclass: #ZipDirectoryMember
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ZipDirectoryMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipFileMember subclass: #ZipDirectoryMember
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ZipDirectoryMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipDirectoryMember class
	instanceVariableNames: ''!

!classDefinition: 'ZipDirectoryMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipDirectoryMember class
	instanceVariableNames: ''!

!classDefinition: #ZipNewFileMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipNewFileMember
	instanceVariableNames: 'externalFileName stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ZipNewFileMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipNewFileMember
	instanceVariableNames: 'externalFileName stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ZipNewFileMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipNewFileMember class
	instanceVariableNames: ''!

!classDefinition: 'ZipNewFileMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipNewFileMember class
	instanceVariableNames: ''!

!classDefinition: #ZipStringMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipStringMember
	instanceVariableNames: 'contents stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: #ZipStringMember category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipArchiveMember subclass: #ZipStringMember
	instanceVariableNames: 'contents stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compression-Archives'!

!classDefinition: 'ZipStringMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipStringMember class
	instanceVariableNames: ''!

!classDefinition: 'ZipStringMember class' category: 'Compression-Archives' stamp: 'VV 11/10/2022 00:44:17'!
ZipStringMember class
	instanceVariableNames: ''!
!InflateStream commentStamp: '<historical>' prior: 0!
This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in

[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.

[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"

For more information see the above mentioned RFC 1951 which can for instance be found at

	http://www.leo.org/pub/comp/doc/standards/rfc/index.html

Huffman Tree Implementation Notes:
===========================================
The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):

	table _ initialTable.
	bitsNeeded _ high 8 bits of (table at: 1).		"Determine initial bits"
	table _ initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"
	[bits _ fetch next bitsNeeded bits.			"Grab the bits"
	value _ table at: bits.						"Lookup the value"
	value has high 8 bit set] whileTrue:[		"Check if it's leaf"
		table _ initialTable + (low 16 bits of value).	"No - compute new sub table start"
		bitsNeeded _ high 8 bit of value].		"Compute additional number of bits needed"
	^value
!
!FastInflateStream commentStamp: '<historical>' prior: 0!
This class adds the following optimizations to the basic Inflate decompression:

a) Bit reversed access
If we want to fetch the bits efficiently then we have them in the wrong bit order (e.g., when we should fetch 2r100 we would get 2r001). But since the huffman tree lookup determines the efficiency of the decompression, reversing the bits before traversal is expensive. Therefore the entries in each table are stored in REVERSE BIT ORDER. This is achieved by a reverse increment of the current table index in the huffman table construction phase (see method increment:bits:). According to my measures this speeds up the implementation by about 30-40%.

b) Inplace storage of code meanings and extra bits
Rather than looking up the meaning for each code during decompression of blocks we store the appropriate values directly in the huffman tables, using a pre-defined mapping. Even though this does not make a big difference in speed, it cleans up the code and allows easier translation into primitive code (which is clearly one goal of this implementation).

c) Precomputed huffman tables for fixed blocks
So we don't have to compute the huffman tables from scratch. The precomputed tables are not in our superclass to avoid double storage (and my superclass is more intended for documentation anyways).!
!ZipReadStream commentStamp: 'nk 3/7/2004 18:54' prior: 0!
ZipReadStream is intended for uncompressing the compressed contents of Zip archive members.

Since Zip archive members keep their expected CRC value separately in Zip headers, this class does not attempt to read the CRC from its input stream.

Instead, if you want the CRC verification to work you have to call #expectedCrc: with the expected CRC-32 value from the Zip member header.!
!GZipSurrogateStream commentStamp: 'jmv 6/17/2015 11:47' prior: 0!
A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:

1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.

2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.

| fileStream wa |

wa _ WordArrayForSegment new: 30000.
1 to: wa size do: [ :i | wa at: i put: i].
fileStream _ GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory smalltalkImageDirectory.
fileStream nextPutAll: 'this is a test'.
fileStream nextPutAll: wa.
fileStream reallyClose.
!
!ZipEncoderNode commentStamp: '<historical>' prior: 0!
ZipEncoderNode represents a node in a huffman tree for encoding ZipStreams.

Instance variables:
	value 		<Integer>	- Encoded value
	frequency	<Integer>	- Number of occurences of the encoded value
	height 		<Integer>	- Height of the node in the tree
	bitLength 	<Integer>	- bit length of the code
	code		<Integer>	- Assigned code for this node
	parent		<ZipEncoderNode>		- Parent of this node
	left			<ZipEncoderNode>		- First child of this node
	right		<ZipEncoderNode>		- Second child of this node
!
!ZipEncoderTree commentStamp: '<historical>' prior: 0!
ZipEncoderTree represents a huffman tree for encoding ZipStreams.

Instance variables:
	bitLengths	<WordArray>	 - Bit lengths of each generated code
	codes		<WordArray>	 - Codes for each value
	maxCode		<Integer>	- Maximum value with non-zero frequency!
!Archive commentStamp: '<historical>' prior: 0!
This is the abstract superclass for file archives. Archives can be read from or written to files, and contain members that represent files and directories.!
!ZipArchive commentStamp: '<historical>' prior: 0!
A ZipArchive represents an archive that is read and/or written using the PKZIP file format.

ZipArchive instances know how to read and write such archives; their members are subinstances of ZipArchiveMember.!
!ArchiveMember commentStamp: '<historical>' prior: 0!
This is the abstract superclass for archive members, which are files or directories stored in archives.!
!ZipArchiveMember commentStamp: '<historical>' prior: 0!
Subinstances of me are members in a ZipArchive.
They represent different data sources:
	* ZipDirectoryMember -- a directory to be added to a zip file
	* ZipFileMember -- a file or directory that is already in a zip file
	* ZipNewFilemember -- a file that is to be added to a zip file
	* ZipStringMember -- a string that is to be added to a zip file

They can write their data to another stream either copying, compressing,
or decompressing as desired.!
!ZipFileMember commentStamp: '<historical>' prior: 0!
ZipNewFileMember instances are used to represent files that have been read from a ZipArchive.
Their data stays in the file on disk, so the original Zip file cannot be directly overwritten.!
!ZipDirectoryMember commentStamp: '<historical>' prior: 0!
ZipFileMember instances represent directories inside ZipArchives.
They don't do much other than hold names and permissions (and extra fields).

You can add files in subdirectories to a ZipArchive without using any ZipDirectoryMembers.!
!ZipNewFileMember commentStamp: '<historical>' prior: 0!
ZipNewFileMember instances are used to represent files that are going to be written to a ZipArchive.
Their data comes from external file streams.!
!ZipStringMember commentStamp: '<historical>' prior: 0!
ZipStringMember instances are used to represent files that are going to be written to a ZipArchive.
Their data comes from in-image strings, though.!
!ZipEncoderNode methodsFor: 'printing' stamp: 'ar 12/26/1999 10:46' overrides: 16902975!
printOn: aStream
	super printOn: aStream.
	aStream nextPut:$(;
		nextPutAll:'value = '; print: value;
		nextPutAll:', freq = '; print: frequency;
		nextPutAll:', bitLength = '; print: bitLength;
		nextPutAll:', code = '; print: code;
		nextPutAll:', height = '; print: height; 
	nextPut:$).! !
!ArchiveMember methodsFor: 'printing' stamp: 'nk 12/20/2002 15:11' overrides: 16902975!
printOn: aStream
	super printOn: aStream.
	aStream nextPut: $(;
		nextPutAll: self fileName;
		nextPut: $)! !
!GZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:00'!
gzipMagic
	^GZipMagic! !
!GZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:00' overrides: 16904184!
initialize
	"GZipConstants initialize"
	GZipMagic := 16r8B1F.		"GZIP magic number"
	GZipDeflated := 8.			"Compression method"

	GZipAsciiFlag := 16r01.		"Contents is ASCII"
	GZipContinueFlag := 16r02.	"Part of a multi-part archive"
	GZipExtraField := 16r04.		"Archive has extra fields"
	GZipNameFlag := 16r08.		"Archive has original file name"
	GZipCommentFlag := 16r10.	"Archive has comment"
	GZipEncryptFlag := 16r20.	"Archive is encrypted"
	GZipReservedFlags := 16rC0.	"Reserved" ! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:09' overrides: 16904184!
initialize
	"ZipConstants initialize"
	self initializeDeflateConstants.
	self initializeWriteStreamConstants.! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:06'!
initializeDeflateConstants

	WindowSize _ 16r8000.
	WindowMask _ WindowSize - 1.
	MaxDistance _ WindowSize.

	MinMatch _ 3.
	MaxMatch _ 258.

	HashBits _ 15.
	HashMask _ (1 << HashBits) - 1.
	HashShift _ (HashBits + MinMatch - 1) // MinMatch.
! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:08'!
initializeDistanceCodes
	| dist |
	BaseDistance _ WordArray new: MaxDistCodes.
	DistanceCodes _ WordArray new: 512.
	dist _ 0.
	1 to: 16 do:[:code|
		BaseDistance at: code put: dist.
		1 to: (1 bitShift: (ExtraDistanceBits at: code)) do:[:n|
			dist _ dist + 1.
			DistanceCodes at: dist put: code-1]].
	dist = 256 ifFalse:[self error:'Whoops?!!'].
	dist _ dist >> 7.
	17 to: MaxDistCodes do:[:code|
		BaseDistance at: code put: dist << 7.
		1 to: (1 bitShift: (ExtraDistanceBits at: code)-7) do:[:n|
			dist _ dist + 1.
			DistanceCodes at: 256 + dist put: code-1]].
! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:07'!
initializeExtraBits
	ExtraLengthBits _ 
		WordArray withAll: #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0).
	ExtraDistanceBits _ 
		WordArray withAll: #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).
	ExtraBitLengthBits _ 
		WordArray withAll: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 7).
	BitLengthOrder _
		WordArray withAll: #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15).
! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:08'!
initializeFixedTrees
	"ZipWriteStream initializeFixedTrees"
	| counts nodes |
	FixedLiteralTree _ ZipEncoderTree new.
	FixedLiteralTree maxCode: 287.
	counts _ WordArray new: MaxBits+1.
	counts at: 7+1 put: 24.
	counts at: 8+1 put: 144+8.
	counts at: 9+1 put: 112.
	nodes _ Array new: 288.
	1 to: 288 do:[:i| nodes at: i put: (ZipEncoderNode value: i-1 frequency: 0 height: 0)].
	0 to: 143 do:[:i| (nodes at: i+1) setBitLengthTo: 8].
	144 to: 255 do:[:i| (nodes at: i+1) setBitLengthTo: 9].
	256 to: 279 do:[:i| (nodes at: i+1) setBitLengthTo: 7].
	280 to: 287 do:[:i| (nodes at: i+1) setBitLengthTo: 8].
	FixedLiteralTree buildCodes: nodes counts: counts maxDepth: MaxBits.
	FixedLiteralTree setValuesFrom: nodes.

	FixedDistanceTree _ ZipEncoderTree new.
	FixedDistanceTree maxCode: MaxDistCodes.
	FixedDistanceTree
		bitLengths: ((WordArray new: MaxDistCodes+1) atAllPut: 5)
		codes: ((0 to: MaxDistCodes) collect:[:i| FixedDistanceTree reverseBits: i length: 5]).! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:07'!
initializeLengthCodes
	| length |
	BaseLength _ WordArray new: MaxLengthCodes.
	MatchLengthCodes _ WordArray new: MaxMatch - MinMatch + 1.
	length _ 0.
	1 to: MaxLengthCodes - 1 do:[:code|
		BaseLength at: code put: length.
		1 to: (1 bitShift: (ExtraLengthBits at: code)) do:[:n|
			length _ length + 1.
			MatchLengthCodes at: length put: NumLiterals + code]].
! !
!ZipConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:09'!
initializeWriteStreamConstants

	MaxBits _ 15.
	MaxBitLengthBits _ 7.
	EndBlock _ 256.

	StoredBlock _ 0.
	FixedBlock _ 1.
	DynamicBlock _ 2.

	NumLiterals _ 256.
	MaxLengthCodes _ 29.
	MaxDistCodes _ 30.
	MaxBitLengthCodes _ 19.
	MaxLiteralCodes _ NumLiterals + MaxLengthCodes + 1. "+ End of Block"

	Repeat3To6 _ 16. "Repeat previous bit length 3-6 times (2 bits repeat count)"
	Repeat3To10 _ 17. "Repeat previous bit length 3-10 times (3 bits repeat count)"
	Repeat11To138 _ 18. "Repeat previous bit length 11-138 times (7 bits repeat count)"

	self initializeExtraBits.
	self initializeLengthCodes.
	self initializeDistanceCodes.
	self initializeFixedTrees.
! !
!ZipFileConstants class methodsFor: 'pool initialization' stamp: 'ar 5/18/2003 19:20' overrides: 16904184!
initialize
	"ZipFileConstants initialize"
	FaMsdos		:= 0.
	FaUnix 		:= 3.
	DeflatingCompressionNormal		:= 0.
	DeflatingCompressionMaximum	:= 2.
	DeflatingCompressionFast		:= 4.
	DeflatingCompressionSuperFast	:= 6.
	CompressionStored				:= 0.
	CompressionDeflated				:= 8.
	CompressionLevelNone			:= 0.
	CompressionLevelDefault			:= 6.
	IfaTextFile						:= 1.
	IfaBinaryFile					:= 0.
	CentralDirectoryFileHeaderSignature	:= 0.
	LocalFileHeaderSignature 			:= 0.
	EndOfCentralDirectorySignature 		:= 0.
	DataDescriptorLength 				:= 12.

	"Unix permission bits"
	DefaultDirectoryPermissions		:= 8r040755.
	DefaultFilePermissions			:= 8r0100666.
	DirectoryAttrib 					:= 8r040000.
	FileAttrib 						:= 8r0100000.

	CentralDirectoryFileHeaderSignature _ 
		(ByteArray with: 16r50 with: 16r4B with: 16r01 with: 16r02) asString.
	LocalFileHeaderSignature _
		(ByteArray with: 16r50 with: 16r4B with: 16r03 with: 16r04) asString.
	EndOfCentralDirectorySignature _
		(ByteArray with: 16r50 with: 16r4B with: 16r05 with: 16r06) asString.! !
!InflateStream methodsFor: 'testing' stamp: 'jmv 3/1/2010 11:28' overrides: 16914201!
atEnd
	"Note: It is possible that we have a few bits left,
	representing just the EOB marker. To check for
	this we must force decompression of the next
	block if at end of data."
	super atEnd ifFalse:[^false]. "Primitive test"
	(position >= readLimit and:[state = StateNoMoreData]) ifTrue:[^true].
	"Force decompression, by calling #next. Since #moveContentsToFront
	will never move data to the beginning of the buffer it is safe to
	skip back the read position afterwards"
	self next
		ifNil: [^ true].
	position _ position - 1.
	^false! !
!InflateStream methodsFor: 'bit access' stamp: 'jmv 3/1/2010 11:28'!
bitPosition
	"Return the current bit position of the source"
	^sourceStream
		ifNil: [sourcePos * 8 + bitPos]
		ifNotNil: [sourceStream position + sourcePos * 8 + bitPos]! !
!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:00'!
nextBits: n
	| bits |
	[bitPos < n] whileTrue:[
		bitBuf _ bitBuf + (self nextByte bitShift: bitPos).
		bitPos _ bitPos + 8].
	bits _ bitBuf bitAnd: (1 bitShift: n)-1.
	bitBuf _ bitBuf bitShift: 0 - n.
	bitPos _ bitPos - n.
	^bits! !
!InflateStream methodsFor: 'bit access' stamp: 'ar 12/5/1998 14:54'!
nextByte
	^source byteAt: (sourcePos _ sourcePos + 1)! !
!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:01'!
nextSingleBits: n
	| out |
	out _ 0.
	1 to: n do:[:i| out _ (out bitShift: 1) + (self nextBits: 1)].
	^out! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:31' overrides: 16945886!
close
	sourceStream ifNotNil:[sourceStream close].! !
!InflateStream methodsFor: 'accessing' stamp: 'jmv 7/12/2016 10:11:19' overrides: 50365948!
contents
	"Use a copy to avoid modifying receiver.
	The copy is shallow, i.e. cheap."
	^ self copy upToEnd! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/22/1999 01:29' overrides: 16922435!
next
	"Answer the next decompressed object in the Stream represented by the
	receiver."

	<primitive: 65>
	position >= readLimit
		ifTrue: [^self pastEndRead]
		ifFalse: [^collection at: (position _ position + 1)]! !
!InflateStream methodsFor: 'accessing' stamp: 'nk 3/7/2004 18:45' overrides: 16922442!
next: anInteger 
	"Answer the next anInteger elements of my collection.  overriden for simplicity"
	| newArray |

	"try to do it the fast way"
	position + anInteger < readLimit ifTrue: [
		newArray _ collection copyFrom: position + 1 to: position + anInteger.
		position _ position + anInteger.
		^newArray
	].

	"oh, well..."
	newArray _ collection species new: anInteger.
	1 to: anInteger do: [:index | newArray at: index put: (self next ifNil: [ ^newArray copyFrom: 1 to: index - 1]) ].
	^newArray! !
!InflateStream methodsFor: 'accessing' stamp: 'jmv 3/1/2010 11:29' overrides: 16922453!
next: n into: buffer startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| c numRead count |
	numRead _ 0.
	["Force decompression if necessary"
	(c _ self next)
		ifNil: [ ^buffer copyFrom: 1 to: startIndex+numRead-1 ].
	"Store the first value which provoked decompression"
	buffer at: startIndex + numRead put: c.
	numRead _ numRead + 1.
	"After collection has been filled copy as many objects as possible"
	count _ (readLimit - position) min: (n - numRead).
	buffer 
		replaceFrom: startIndex + numRead 
		to: startIndex + numRead + count - 1 
		with: collection 
		startingAt: position+1.
	position _ position + count.
	numRead _ numRead + count.
	numRead = n] whileFalse.
	^buffer! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19' overrides: 16922493!
size
	"This is a compressed stream - we don't know the size beforehand"
	^self shouldNotImplement! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/21/1999 23:54'!
sourceLimit
	^sourceLimit! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/21/1999 23:52'!
sourcePosition
	^sourcePos! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:31'!
sourceStream
	^sourceStream! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19' overrides: 16914102!
upTo: anObject 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of anObject in the receiver. If 
	anObject is not in the collection, answer the entire rest of the receiver."
	| newStream element |
	newStream _ WriteStream on: (collection species new: 100).
	[self atEnd or: [(element _ self next) = anObject]]
		whileFalse: [newStream nextPut: element].
	^newStream contents! !
!InflateStream methodsFor: 'accessing' stamp: 'ar 12/22/1999 02:04' overrides: 16922517!
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	| newStream buffer |
	buffer _ collection species new: 1000.
	newStream _ WriteStream on: (collection species new: 100).
	[self atEnd] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].
	^ newStream contents! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/21/1999 22:59'!
computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits
	"Assign numerical values to all codes.
	Note: The values are stored according to the bit length"
	| offsets values baseOffset codeLength |
	offsets _ Array new: maxBits.
	offsets atAllPut: 0.
	baseOffset _ 1.
	minBits to: maxBits do:[:bits|
		offsets at: bits put: baseOffset.
		baseOffset _ baseOffset + (counts at: bits+1)].
	values _ WordArray new: aCollection size.
	1 to: aCollection size do:[:i|
		codeLength _ aCollection at: i.
		codeLength > 0 ifTrue:[
			baseOffset _ offsets at: codeLength.
			values at: baseOffset put: i-1.
			offsets at: codeLength put: baseOffset + 1]].
	^values! !
!InflateStream methodsFor: 'huffman trees' stamp: 'sma 5/12/2000 10:49'!
createHuffmanTables: values counts: counts from: minBits to: maxBits
	"Create the actual tables"
	| table tableStart tableSize tableEnd 
	valueIndex tableStack numValues deltaBits maxEntries
	lastTable lastTableStart tableIndex lastTableIndex |

	table _ WordArray new: ((4 bitShift: minBits) max: 16).

	"Create the first entry - this is a dummy.
	It gives us information about how many bits to fetch initially."
	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"

	"Create the first table from scratch."
	tableStart _ 2. "See above"
	tableSize _ 1 bitShift: minBits.
	tableEnd _ tableStart + tableSize.
	"Store the terminal symbols"
	valueIndex _ (counts at: minBits+1).
	tableIndex _ 0.
	1 to: valueIndex do:[:i|
		table at: tableStart + tableIndex put: (values at: i).
		tableIndex _ self increment: tableIndex bits: minBits].
	"Fill up remaining entries with invalid entries"
	tableStack _ OrderedCollection new: 10. "Should be more than enough"
	tableStack addLast: 
		(Array 
			with: minBits	"Number of bits (e.g., depth) for this table"
			with: tableStart	"Start of table"
			with: tableIndex "Next index in table"
			with: minBits	"Number of delta bits encoded in table"
			with: tableSize - valueIndex "Entries remaining in table").
	"Go to next value index"
	valueIndex _ valueIndex + 1.
	"Walk over remaining bit lengths and create new subtables"
	minBits+1 to: maxBits do:[:bits|
		numValues _ counts at: bits+1.
		[numValues > 0] whileTrue:["Create a new subtable"
			lastTable _ tableStack last.
			lastTableStart _ lastTable at: 2.
			lastTableIndex _ lastTable at: 3.
			deltaBits _ bits - (lastTable at: 1).
			"Make up a table of deltaBits size"
			tableSize _ 1 bitShift: deltaBits.
			tableStart _ tableEnd.
			tableEnd _ tableEnd + tableSize.
			[tableEnd > table size ]
				whileTrue:[table _ self growHuffmanTable: table].
			"Connect to last table"
			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"
			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.
			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).
			lastTable at: 5 put: (lastTable at: 5) - 1.
			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"
			"Store terminal values"
			maxEntries _ numValues min: tableSize.
			tableIndex _ 0.
			1 to: maxEntries do:[:i|
				table at: tableStart + tableIndex put: (values at: valueIndex).
				valueIndex _ valueIndex + 1.
				numValues _ numValues - 1.
				tableIndex _ self increment: tableIndex bits: deltaBits].
			"Check if we have filled up the current table completely"
			maxEntries = tableSize ifTrue:[
				"Table has been filled. Back up to the last table with space left."
				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]
						whileTrue:[tableStack removeLast].
			] ifFalse:[
				"Table not yet filled. Put it back on the stack."
				tableStack addLast:
					(Array
						with: bits		"Nr. of bits in this table"
						with: tableStart	"Start of table"
						with: tableIndex "Index in table"
						with: deltaBits	"delta bits of table"
						with: tableSize - maxEntries "Unused entries in table").
			].
		].
	].
	 ^table copyFrom: 1 to: tableEnd-1! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:25'!
decodeDynamicTable: nItems from: aHuffmanTable
	"Decode the code length of the literal/length and distance table
	in a block compressed with dynamic huffman trees"
	| values index value repCount theValue |
	values _ Array new: nItems.
	index _ 1.
	theValue _ 0.
	[index <= nItems] whileTrue:[
		value _ self decodeValueFrom: aHuffmanTable.
		value < 16 ifTrue:[
			"Immediate values"
			theValue _ value.
			values at: index put: value.
			index _ index+1.
		] ifFalse:[
			"Repeated values"
			value = 16 ifTrue:[
				"Repeat last value"
				repCount _ (self nextBits: 2) + 3.
			] ifFalse:[
				"Repeat zero value"
				theValue _ 0.
				value = 17 
					ifTrue:[repCount _ (self nextBits: 3) + 3]
					ifFalse:[value = 18 
								ifTrue:[repCount _ (self nextBits: 7) + 11]
								ifFalse:[^self error:'Invalid bits tree value']]].
			0 to: repCount-1 do:[:i| values at: index+i put: theValue].
			index _ index + repCount].
	].
	^values! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:51'!
distanceMap
	"This is used by the fast decompressor"
	^nil! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/3/1998 13:16'!
growHuffmanTable: table
	| newTable |
	newTable _ table species new: table size * 2.
	newTable replaceFrom: 1 to: table size with: table startingAt: 1.
	^newTable! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:27'!
huffmanTableFrom: aCollection mappedBy: valueMap
	"Create a new huffman table from the given code lengths.
	Map the actual values by valueMap if it is given.
	See the class comment for a documentation of the huffman
	tables used in this decompressor."
	| counts  values table minBits maxBits |
	minBits _ MaxBits + 1.
	maxBits _ 0.
	"Count the occurences of each code length and compute minBits and maxBits"
	counts _ Array new: MaxBits+1.
	counts atAllPut: 0.
	aCollection do:[:length| 
		length > 0 ifTrue:[
			length < minBits ifTrue:[minBits _ length].
			length > maxBits ifTrue:[maxBits _ length].
			counts at: length+1 put: (counts at: length+1)+1]].
	maxBits = 0 ifTrue:[^nil]. "Empty huffman table"

	"Assign numerical values to all codes."
	values _ self computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits.

	"Map the values if requested"
	self mapValues: values by: valueMap.

	"Create the actual tables"
	table _ self createHuffmanTables: values counts: counts from: minBits to: maxBits.

	^table! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!
increment: value bits: nBits
	"Increment a value of nBits length.
	The fast decompressor will do this differently"
	^value+1! !
!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:50'!
literalLengthMap
	"This is used by the fast decompressor"
	^nil! !
!InflateStream methodsFor: 'huffman trees' stamp: 'jmv 3/2/2010 16:07'!
mapValues: values by: valueMap
	| oldValue |
	valueMap ifNil:[^values].
	1 to: values size do:[:i|
		oldValue _ values at: i.
		"Note: there may be nil values if not all values are used"
		oldValue
			ifNil: [ ^values]
			ifNotNil: [ values at: i put: (valueMap at: oldValue+1)]]! !
!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:04'!
crcError: aString
	^CRCError signal: aString! !
!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:49'!
updateCrc: oldCrc from: start to: stop in: aCollection
	"Answer an updated CRC for the range of bytes in aCollection.
	Subclasses can implement the appropriate means for the check sum they wish to use."
	^oldCrc! !
!InflateStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:22'!
verifyCrc
	"Verify the crc checksum in the input"! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:24'!
decodeValueFrom: table
	"Decode the next value in the receiver using the given huffman table."
	| bits bitsNeeded tableIndex value |
	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"
	tableIndex _ 2.							"First real table"
	[bits _ self nextSingleBits: bitsNeeded.	"Get bits"
	value _ table at: (tableIndex + bits).		"Lookup entry in table"
	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"
		whileFalse:["Fetch sub table"
			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"
			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"
			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].
	^value! !
!InflateStream methodsFor: 'inflating' stamp: 'yo 5/9/2014 15:19'!
decompressBlock: llTable with: dTable
	"Process the compressed data in the block.
	llTable is the huffman table for literal/length codes
	and dTable is the huffman table for distance codes."
	| value extra length distance oldPos oldBits oldBitPos |
	[readLimit < collection size and: [sourcePos <= sourceLimit]] whileTrue: [
		"Back up stuff if we're running out of space"
		oldBits _ bitBuf.
		oldBitPos _ bitPos.
		oldPos _ sourcePos.
		value _ self decodeValueFrom: llTable.
		value < 256 ifTrue:[ "A literal"
			collection byteAt: (readLimit _ readLimit + 1) put: value.
		] ifFalse: ["length/distance or end of block"
			value = 256 ifTrue:["End of block"
				state _ state bitAnd: StateNoMoreData.
				^self].
			"Compute the actual length value (including possible extra bits)"
			extra _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0) at: value - 256.
			length _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258) at: value - 256.
			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].
			"Compute the distance value"
			value _ self decodeValueFrom: dTable.
			extra _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13) at: value+1.
			distance _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769
						1025 1537 2049 3073 4097 6145 8193 12289 16385 24577) at: value+1.
			extra > 0 ifTrue: [distance _ distance + (self nextBits: extra)].
			(readLimit + length >= collection size) ifTrue:[
				bitBuf _ oldBits.
				bitPos _ oldBitPos.
				sourcePos _ oldPos.
				^self].
			collection 
					replaceFrom: readLimit+1 
					to: readLimit + length
					with: collection 
					startingAt: readLimit - distance + 1.
			readLimit _ readLimit + length.
		].
	].! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!
proceedDynamicBlock
	self decompressBlock: litTable with: distTable! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!
proceedFixedBlock
	self decompressBlock: litTable with: distTable! !
!InflateStream methodsFor: 'inflating' stamp: 'jmv 3/1/2010 11:29'!
proceedStoredBlock
	"Proceed decompressing a stored (e.g., uncompressed) block"
	| length decoded |
	"Literal table must be nil for a stored block"
	litTable
		ifNotNil: [^ self error: 'Bad state'].
	length _ distTable.
	[length > 0 and:[readLimit < collection size and:[sourcePos < sourceLimit]]] 
		whileTrue:[
			collection at: (readLimit _ readLimit + 1) put: 
				(source at: (sourcePos _ sourcePos + 1)).
			length _ length - 1].
	length = 0 ifTrue:[state _ state bitAnd: StateNoMoreData].
	decoded _ length - distTable.
	distTable _ length.
	^decoded! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 01:46'!
processDynamicBlock
	| nLit nDist nLen codeLength lengthTable bits |
	nLit _ (self nextBits: 5) + 257.
	nDist _ (self nextBits: 5) + 1.
	nLen _ (self nextBits: 4) + 4.
	codeLength _ Array new: 19.
	codeLength atAllPut: 0.
	1 to: nLen do:[:i|
		bits _ #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15) at: i.
		codeLength at: bits+1 put: (self nextBits: 3).
	].
	lengthTable _ self huffmanTableFrom: codeLength mappedBy: nil.
	"RFC 1951: In other words, all code lengths form a single sequence..."
	codeLength _ self decodeDynamicTable: nLit+nDist from: lengthTable.
	litTable _ self 
				huffmanTableFrom: (codeLength copyFrom: 1 to: nLit)
				mappedBy: self literalLengthMap.
	distTable _ self 
				huffmanTableFrom: (codeLength copyFrom: nLit+1 to: codeLength size)
				mappedBy: self distanceMap.
	state _ state bitOr: BlockProceedBit.
	self proceedDynamicBlock.! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:13'!
processFixedBlock
	litTable _ self 
				huffmanTableFrom: FixedLitCodes
				mappedBy: self literalLengthMap.
	distTable _ self 
				huffmanTableFrom: FixedDistCodes
				mappedBy: self distanceMap.
	state _ state bitOr: BlockProceedBit.
	self proceedFixedBlock.! !
!InflateStream methodsFor: 'inflating' stamp: 'ar 12/27/1999 13:49'!
processStoredBlock
	| chkSum length |
	"Skip to byte boundary"
	self nextBits: (bitPos bitAnd: 7).
	length _ self nextBits: 16.
	chkSum _ self nextBits: 16.
	(chkSum bitXor: 16rFFFF) = length
		ifFalse:[^self error:'Bad block length'].
	litTable _ nil.
	distTable _ length.
	state _ state bitOr: BlockProceedBit.
	^self proceedStoredBlock! !
!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!
decompressAll
	"Profile the decompression speed"
	[self atEnd] whileFalse:[
		position _ readLimit.
		self next "Provokes decompression"
	].! !
!InflateStream methodsFor: 'private' stamp: 'jmv 3/1/2010 11:29'!
getFirstBuffer
	"Get the first source buffer after initialization has been done"
	sourceStream
		ifNil: [^ self].
	source _ sourceStream next: 1 << 16. "This is more than enough..."
	sourceLimit _ source size! !
!InflateStream methodsFor: 'private' stamp: 'ar 12/3/1998 17:32'!
getNextBlock
	^self nextBits: 3! !
!InflateStream methodsFor: 'private' stamp: 'ar 12/23/1999 15:17'!
moveContentsToFront
	"Move the decoded contents of the receiver to the front so that we have enough space for decoding more data."
	| delta |
	readLimit > 32768 ifTrue:[
		delta _ readLimit - 32767.
		collection 
			replaceFrom: 1 
			to: collection size - delta + 1 
			with: collection 
			startingAt: delta.
		position _ position - delta + 1.
		readLimit _ readLimit - delta + 1].! !
!InflateStream methodsFor: 'private' stamp: 'ar 12/23/1999 15:27'!
moveSourceToFront
	"Move the encoded contents of the receiver to the front so that we have enough space for decoding more data."
	(sourceStream == nil or:[sourceStream atEnd]) ifTrue:[^self].
	sourcePos > 10000 ifTrue:[
		source 
			replaceFrom: 1 
			to: source size - sourcePos
			with: source 
			startingAt: sourcePos + 1.
		source _ sourceStream 
			next: sourcePos 
			into: source 
			startingAt: source size - sourcePos + 1.
		sourcePos _ 0.
		sourceLimit _ source size].! !
!InflateStream methodsFor: 'private' stamp: 'ar 2/29/2004 04:18'!
pastEndRead
	"A client has attempted to read beyond the read limit.
	Check in what state we currently are and perform
	the appropriate action"
	| blockType bp oldLimit |
	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"
	"Check if we can move decoded data to front"
	self moveContentsToFront.
	"Check if we can fetch more source data"
	self moveSourceToFront.
	state = StateNewBlock ifTrue:[state _ self getNextBlock].
	blockType _ state bitShift: -1.
	bp _ self bitPosition.
	oldLimit := readLimit.
	self perform: (BlockTypes at: blockType+1).
	"Note: if bit position hasn't advanced then nothing has been decoded."
	bp = self bitPosition 
		ifTrue:[^self primitiveFailed].
	"Update crc for the decoded contents"
	readLimit > oldLimit 
		ifTrue:[crc _ self updateCrc: crc from: oldLimit+1 to: readLimit in: collection].
	state = StateNoMoreData ifTrue:[self verifyCrc].
	^self next! !
!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!
profile
	"Profile the decompression speed"
	MessageTally spyOn:[self decompressAll].! !
!InflateStream methodsFor: 'initialization' stamp: 'jmv 1/12/2010 11:51' overrides: 50361502!
on: aCollectionOrStream
	(aCollectionOrStream is: #Stream)
		ifTrue: [	aCollectionOrStream binary.
				sourceStream _ aCollectionOrStream.
				self getFirstBuffer]
		ifFalse: [ source _ aCollectionOrStream].
	^self on: source from: 1 to: source size.! !
!InflateStream methodsFor: 'initialization' stamp: 'ar 12/23/1999 15:35' overrides: 16922523!
on: aCollection from: firstIndex to: lastIndex
	bitBuf _ bitPos _ 0.
	"The decompression buffer has a size of at 64k,
	since we may have distances up to 32k back and
	repetitions of at most 32k length forward"
	collection _ aCollection species new: 1 << 16.
	readLimit _ 0. "Not yet initialized"
	position _ 0.
	source _ aCollection.
	sourceLimit _ lastIndex.
	sourcePos _ firstIndex-1.
	state _ StateNewBlock.! !
!InflateStream methodsFor: 'initialization' stamp: 'ar 12/3/1998 16:32' overrides: 16914327!
reset
	"Position zero - nothing decoded yet"
	position _ readLimit _ 0.
	sourcePos _ 0.
	bitBuf _ bitPos _ 0.
	state _ 0.! !
!InflateStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 19:12' overrides: 16904184!
initialize
	"InflateStream initialize"
	MaxBits _ 16.
	StateNewBlock _ 0.
	StateNoMoreData _ 1.
	BlockProceedBit _ 8.
	BlockTypes _ #(	processStoredBlock	"New block in stored format"
					processFixedBlock	"New block with fixed huffman tables"
					processDynamicBlock	"New block with dynamic huffman tables"
					errorBadBlock		"Bad block format"
					proceedStoredBlock	"Continue block in stored format"
					proceedFixedBlock	"Continue block in fixed format"
					proceedDynamicBlock	"Continue block in dynamic format"
					errorBadBlock		"Bad block format").
	"Initialize fixed block values"
	FixedLitCodes _ 	((1 to: 144) collect:[:i| 8]),
					((145 to: 256) collect:[:i| 9]),
					((257 to: 280) collect:[:i| 7]),
					((281 to: 288) collect:[:i| 8]).
	FixedDistCodes _ ((1 to: 32) collect:[:i| 5]).! !
!FastInflateStream methodsFor: 'inflating' stamp: 'yo 5/9/2014 15:19' overrides: 50595572!
decompressBlock: llTable with: dTable
	"Process the compressed data in the block.
	llTable is the huffman table for literal/length codes
	and dTable is the huffman table for distance codes."
	| value extra length distance oldPos oldBits oldBitPos |
	<primitive: 'primitiveInflateDecompressBlock' module: 'ZipPlugin'>
	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[
		"Back up stuff if we're running out of space"
		oldBits _ bitBuf.
		oldBitPos _ bitPos.
		oldPos _ sourcePos.
		value _ self decodeValueFrom: llTable.
		value < 256 ifTrue:[ "A literal"
			collection byteAt: (readLimit _ readLimit + 1) put: value.
		] ifFalse: ["length/distance or end of block"
			value = 256 ifTrue:["End of block"
				state _ state bitAnd: StateNoMoreData.
				^self].
			"Compute the actual length value (including possible extra bits)"
			extra _ (value bitShift: -16) - 1.
			length _ value bitAnd: 16rFFFF.
			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].
			"Compute the distance value"
			value _ self decodeValueFrom: dTable.
			extra _ (value bitShift: -16).
			distance _ value bitAnd: 16rFFFF.
			extra > 0 ifTrue: [distance _ distance + (self nextBits: extra)].
			(readLimit + length >= collection size) ifTrue:[
				bitBuf _ oldBits.
				bitPos _ oldBitPos.
				sourcePos _ oldPos.
				^self].
			collection 
					replaceFrom: readLimit+1 
					to: readLimit + length
					with: collection 
					startingAt: readLimit - distance + 1.
			readLimit _ readLimit + length.
		].
	].! !
!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:15' overrides: 50595690!
processFixedBlock
	litTable _ FixedLitTable.
	distTable _ FixedDistTable.
	state _ state bitOr: BlockProceedBit.
	self proceedFixedBlock.! !
!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26' overrides: 50595460!
distanceMap
	^DistanceMap! !
!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48' overrides: 50595508!
increment: value bits: nBits
	"Increment value in reverse bit order, e.g. 
	for a 3 bit value count as follows:
		000 / 100 / 010 / 110
		001 / 101 / 011 / 111
	See the class comment why we need this."
	| result bit |
	result _ value.
	"Test the lowest bit first"
	bit _ 1 << (nBits - 1).
	"If the currently tested bit is set then we need to
	turn this bit off and test the next bit right to it"
	[(result bitAnd: bit) = 0] whileFalse:[ 
		"Turn off current bit"
		result _ result bitXor: bit.
		"And continue testing the next bit"
		bit _ bit bitShift: -1].
	"Turn on the right-most bit that we haven't touched in the loop above"
	^result bitXor: bit! !
!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26' overrides: 50595515!
literalLengthMap
	^LiteralLengthMap! !
!FastInflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:02' overrides: 50595176!
nextSingleBits: n
	"Fetch the bits all at once"
	^self nextBits: n.! !
!FastInflateStream class methodsFor: 'class initialization' stamp: 'ar 12/21/1999 23:00' overrides: 50595839!
initialize
	"FastInflateStream initialize"
	| low high |

	"Init literal/length map"
	low _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 ).
	high _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0 0).
	LiteralLengthMap _ WordArray new: 256 + 32.
	1 to: 257 do:[:i| LiteralLengthMap at: i put: i-1].
	1 to: 29 do:[:i| LiteralLengthMap at: 257+i put: (low at:i) + ( (high at: i) + 1 << 16)].

	"Init distance map"
	high _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).
	low _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769
			1025 1537 2049 3073 4097 6145 8193 12289 16385 24577).
	DistanceMap _ WordArray new: 32.
	1 to: 30 do:[:i| DistanceMap at: i put: (low at: i) + ( (high at: i) << 16)].

	"Init fixed block huffman tables"
	FixedLitTable _ self basicNew
				huffmanTableFrom: FixedLitCodes
				mappedBy: LiteralLengthMap.
	FixedDistTable _ self basicNew
				huffmanTableFrom: FixedDistCodes
				mappedBy: DistanceMap.! !
!GZipReadStream methodsFor: 'initialization' stamp: 'ar 2/29/2004 03:32' overrides: 50595815!
on: aCollection from: firstIndex to: lastIndex
	"Check the header of the GZIP stream."
	| method magic flags length |
	super on: aCollection from: firstIndex to: lastIndex.
	crc _ 16rFFFFFFFF.
	magic _ self nextBits: 16.
	(magic = GZipMagic) 
		ifFalse:[^self error:'Not a GZipped stream'].
	method _ self nextBits: 8.
	(method = GZipDeflated)
		ifFalse:[^self error:'Bad compression method'].
	flags _ self nextBits: 8.
	(flags anyMask: GZipEncryptFlag) 
		ifTrue:[^self error:'Cannot decompress encrypted stream'].
	(flags anyMask: GZipReservedFlags)
		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].
	"Ignore stamp, extra flags, OS type"
	self nextBits: 16; nextBits: 16. "stamp"
	self nextBits: 8. "extra flags"
	self nextBits: 8. "OS type"
	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"
		ifTrue:[self nextBits: 16]. 
	(flags anyMask: GZipExtraField) "Extra fields - ignored"
		ifTrue:[	length _ self nextBits: 16.
				1 to: length do:[:i| self nextBits: 8]].
	(flags anyMask: GZipNameFlag) "Original file name - ignored"
		ifTrue:[[(self nextBits: 8) = 0] whileFalse].
	(flags anyMask: GZipCommentFlag) "Comment - ignored"
		ifTrue:[[(self nextBits: 8) = 0] whileFalse].
! !
!GZipReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:30' overrides: 50595535!
updateCrc: oldCrc from: start to: stop in: aCollection
	"Answer an updated CRC for the range of bytes in aCollection"
	^ZipWriteStream updateCrc: oldCrc from: start to: stop in: aCollection.! !
!GZipReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:20' overrides: 50595544!
verifyCrc
	| stored |
	stored := 0.
	0 to: 24 by: 8 do: [ :i |
		sourcePos >= sourceLimit ifTrue: [ ^ self crcError: 'No checksum (proceed to ignore)' ].
		stored := stored + (self nextByte bitShift: i) ].
	stored := stored bitXor: 16rFFFFFFFF.
	stored = crc ifFalse: [ ^ self crcError: 'Wrong checksum (proceed to ignore)' ].
	^stored! !
!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pb 2/26/2020 13:51:16'!
fileReaderServicesForFileEntry: aFileEntry suffix: suffix
	"FileList buttons that are serviced by us."

	^suffix = 'gz'
		ifTrue: [ {self serviceViewDecompress. self serviceDecompressToFile} ]
		ifFalse: [ #() ]! !
!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'jmv 6/24/2020 16:07:05'!
saveContents: aFileEntry
	"Save the contents of a gzipped file"
	| zipped buffer newFile |
	newFile := aFileEntry parent // aFileEntry baseName.
	newFile writeStreamDo: [ :unzipped |
		unzipped binary.
		aFileEntry readStreamDo: [ :zipContents |
			zipped _ GZipReadStream on: zipContents.
			buffer _ ByteArray new: 50000.
			'Extracting ' , aFileEntry asString
				displayProgressAt: Sensor mousePoint
				from: 0
				to: zipped sourceStream size
				during: [ :barBlock | 
					[ zipped atEnd ]
						whileFalse: [
							barBlock value: zipped sourceStream position.
							unzipped nextPutAll: (zipped nextInto: buffer) ]]]].
	^ newFile ! !
!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'HAW 1/2/2019 18:36:16'!
serviceDecompressToFile

	^ (SimpleServiceEntry 
		provider: self 
		label: 'decompress to file'
		selector: #saveContents:
		description: 'decompress to file'
		icon: #goTopIcon) triggerFileListChanged! !
!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'HAW 1/2/2019 18:37:36'!
serviceViewDecompress

	^ SimpleServiceEntry 
		provider: self 
		label: 'view decompressed'
		selector: #viewContents:
		description: 'view decompressed'
		icon: #findIcon! !
!GZipReadStream class methodsFor: 'fileIn/Out' stamp: 'pb 2/26/2020 13:44:18'!
viewContents: aFileEntry
	"Open the decompressed contents of the .gz file with the given name.  This method is only required for the registering-file-list of Squeak 3.3a and beyond, but does no harm in an earlier system"

	(aFileEntry readStream ) ifNotNil: [ :aStream | 
		aStream viewGZipContents]! !
!ZLibReadStream methodsFor: 'initialization' stamp: 'ar 2/29/2004 03:31' overrides: 50595815!
on: aCollection from: firstIndex to: lastIndex
	"Check the header of the ZLib stream."
	| method byte |
	super on: aCollection from: firstIndex to: lastIndex.
	crc _ 1.
	method _ self nextBits: 8.
	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].
	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].
	byte _ self nextBits: 8.
	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].
	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].
! !
!ZLibReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 03:30' overrides: 50595535!
updateCrc: oldCrc from: start to: stop in: aCollection
	"Answer an updated CRC for the range of bytes in aCollection"
	^ZLibWriteStream updateAdler32: oldCrc from: start to: stop in: aCollection.! !
!ZLibReadStream methodsFor: 'crc' stamp: 'ar 2/29/2004 04:21' overrides: 50595544!
verifyCrc
	| stored |
	stored := 0.
	24 to: 0 by: -8 do: [ :i |
		sourcePos >= sourceLimit ifTrue: [ ^ self crcError: 'No checksum (proceed to ignore)' ].
		stored := stored + (self nextByte bitShift: i) ].
	stored = crc ifFalse: [ ^ self crcError: 'Wrong checksum (proceed to ignore)' ].
	^stored! !
!ZipReadStream methodsFor: 'crc' stamp: 'nk 3/7/2004 18:55'!
expectedCrc: aNumberOrNil
	"If expectedCrc is set, it will be compared against the calculated CRC32 in verifyCrc.
	This number should be the number read from the Zip header (which is the bitwise complement of my crc if all is working correctly)"
	expectedCrc _ aNumberOrNil! !
!ZipReadStream methodsFor: 'crc' stamp: 'nk 3/7/2004 15:32' overrides: 50595535!
updateCrc: oldCrc from: start to: stop in: aCollection
	^ZipWriteStream updateCrc: oldCrc from: start to: stop in: aCollection! !
!ZipReadStream methodsFor: 'crc' stamp: 'jmv 2/22/2011 22:55' overrides: 50595544!
verifyCrc
	"Verify the CRC-32 checksum calculated from the input against the expected CRC-32, if any.
	Answer the calculated CRC-32 in any case.
	Note that the CRC-32 used in Zip files is actually the bit inverse of the calculated value, so that is what is returned."

	| invertedCrc |
	invertedCrc _ crc bitXor: 16rFFFFFFFF.
	(expectedCrc notNil and: [ expectedCrc ~= invertedCrc ])
		ifTrue: [ ^ self crcError: ('Wrong CRC-32 (expected {1} got {2}) (proceed to ignore)' format: { expectedCrc hex. invertedCrc hex }) ].
	^invertedCrc! !
!ZipReadStream methodsFor: 'initialization' stamp: 'nk 3/7/2004 15:31' overrides: 50595815!
on: aCollection from: firstIndex to: lastIndex
	super on: aCollection from: firstIndex to: lastIndex.
	crc _ 16rFFFFFFFF.
	expectedCrc _ nil.! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 20:24'!
compare: here with: matchPos min: minLength
	"Compare the two strings and return the length of matching characters.
	minLength is a lower bound for match lengths that will be accepted.
	Note: here and matchPos are zero based."
	| length |
	"First test if we can actually get longer than minLength"
	(collection at: here+minLength+1) = (collection at: matchPos+minLength+1)
		ifFalse:[^0].
	(collection at: here+minLength) = (collection at: matchPos+minLength)
		ifFalse:[^0].
	"Then test if we have an initial match at all"
	(collection at: here+1) = (collection at: matchPos+1)
		ifFalse:[^0].
	(collection at: here+2) = (collection at: matchPos+2)
		ifFalse:[^1].
	"Finally do the real comparison"
	length _ 3.
	[length <= MaxMatch and:[
		(collection at: here+length) = (collection at: matchPos+length)]]
			whileTrue:[length _ length + 1].
	^length - 1! !
!DeflateStream methodsFor: 'deflating' stamp: 'jmv 3/1/2010 09:56'!
deflateBlock
	"Deflate the current contents of the stream"
	| flushNeeded lastIndex |
	blockStart ifNil: [
		"One time initialization for the first block"
		1 to: MinMatch-1 do:[:i| self updateHashAt: i].
		blockStart _ 0].

	[blockPosition < position] whileTrue:[
		(position + MaxMatch > writeLimit)
			ifTrue:[lastIndex _ writeLimit - MaxMatch]
			ifFalse:[lastIndex _ position].
		flushNeeded _ self deflateBlock: lastIndex-1
							chainLength: self hashChainLength
							goodMatch: self goodMatchLength.
		flushNeeded ifTrue:[
			self flushBlock.
			blockStart _ blockPosition].
		"Make room for more data"
		self moveContentsToFront].
! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 18:05'!
deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch
	"Continue deflating the receiver's collection from blockPosition to lastIndex.
	Note that lastIndex must be at least MaxMatch away from the end of collection"
	| here matchResult flushNeeded hereMatch hereLength newMatch newLength hasMatch |
	blockPosition > lastIndex ifTrue:[^false]. "Nothing to deflate"
	hasMatch _ false.
	here _ blockPosition.
	[here <= lastIndex] whileTrue:[
		hasMatch ifFalse:[
			"Find the first match"
			matchResult _ self findMatch: here
								lastLength: MinMatch-1
								lastMatch: here
								chainLength: chainLength
								goodMatch: goodMatch.
			self insertStringAt: here. "update hash table"
			hereMatch _ matchResult bitAnd: 16rFFFF.
			hereLength _ matchResult bitShift: -16].

		"Look ahead if there is a better match at the next position"
		matchResult _ self findMatch: here+1
							lastLength: hereLength
							lastMatch: hereMatch
							chainLength: chainLength
							goodMatch: goodMatch.
		newMatch _ matchResult bitAnd: 16rFFFF.
		newLength _ matchResult bitShift: -16.

		"Now check if the next match is better than the current one.
		If not, output the current match (provided that the current match
		is at least MinMatch long)"
		(hereLength >= newLength and:[hereLength >= MinMatch]) ifTrue:[
			self assert:[self validateMatchAt: here
							from: hereMatch to: hereMatch + hereLength - 1].
			"Encode the current match"
			flushNeeded _ self
				encodeMatch: hereLength
				distance: here - hereMatch.
			"Insert all strings up to the end of the current match.
			Note: The first string has already been inserted."
			1 to: hereLength-1 do:[:i| self insertStringAt: (here _ here + 1)].
			hasMatch _ false.
			here _ here + 1.
		] ifFalse:[
			"Either the next match is better than the current one or we didn't
			have a good match after all (e.g., current match length < MinMatch).
			Output a single literal."
			flushNeeded _ self encodeLiteral: (collection byteAt: (here + 1)).
			here _ here + 1.
			(here <= lastIndex and:[flushNeeded not]) ifTrue:[
				"Cache the results for the next round"
				self insertStringAt: here.
				hasMatch _ true.
				hereMatch _ newMatch.
				hereLength _ newLength].
		].
		flushNeeded ifTrue:[blockPosition _ here. ^true].
	].
	blockPosition _ here.
	^false! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:45'!
findMatch: here lastLength: lastLength lastMatch: lastMatch chainLength: maxChainLength goodMatch: goodMatch
	"Find the longest match for the string starting at here.
	If there is no match longer than lastLength return lastMatch/lastLength.
	Traverse at most maxChainLength entries in the hash table.
	Stop if a match of at least goodMatch size has been found."
	| matchResult matchPos distance chainLength limit bestLength length |
	"Compute the default match result"
	matchResult _ (lastLength bitShift: 16) bitOr: lastMatch.

	"There is no way to find a better match than MaxMatch"
	lastLength >= MaxMatch ifTrue:[^matchResult].

	"Start position for searches"
	matchPos _ hashHead at: (self updateHashAt: here + MinMatch) + 1.

	"Compute the distance to the (possible) match"
	distance _ here - matchPos.

	"Note: It is required that 0 < distance < MaxDistance"
	(distance > 0 and:[distance < MaxDistance]) ifFalse:[^matchResult].

	chainLength _ maxChainLength.	"Max. nr of match chain to search"
	here > MaxDistance	"Limit for matches that are too old"
		ifTrue:[limit _ here - MaxDistance]
		ifFalse:[limit _ 0].

	"Best match length so far (current match must be larger to take effect)"
	bestLength _ lastLength.

	["Compare the current string with the string at match position"
	length _ self compare: here with: matchPos min: bestLength.
	"Truncate accidental matches beyound stream position"
	(here + length > position) ifTrue:[length _ position - here].
	"Ignore very small matches if they are too far away"
	(length = MinMatch and:[(here - matchPos) > (MaxDistance // 4)])
		ifTrue:[length _ MinMatch - 1].
	length > bestLength ifTrue:["We have a new (better) match than before"
		"Compute the new match result"
		matchResult _ (length bitShift: 16) bitOr: matchPos.
		bestLength _ length.
		"There is no way to find a better match than MaxMatch"
		bestLength >= MaxMatch ifTrue:[^matchResult].
		"But we may have a good, fast match"
		bestLength > goodMatch ifTrue:[^matchResult].
	].
	(chainLength _ chainLength - 1) > 0] whileTrue:[
		"Compare with previous entry in hash chain"
		matchPos _ hashTail at: (matchPos bitAnd: WindowMask) + 1.
		matchPos <= limit ifTrue:[^matchResult]. "Match position is too old"
	].
	^matchResult! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:37'!
flushBlock
	"Flush a deflated block"! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:46'!
insertStringAt: here
	"Insert the string at the given start position into the hash table.
	Note: The hash value is updated starting at MinMatch-1 since
	all strings before have already been inserted into the hash table
	(and the hash value is updated as well)."
	| prevEntry |
	hashValue _ self updateHashAt: (here + MinMatch).
	prevEntry _ hashHead at: hashValue+1.
	hashHead at: hashValue+1 put: here.
	hashTail at: (here bitAnd: WindowMask)+1 put: prevEntry.! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:48'!
updateHash: nextValue
	"Update the running hash value based on the next input byte.
	Return the new updated hash value."
	^((hashValue bitShift: HashShift) bitXor: nextValue) bitAnd: HashMask.! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:47'!
updateHashAt: here
	"Update the hash value at position here (one based)"
	^self updateHash: (collection byteAt: here)! !
!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:43'!
validateMatchAt: pos from: startPos to: endPos
	| here |
	here _ pos.
	startPos+1 to: endPos+1 do:[:i|
		(collection at: i) = (collection at: (here _ here + 1))
			ifFalse:[^self error:'Not a match']].
	^true! !
!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!
encodeLiteral: literal
	"Encode the given literal.
	Return true if the current block needs to be flushed."
	^false! !
!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!
encodeMatch: matchLength distance: matchDistance
	"Encode a match of the given length and distance.
	Return true if the current block should be flushed."
	^false! !
!DeflateStream methodsFor: 'initialization' stamp: 'ar 12/29/1999 17:30' overrides: 16945731!
flush
	"Force compression"
	self deflateBlock.! !
!DeflateStream methodsFor: 'initialization' stamp: 'ar 12/31/1999 18:00' overrides: 16920235!
initialize
	blockStart _ nil.
	blockPosition _ 0.
	hashValue _ 0.
	self initializeHashTables.! !
!DeflateStream methodsFor: 'initialization' stamp: 'ar 12/29/1999 17:32'!
initializeHashTables
	hashHead _ WordArray new: 1 << HashBits.
	hashTail _ WordArray new: WindowSize.
! !
!DeflateStream methodsFor: 'initialization' stamp: 'ar 12/29/1999 17:33' overrides: 50405197!
on: aCollection
	self initialize.
	super on: (aCollection species new: WindowSize * 2).! !
!DeflateStream methodsFor: 'initialization' stamp: 'ar 12/28/1999 17:34'!
on: aCollection from: firstIndex to: lastIndex
	"Not for DeflateStreams please"
	^self shouldNotImplement! !
!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!
goodMatchLength
	"Return the length that is considered to be a 'good' match.
	Higher values will result in better compression but take more time."
	^MaxMatch "Best compression"! !
!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!
hashChainLength
	"Return the max. number of hash chains to traverse.
	Higher values will result in better compression but take more time."
	^4096 "Best compression"! !
!DeflateStream methodsFor: 'accessing' stamp: 'ar 2/19/2004 00:34' overrides: 16982981!
next: bytes putAll: aCollection startingAt: startPos
	(startPos = 1 and:[bytes = aCollection size]) 
		ifTrue:[^self nextPutAll: aCollection].
	^self nextPutAll: (aCollection copyFrom: startPos to: startPos + bytes - 1)! !
!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 17:33' overrides: 50365979!
nextPutAll: aCollection
	| start count max |
	aCollection species = collection species
		ifFalse:[
			aCollection do:[:ch| self nextPut: ch].
			^aCollection].
	start _ 1.
	count _ aCollection size.
	[count = 0] whileFalse:[
		position = writeLimit ifTrue:[self deflateBlock].
		max _ writeLimit - position.
		max > count ifTrue:[max _ count].
		collection replaceFrom: position+1
			to: position+max
			with: aCollection
			startingAt: start.
		start _ start + max.
		count _ count - max.
		position _ position + max].
	^aCollection! !
!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/28/1999 17:35' overrides: 16983276!
pastEndPut: anObject
	self deflateBlock.
	^self nextPut: anObject! !
!DeflateStream methodsFor: 'private' stamp: 'ar 12/29/1999 17:50'!
moveContentsToFront
	"Move the contents of the receiver to the front"
	| delta |
	delta _ (blockPosition - WindowSize).
	delta <= 0 ifTrue:[^self].
	"Move collection"
	collection 
		replaceFrom: 1 
		to: collection size - delta 
		with: collection 
		startingAt: delta+1.
	position _ position - delta.
	"Move hash table entries"
	blockPosition _ blockPosition - delta.
	blockStart _ blockStart - delta.
	self updateHashTable: hashHead delta: delta.
	self updateHashTable: hashTail delta: delta.! !
!DeflateStream methodsFor: 'private' stamp: 'ar 2/2/2001 15:47'!
updateHashTable: table delta: delta
	| pos |
	<primitive: 'primitiveDeflateUpdateHashTable' module: 'ZipPlugin'>
	1 to: table size do:[:i|
		"Discard entries that are out of range"
		(pos _ table at: i) >= delta
			ifTrue:[table at: i put: pos - delta]
			ifFalse:[table at: i put: 0]].! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 2/28/2001 13:39' overrides: 16945886!
close
	self deflateBlock.
	self flushBlock: true.
	encoder close.! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 2/27/2001 13:23'!
finish
	"Finish pending operation. Do not close output stream."
	self deflateBlock.
	self flushBlock: true.
	encoder flush.! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 12/30/1999 00:40' overrides: 50596482!
initialize
	super initialize.
	literals _ ByteArray new: WindowSize.
	distances _ WordArray new: WindowSize.
	literalFreq _ WordArray new: MaxLiteralCodes.
	distanceFreq _ WordArray new: MaxDistCodes.
	self initializeNewBlock.
! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 12/29/1999 18:29'!
initializeNewBlock
	"Initialize the encoder for a new block of data"
	literalFreq atAllPut: 0.
	distanceFreq atAllPut: 0.
	literalFreq at: EndBlock+1 put: 1.
	litCount _ 0.
	matchCount _ 0.! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 2/24/2001 19:43' overrides: 50596495!
on: aCollectionOrStream
	crc _ 16rFFFFFFFF.
	crcPosition _ 1.
	bytesWritten _ 0.
	encoder _ ZipEncoder on: aCollectionOrStream.
	encoder isBinary
		ifTrue:[super on: ByteArray new]
		ifFalse:[super on: String new].
	self writeHeader.
! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'nk 2/17/2004 16:31'!
release
	"We're done with compression. Do some cleanup."
	literals _ distances _ literalFreq _ distanceFreq _ nil.
	self updateCrc.
	encoder flushBits.
	self writeFooter.! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'nk 2/17/2004 16:30'!
writeFooter
	"Write footer information if necessary"
	crc _ crc bitXor: 16rFFFFFFFF.! !
!ZipWriteStream methodsFor: 'initialization' stamp: 'ar 2/24/2001 19:44'!
writeHeader
	"Write header information if necessary"! !
!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 2/24/2001 19:46'!
crc
	^crc! !
!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!
encodedStream
	^encoder encodedStream! !
!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 18:32'!
forcedMethod
	"Return a symbol describing an enforced method or nil if the method should
	be chosen adaptively. Valid symbols are
		#stored	- store blocks (do not compress)
		#fixed	- use fixed huffman trees
		#dynamic	- use dynamic huffman trees."
	^nil! !
!ZipWriteStream methodsFor: 'deflating' stamp: 'ar 2/2/2001 15:47' overrides: 50596268!
deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch
	"^DeflatePlugin doPrimitive:#primitiveDeflateBlock"
	<primitive: 'primitiveDeflateBlock' module: 'ZipPlugin'>
	^super deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 01:55'!
dynamicBlockSizeFor: lTree and: dTree using: blTree and: blFreq
	"Compute the length for the current block using dynamic huffman trees"
	| bits index extra treeBits freq |
	bits _ 3 "block type" + 5 "literal codes length" + 5 "distance codes length".

	"Compute the # of bits for sending the bit length tree"
	treeBits _ 4. "Max index for bit length tree"
	index _ MaxBitLengthCodes.
	[index >= 4] whileTrue:[
		(index = 4 or:[(blFreq at: (BitLengthOrder at: index)+1) > 0])
			ifTrue:[treeBits _ treeBits + (index * 3).
					index _ -1]
			ifFalse:[index _ index - 1]].

	"Compute the # of bits for sending the literal/distance tree.
	Note: The frequency are already stored in the blTree"
	0 to: 15 do:[:i| "First, the non-repeating values"
		freq _ blFreq at: i+1.
		freq > 0 ifTrue:[treeBits _ treeBits + (freq * (blTree bitLengthAt: i))]].
	"Now the repeating values"
	(Repeat3To6 to: Repeat11To138) with: #(2 3 7) do:[:i :addl|
		freq _ blFreq at: i+1.
		freq > 0 ifTrue:[
			treeBits _ treeBits + (freq * ((blTree bitLengthAt: i) + addl "addl bits"))]].
	VerboseLevel > 1 ifTrue:[
		Transcript show:'['; print: treeBits; show:' bits for dynamic tree]'].
	bits _ bits + treeBits.

	"Compute the size of the compressed block"
	0 to: NumLiterals do:[:i| "encoding of literals"
		freq _ literalFreq at: i+1.
		freq > 0 ifTrue:[bits _ bits + (freq * (lTree bitLengthAt: i))]].
	NumLiterals+1 to: lTree maxCode do:[:i| "encoding of match lengths"
		freq _ literalFreq at: i+1.
		extra _ ExtraLengthBits at: i-NumLiterals.
		freq > 0 ifTrue:[bits _ bits + (freq * ((lTree bitLengthAt: i) + extra))]].
	0 to: dTree maxCode do:[:i| "encoding of distances"
		freq _ distanceFreq at: i+1.
		extra _ ExtraDistanceBits at: i+1.
		freq > 0 ifTrue:[bits _ bits + (freq * ((dTree bitLengthAt: i) + extra))]].

	^bits! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!
scanBitLength: bitLength repeatCount: repeatCount into: anArray
	"Update the frequency for the aTree based on the given values"
	| count |
	count _ repeatCount.
	bitLength = 0 ifTrue:[
		[count >= 11] whileTrue:[
			anArray at: Repeat11To138+1 put: (anArray at: Repeat11To138+1) + 1.
			count _ (count - 138) max: 0].
		[count >= 3] whileTrue:[
			anArray at: Repeat3To10+1 put: (anArray at: Repeat3To10+1) + 1.
			count _ (count - 10) max: 0].
		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].
	] ifFalse:[
		anArray at: bitLength+1 put: (anArray at: bitLength+1) + 1.
		count _ count - 1.
		[count >= 3] whileTrue:[
			anArray at: Repeat3To6+1 put: (anArray at: Repeat3To6+1) + 1.
			count _ (count - 6) max: 0].
		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].
	].! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!
scanBitLengths: bits into: anArray
	"Scan the trees and determine the frequency of the bit lengths.
	For repeating codes, emit a repeat count."
	| lastValue lastCount value |
	bits size = 0 ifTrue:[^self].
	lastValue _ bits at: 1.
	lastCount _ 1.
	2 to: bits size do:[:i|
		value _ bits at: i.
		value = lastValue 
			ifTrue:[lastCount _ lastCount + 1]
			ifFalse:[self scanBitLength: lastValue repeatCount: lastCount into: anArray.
					lastValue _ value.
					lastCount _ 1]].
	self scanBitLength: lastValue repeatCount: lastCount into: anArray.! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!
sendBitLength: bitLength repeatCount: repeatCount tree: aTree
	"Send the given bitLength, repeating repeatCount times"
	| count |
	count _ repeatCount.
	bitLength = 0 ifTrue:[
		[count >= 11] whileTrue:[
			self sendBitLength: Repeat11To138 tree: aTree.
			encoder nextBits: 7 put: (count min: 138) - 11.
			count _ (count - 138) max: 0].
		[count >= 3] whileTrue:[
			self sendBitLength: Repeat3To10 tree: aTree.
			encoder nextBits: 3 put: (count min: 10) - 3.
			count _ (count - 10) max: 0].
		count timesRepeat:[self sendBitLength: bitLength tree: aTree].
	] ifFalse:[
		self sendBitLength: bitLength tree: aTree.
		count _ count - 1.
		[count >= 3] whileTrue:[
			self sendBitLength: Repeat3To6 tree: aTree.
			encoder nextBits: 2 put: (count min: 6) - 3.
			count _ (count - 6) max: 0].
		count timesRepeat:[self sendBitLength: bitLength tree: aTree].
	].! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!
sendBitLength: bitLength tree: aTree
	"Send the given bitLength"
	encoder nextBits: (aTree bitLengthAt: bitLength) 
		put: (aTree codeAt: bitLength).! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!
sendBitLengthTree: blTree
	"Send the bit length tree"
	| blIndex bitLength |
	MaxBitLengthCodes to: 4 by: -1 do:[:maxIndex|
		blIndex _ BitLengthOrder at: maxIndex.
		bitLength _ blIndex <= blTree maxCode 
			ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].
		(maxIndex = 4 or:[bitLength > 0]) ifTrue:[
			encoder nextBits: 4 put: maxIndex - 4.
			1 to: maxIndex do:[:j|
				blIndex _ BitLengthOrder at: j.
				bitLength _ blIndex <= blTree maxCode 
					ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].
				encoder nextBits: 3 put: bitLength].
			^self]].! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 00:48'!
sendCompressedBlock: litTree with: distTree
	"Send the current block using the encodings from the given literal/length and distance tree"
	| sum |
	sum _ encoder
			sendBlock: (ReadStream on: literals from: 1 to: litCount)
			with: (ReadStream on: distances from: 1 to: litCount)
			with: litTree
			with: distTree.
	sum = (blockPosition - blockStart) ifFalse:[self error:'Wrong number of bytes'].! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/29/1999 18:19'!
sendDynamicBlock: blTree literalTree: lTree distanceTree: dTree bitLengths: bits
	"Send a block using dynamic huffman trees"
	self sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits.
	self sendCompressedBlock: lTree with: dTree.! !
!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!
sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits
	"Send all the trees needed for dynamic huffman tree encoding"
	| lastValue lastCount value |
	encoder nextBits: 5 put: (lTree maxCode - 256).
	encoder nextBits: 5 put: (dTree maxCode).
	self sendBitLengthTree: blTree.
	bits size = 0 ifTrue:[^self].
	lastValue _ bits at: 1.
	lastCount _ 1.
	2 to: bits size do:[:i|
		value _ bits at: i.
		value = lastValue 
			ifTrue:[lastCount _ lastCount + 1]
			ifFalse:[self sendBitLength: lastValue repeatCount: lastCount tree: blTree.
					lastValue _ value.
					lastCount _ 1]].
	self sendBitLength: lastValue repeatCount: lastCount tree: blTree.! !
!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05' overrides: 50596462!
encodeLiteral: lit
	"Encode the given literal"
	litCount _ litCount + 1.
	literals at: litCount put: lit.
	distances at: litCount put: 0.
	literalFreq at: lit+1 put: (literalFreq at: lit+1) + 1.
	^self shouldFlush! !
!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05' overrides: 50596468!
encodeMatch: length distance: dist
	"Encode the given match of length length starting at dist bytes ahead"
	| literal distance |
	dist > 0 
		ifFalse:[^self error:'Distance must be positive'].
	length < MinMatch 
		ifTrue:[^self error:'Match length must be at least ', MinMatch printString].
	litCount _ litCount + 1.
	matchCount _ matchCount + 1.
	literals at: litCount put: length - MinMatch.
	distances at: litCount put: dist.
	literal _ (MatchLengthCodes at: length - MinMatch + 1).
	literalFreq at: literal+1 put: (literalFreq at: literal+1) + 1.
	dist < 257
		ifTrue:[distance _ DistanceCodes at: dist]
		ifFalse:[distance _ DistanceCodes at: 257 + (dist - 1 bitShift: -7)].
	distanceFreq at: distance+1 put: (distanceFreq at: distance+1) + 1.
	^self shouldFlush! !
!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08' overrides: 50596417!
flushBlock
	^self flushBlock: false! !
!ZipWriteStream methodsFor: 'encoding' stamp: 'jmv 3/13/2012 12:58'!
flushBlock: lastBlock
	"Send the current block"
	| lastFlag bitsRequired method bitsSent
	storedLength fixedLength dynamicLength 
	blTree lTree dTree blBits blFreq |

	lastFlag _ lastBlock ifTrue:[1] ifFalse:[0].

	"Compute the literal/length and distance tree"
	lTree _ ZipEncoderTree buildTreeFrom: literalFreq maxDepth: MaxBits.
	dTree _ ZipEncoderTree buildTreeFrom: distanceFreq maxDepth: MaxBits.

	"Compute the bit length tree"
	blBits _ lTree bitLengths, dTree bitLengths.
	blFreq _ WordArray new: MaxBitLengthCodes.
	self scanBitLengths: blBits into: blFreq.
	blTree _ ZipEncoderTree buildTreeFrom: blFreq maxDepth: MaxBitLengthBits.

	"Compute the bit length for the current block.
	Note: Most of this could be computed on the fly but it's getting
	really ugly in this case so we do it afterwards."
	storedLength _ self storedBlockSize.
	fixedLength _ self fixedBlockSizeFor: lTree and: dTree.
	dynamicLength _ self dynamicBlockSizeFor: lTree and: dTree 
							using: blTree and: blFreq.
	VerboseLevel > 1 ifTrue:[
		Transcript newLine; show:'Block sizes (S/F/D):';
			space; print: storedLength // 8; 
			nextPut:$/; print: fixedLength // 8; 
			nextPut:$/; print: dynamicLength // 8; space; endEntry].

	"Check which method to use"
	method _ self forcedMethod.
	method ifNil: [ 
		method _ (storedLength < fixedLength and:[storedLength < dynamicLength]) 
			ifTrue:[#stored]
			ifFalse:[fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]]].
	(method == #stored and:[blockStart < 0]) ifTrue:[
		"Cannot use #stored if the block is not available"
		method _ fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]].

	bitsSent _ encoder bitPosition. "# of bits sent before this block"
	bitsRequired _ nil.

	(method == #stored) ifTrue:[
		VerboseLevel > 0 ifTrue:[Transcript show:'S'].
		bitsRequired _ storedLength.
		encoder nextBits: 3 put: StoredBlock << 1 + lastFlag.
		self sendStoredBlock].

	(method == #fixed) ifTrue:[
		VerboseLevel > 0 ifTrue:[Transcript show:'F'].
		bitsRequired _ fixedLength.
		encoder nextBits: 3 put: FixedBlock << 1 + lastFlag.
		self sendFixedBlock].

	(method == #dynamic) ifTrue:[
		VerboseLevel > 0 ifTrue:[Transcript show:'D'].
		bitsRequired _ dynamicLength.
		encoder nextBits: 3 put: DynamicBlock << 1 + lastFlag.
		self sendDynamicBlock: blTree 
			literalTree: lTree 
			distanceTree: dTree 
			bitLengths: blBits].

	bitsRequired = (encoder bitPosition - bitsSent)
		ifFalse:[self error:'Bits size mismatch'].

	lastBlock 
		ifTrue:[self release]
		ifFalse:[self initializeNewBlock].! !
!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08'!
shouldFlush
	"Check if we should flush the current block.
	Flushing can be useful if the input characteristics change."
	| nLits |
	litCount = literals size ifTrue:[^true]. "We *must* flush"
	(litCount bitAnd: 16rFFF) = 0 ifFalse:[^false]. "Only check every N kbytes"
	matchCount * 10 <= litCount ifTrue:[
		"This is basically random data. 
		There is no need to flush early since the overhead
		for encoding the trees will add to the overall size"
		^false].
	"Try to adapt to the input data.
	We flush if the ratio between matches and literals
	changes beyound a certain threshold"
	nLits _ litCount - matchCount.
	nLits <= matchCount ifTrue:[^false]. "whow!! so many matches"
	^nLits * 4 <= matchCount! !
!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!
fixedBlockSizeFor: lTree and: dTree
	"Compute the length for the current block using fixed huffman trees"
	| bits extra |
	bits _ 3 "block type".
	"Compute the size of the compressed block"
	0 to: NumLiterals do:[:i| "encoding of literals"
		bits _ bits + ((literalFreq at: i+1) * (FixedLiteralTree bitLengthAt: i))].
	NumLiterals+1 to: lTree maxCode+1 do:[:i| "Encoding of match lengths"
		extra _ ExtraLengthBits at: i-NumLiterals.
		bits _ bits + ((literalFreq at: i+1) * ((FixedLiteralTree bitLengthAt: i) + extra))].
	0 to: dTree maxCode do:[:i| "encoding of distances"
		extra _ ExtraDistanceBits at: i+1.
		bits _ bits + ((distanceFreq at: i+1) * ((FixedDistanceTree bitLengthAt: i) + extra))].

	^bits! !
!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!
sendFixedBlock
	"Send a block using fixed huffman trees"
	self sendCompressedBlock: FixedLiteralTree with: FixedDistanceTree.! !
!ZipWriteStream methodsFor: 'private' stamp: 'ar 2/24/2001 19:45' overrides: 50596558!
moveContentsToFront
	"Need to update crc here"
	self updateCrc.
	super moveContentsToFront.
	crcPosition _ position + 1.! !
!ZipWriteStream methodsFor: 'private' stamp: 'ar 2/24/2001 19:45'!
updateCrc
	crcPosition <= position ifTrue:[
		bytesWritten _ bytesWritten + position - crcPosition + 1.
		crc _ self updateCrc: crc from: crcPosition to: position in: collection.
		crcPosition _ position + 1].! !
!ZipWriteStream methodsFor: 'private' stamp: 'nk 2/17/2004 16:51'!
updateCrc: oldCrc from: start to: stop in: aCollection
	^self class updateCrc: oldCrc from: start to: stop in: aCollection! !
!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 1/2/2000 16:36'!
sendStoredBlock
	"Send an uncompressed block"
	| inBytes |
	inBytes _ blockPosition - blockStart.
	encoder flushBits. "Skip to byte boundary"
	encoder nextBits: 16 put: inBytes.
	encoder nextBits: 16 put: (inBytes bitXor: 16rFFFF).
	encoder flushBits.
	1 to: inBytes do:[:i|
		encoder nextBytePut: (collection byteAt: blockStart+i)].! !
!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 12/30/1999 00:42'!
storedBlockSize
	"Compute the length for the current block when stored as is"
	^3 "block type bits" 
		+ (8 - (encoder bitPosition + 3 bitAnd: 7) bitAnd: 7)"skipped bits to byte boundary"
			+ 32 "byte length + chksum" 
				+ (blockPosition - blockStart * 8) "actual data bits".! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!
baseDistance
	^BaseDistance! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!
baseLength
	^BaseLength! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 2/24/2001 19:42'!
crcTable
	^CrcTable! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!
distanceCodes
	^DistanceCodes! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!
extraDistanceBits
	^ExtraDistanceBits! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!
extraLengthBits
	^ExtraLengthBits! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!
matchLengthCodes
	^MatchLengthCodes! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!
maxDistanceCodes
	^MaxDistCodes! !
!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!
maxLiteralCodes
	^MaxLiteralCodes! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 7/17/2017 15:51:45'!
compressAndDecompress: aFile using: tempName stats: stats
	| fileSize tempFile result |
	aFile
		ifNil: [^ nil].
	fileSize _ aFile size.
	(fileSize < 1"00000" "or:[fileSize > 1000000]") ifTrue:[aFile close. ^nil].
	Transcript newLine; show:'Testing ', aFile name,' ... '.
	tempFile _ StandardFileStream new open: tempName forWrite: true.
	'Compressing ', aFile name,'...' displayProgressAt: Sensor mousePoint
		from: 1 to: aFile size during:[:barBlock|
			result _ self regressionCompress: aFile into: tempFile notifiying: barBlock stats: stats].
	result ifTrue:[
		'Validating ', aFile name,'...' displayProgressAt: Sensor mousePoint
			from: 0 to: aFile size during:[:barBlock|
				result _ self regressionDecompress: aFile from: tempFile notifying: barBlock stats: stats]].
	aFile close.
	tempFile close.
	(DirectoryEntry smalltalkImageDirectory // tempName) delete.
	result ~~ false ifTrue:[
		Transcript show:' ok (', (result * 100 truncateTo: 0.01) printString,')'].
	^result! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'pb 5/25/2016 01:30'!
logProblem: reason for: aFile

	'problems.log' asFileEntry appendStreamDo: [ :errFile |
		errFile
			newLine;
			nextPutAll: aFile name;
			newLine;
			nextPutAll: reason ].
	Transcript show:' failed (', reason,')'.
	aFile close.
	^false! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 1/9/2014 23:32'!
printRegressionStats: stats from: fd
	| raw compressed numFiles |
	raw _ stats at: #rawSize ifAbsent:[0].
	raw = 0 ifTrue:[^self].
	compressed _ stats at: #compressedSize ifAbsent:[0].
	numFiles _ stats at: #numFiles ifAbsent:[0].
	Transcript newLine; nextPutAll: fd pathName.
	Transcript newLine; tab; nextPutAll:'Files compressed: ', numFiles printStringWithCommas.
	Transcript newLine; tab; nextPutAll:'Bytes compressed: ', raw printStringWithCommas.
	Transcript newLine; tab; nextPutAll:'Avg. compression ratio: ';
		print: ((compressed / raw asFloat * 100.0) truncateTo: 0.01).
	Transcript endEntry.! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 7/17/2017 15:52:09'!
regressionCompress: aFile into: tempFile notifiying: progressBarBlock stats: stats
	"Compress aFile into tempFile"
	| zip encoded buffer |
	aFile binary.
	aFile position: 0.
	tempFile binary.
	buffer _ ByteArray new: 4096.
	zip _ self on: (ByteArray new: 10000).
	encoded _ zip encodedStream.
	[aFile atEnd] whileFalse:[
		progressBarBlock value: aFile position.
		zip nextPutAll: (aFile nextInto: buffer).
		encoded position > 0 ifTrue:[
			tempFile nextPutAll: encoded contents.
			encoded position: 0]].
	zip close.
	tempFile nextPutAll: encoded contents.
	^true! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 7/17/2017 15:52:23'!
regressionDecompress: aFile from: tempFile notifying: progressBarBlock stats: stats
	"Validate aFile as decompressed from tempFile"
	| unzip rawSize compressedSize buffer1 buffer2 |
	rawSize _ aFile size.
	compressedSize _ tempFile size.
	aFile ascii.
	aFile position: 0.
	tempFile ascii.
	tempFile position: 0.
	buffer1 _ ByteArray new: 4096.
	buffer2 _ buffer1 copy.
	unzip _ FastInflateStream on: tempFile.
	[aFile atEnd] whileFalse:[
		progressBarBlock value: aFile position.
		buffer1 _ aFile nextInto: buffer1.
		buffer2 _ unzip nextInto: buffer2.
		buffer1 = buffer2
			ifFalse:[^self logProblem: 'contents ' for: aFile].
	].
	unzip next ifNotNil: [ ^self logProblem: 'EOF' for: aFile].
	stats at: #rawSize put:
		(stats at: #rawSize ifAbsent:[0]) + rawSize.
	stats at: #compressedSize put:
		(stats at: #compressedSize ifAbsent:[0]) + compressedSize.
	^compressedSize asFloat / rawSize asFloat.! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'pb 5/25/2016 01:16'!
regressionTest 
	"
	ZipWriteStream regressionTest
	"
	"Compress and decompress everything we can 
	find to validate that compression works as expected."
	self regressionTestFrom: DirectoryEntry smalltalkImageDirectory! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'pb 5/25/2016 01:16'!
regressionTestFrom: fd
	"ZipWriteStream regressionTestFrom: FileDirectory currentDirectory"
	"ZipWriteStream regressionTestFrom: (FileDirectory on:'')"
	"ZipWriteStream regressionTestFrom: (FileDirectory on:'C:')"
	| stats entry |
	Transcript clear.
	stats _ Dictionary new.
	entry _ (DirectoryEntry smalltalkImageDirectory // '$$sqcompress$$').
	entry exists ifTrue: [ entry delete ].
	self regressionTestFrom: fd using: entry pathName stats: stats.! !
!ZipWriteStream class methodsFor: 'regression test' stamp: 'jmv 11/3/2016 10:22:29'!
regressionTestFrom: fd using: tempName stats: stats
	| files file fullName |
	files _ fd fileNames asArray sort.
	files do: [ :fName |
		file _ nil.
		fullName _ (fd // fName) pathName.
		fullName = tempName ifFalse: [
			file _ StandardFileStream new
				open: fullName
				forWrite: false ].
		self
			compressAndDecompress: file
			using: tempName
			stats: stats ].
	stats
		at: #numFiles
		put:
			(stats
				at: #numFiles
				ifAbsent: [ 0 ]) + files size.
	files _ nil.
	self
		printRegressionStats: stats
		from: fd.
	fd directoryNames asArray sort do: [ :dName |
		self
			regressionTestFrom: fd / dName
			using: tempName
			stats: stats ].! !
!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 5/18/2003 19:10' overrides: 16904184!
initialize
	"ZipWriteStream initialize"
	VerboseLevel := 0.
	self initializeCrcTable.! !
!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 2/24/2001 19:42'!
initializeCrcTable
	"ZipWriteStream initialize"
	CrcTable _ #(16r00000000 16r77073096 16rEE0E612C 16r990951BA 16r076DC419
  16r706AF48F 16rE963A535 16r9E6495A3 16r0EDB8832 16r79DCB8A4
  16rE0D5E91E 16r97D2D988 16r09B64C2B 16r7EB17CBD 16rE7B82D07
  16r90BF1D91 16r1DB71064 16r6AB020F2 16rF3B97148 16r84BE41DE
  16r1ADAD47D 16r6DDDE4EB 16rF4D4B551 16r83D385C7 16r136C9856
  16r646BA8C0 16rFD62F97A 16r8A65C9EC 16r14015C4F 16r63066CD9
  16rFA0F3D63 16r8D080DF5 16r3B6E20C8 16r4C69105E 16rD56041E4
  16rA2677172 16r3C03E4D1 16r4B04D447 16rD20D85FD 16rA50AB56B
  16r35B5A8FA 16r42B2986C 16rDBBBC9D6 16rACBCF940 16r32D86CE3
  16r45DF5C75 16rDCD60DCF 16rABD13D59 16r26D930AC 16r51DE003A
  16rC8D75180 16rBFD06116 16r21B4F4B5 16r56B3C423 16rCFBA9599
  16rB8BDA50F 16r2802B89E 16r5F058808 16rC60CD9B2 16rB10BE924
  16r2F6F7C87 16r58684C11 16rC1611DAB 16rB6662D3D 16r76DC4190
  16r01DB7106 16r98D220BC 16rEFD5102A 16r71B18589 16r06B6B51F
  16r9FBFE4A5 16rE8B8D433 16r7807C9A2 16r0F00F934 16r9609A88E
  16rE10E9818 16r7F6A0DBB 16r086D3D2D 16r91646C97 16rE6635C01
  16r6B6B51F4 16r1C6C6162 16r856530D8 16rF262004E 16r6C0695ED
  16r1B01A57B 16r8208F4C1 16rF50FC457 16r65B0D9C6 16r12B7E950
  16r8BBEB8EA 16rFCB9887C 16r62DD1DDF 16r15DA2D49 16r8CD37CF3
  16rFBD44C65 16r4DB26158 16r3AB551CE 16rA3BC0074 16rD4BB30E2
  16r4ADFA541 16r3DD895D7 16rA4D1C46D 16rD3D6F4FB 16r4369E96A
  16r346ED9FC 16rAD678846 16rDA60B8D0 16r44042D73 16r33031DE5
  16rAA0A4C5F 16rDD0D7CC9 16r5005713C 16r270241AA 16rBE0B1010
  16rC90C2086 16r5768B525 16r206F85B3 16rB966D409 16rCE61E49F
  16r5EDEF90E 16r29D9C998 16rB0D09822 16rC7D7A8B4 16r59B33D17
  16r2EB40D81 16rB7BD5C3B 16rC0BA6CAD 16rEDB88320 16r9ABFB3B6
  16r03B6E20C 16r74B1D29A 16rEAD54739 16r9DD277AF 16r04DB2615
  16r73DC1683 16rE3630B12 16r94643B84 16r0D6D6A3E 16r7A6A5AA8
  16rE40ECF0B 16r9309FF9D 16r0A00AE27 16r7D079EB1 16rF00F9344
  16r8708A3D2 16r1E01F268 16r6906C2FE 16rF762575D 16r806567CB
  16r196C3671 16r6E6B06E7 16rFED41B76 16r89D32BE0 16r10DA7A5A
  16r67DD4ACC 16rF9B9DF6F 16r8EBEEFF9 16r17B7BE43 16r60B08ED5
  16rD6D6A3E8 16rA1D1937E 16r38D8C2C4 16r4FDFF252 16rD1BB67F1
  16rA6BC5767 16r3FB506DD 16r48B2364B 16rD80D2BDA 16rAF0A1B4C
  16r36034AF6 16r41047A60 16rDF60EFC3 16rA867DF55 16r316E8EEF
  16r4669BE79 16rCB61B38C 16rBC66831A 16r256FD2A0 16r5268E236
  16rCC0C7795 16rBB0B4703 16r220216B9 16r5505262F 16rC5BA3BBE
  16rB2BD0B28 16r2BB45A92 16r5CB36A04 16rC2D7FFA7 16rB5D0CF31
  16r2CD99E8B 16r5BDEAE1D 16r9B64C2B0 16rEC63F226 16r756AA39C
  16r026D930A 16r9C0906A9 16rEB0E363F 16r72076785 16r05005713
  16r95BF4A82 16rE2B87A14 16r7BB12BAE 16r0CB61B38 16r92D28E9B
  16rE5D5BE0D 16r7CDCEFB7 16r0BDBDF21 16r86D3D2D4 16rF1D4E242
  16r68DDB3F8 16r1FDA836E 16r81BE16CD 16rF6B9265B 16r6FB077E1
  16r18B74777 16r88085AE6 16rFF0F6A70 16r66063BCA 16r11010B5C
  16r8F659EFF 16rF862AE69 16r616BFFD3 16r166CCF45 16rA00AE278
  16rD70DD2EE 16r4E048354 16r3903B3C2 16rA7672661 16rD06016F7
  16r4969474D 16r3E6E77DB 16rAED16A4A 16rD9D65ADC 16r40DF0B66
  16r37D83BF0 16rA9BCAE53 16rDEBB9EC5 16r47B2CF7F 16r30B5FFE9
  16rBDBDF21C 16rCABAC28A 16r53B39330 16r24B4A3A6 16rBAD03605
  16rCDD70693 16r54DE5729 16r23D967BF 16rB3667A2E 16rC4614AB8
  16r5D681B02 16r2A6F2B94 16rB40BBE37 16rC30C8EA1 16r5A05DF1B
  16r2D02EF8D
).! !
!ZipWriteStream class methodsFor: 'crc' stamp: 'nk 2/17/2004 16:50'!
updateCrc: oldCrc from: start to: stop in: aCollection
	| newCrc |
	<primitive: 'primitiveUpdateGZipCrc32' module: 'ZipPlugin'>
	newCrc _ oldCrc.
	start to: stop do:[:i|
		newCrc _ (CrcTable at: ((newCrc bitXor: (aCollection byteAt: i)) 
				bitAnd: 255) + 1) bitXor: (newCrc bitShift: -8).
	].
	^newCrc! !
!GZipWriteStream methodsFor: 'initialization' stamp: 'nk 2/19/2004 08:31' overrides: 50596637!
writeFooter
	"Write some footer information for the crc"
	super writeFooter.
	0 to: 3 do:[:i| encoder nextBytePut: (crc >> (i*8) bitAnd: 255)].
	0 to: 3 do:[:i| encoder nextBytePut: (bytesWritten >> (i*8) bitAnd: 255)].! !
!GZipWriteStream methodsFor: 'initialization' stamp: 'ar 12/30/1999 11:41' overrides: 50596643!
writeHeader
	"Write the GZip header"
	encoder nextBits: 16 put: GZipMagic.
	encoder nextBits: 8 put: GZipDeflated.
	encoder nextBits: 8 put: 0. "No flags"
	encoder nextBits: 32 put: 0. "no time stamp"
	encoder nextBits: 8 put: 0. "No extra flags"
	encoder nextBits: 8 put: 0. "No OS type"
! !
!GZipWriteStream class methodsFor: 'file list services' stamp: 'pb 2/26/2020 13:44:48'!
compressFile: aFileEntry
	"Create a compressed file from the file of the given name"

	(aFileEntry readStream) compressFile! !
!GZipWriteStream class methodsFor: 'file list services' stamp: 'pb 2/26/2020 13:51:06'!
fileReaderServicesForFileEntry: aFileEntry suffix: suffix
	"FileList buttons that are serviced by us."
	"Don't offer to compress already-compressed files
	sjc 3-May 2003-added jpeg extension"

	^({ 'gz' . 'sar' . 'zip' . 'gif' . 'jpg' . 'jpeg'. 'pr'. 'png' } includes: suffix)
		ifTrue: [ #() ]
		ifFalse: [ { self serviceCompressFile } ]
! !
!GZipWriteStream class methodsFor: 'file list services' stamp: 'HAW 1/2/2019 18:38:24'!
serviceCompressFile

	^ (SimpleServiceEntry 
		provider: self 
		label: 'compress file'
		selector: #compressFile:
		description: 'compress file using gzip compression, making a new file'
		icon: #goBottomIcon) triggerFileListChanged! !
!ZLibWriteStream methodsFor: 'initialization' stamp: 'nk 2/17/2004 16:28' overrides: 50596619!
on: aCollectionOrStream
	super on: aCollectionOrStream.
	crc _ 1.! !
!ZLibWriteStream methodsFor: 'initialization' stamp: 'nk 2/17/2004 16:53' overrides: 50597088!
updateCrc: adler from: start to: stop in: aCollection
	"Update crc using the Adler32 checksum technique from RFC1950"
	^self class updateAdler32: adler from:  start to:  stop in: aCollection! !
!ZLibWriteStream methodsFor: 'initialization' stamp: 'ar 2/29/2004 04:40' overrides: 50596637!
writeFooter
	"Store the Adler32 checksum as the last 4 bytes."
	3 to: 0 by: -1 do:[:i| encoder nextBytePut: (crc >> (i*8) bitAnd: 255)].! !
!ZLibWriteStream methodsFor: 'initialization' stamp: 'nk 2/17/2004 18:23' overrides: 50596643!
writeHeader
	"Write header information"
	encoder nextBits: 8 put: 120. "deflate method with 15bit window size"
	encoder nextBits: 8 put: 94. "checksum; no preset; fast (flevel=1) compression"! !
!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50'!
updateAdler32: adler from: start to: stop in: aCollection
	"Update crc using the Adler32 checksum technique from RFC1950"
"
        unsigned long s1 = adler & 0xffff;
        unsigned long s2 = (adler >> 16) & 0xffff;
        int n;

        for (n = 0; n < len; n++) {
          s1 = (s1 + buf[n]) % BASE;
          s2 = (s2 + s1)     % BASE;
        }
        return (s2 << 16) + s1;
"
	| s1 s2 |
	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>
	s1 := adler bitAnd: 16rFFFF.
	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.
	start to: stop do: [ :n | | b |
		b := aCollection byteAt: n.
		s1 := (s1 + b) \\ 65521.
		s2 := (s2 + s1) \\ 65521. ].
	^(s2 bitShift: 16) + s1! !
!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:45'!
bitPosition
	^encodedStream position + position * 8 + bitPosition.! !
!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!
encodedStream
	^encodedStream! !
!ZipEncoder methodsFor: 'accessing' stamp: 'ar 1/2/2000 16:34'!
nextBits: nBits put: value
	"Store a value of nBits"
	"self assert:[value >= 0 and:[(1 bitShift: nBits) > value]]."
	bitBuffer _ bitBuffer bitOr: (value bitShift: bitPosition).
	bitPosition _ bitPosition + nBits.
	[bitPosition >= 8] whileTrue:[
		self nextBytePut: (bitBuffer bitAnd: 255).
		bitBuffer _ bitBuffer bitShift: -8.
		bitPosition _ bitPosition - 8].! !
!ZipEncoder methodsFor: 'accessing' stamp: 'ar 1/2/2000 16:34'!
nextBytePut: anObject 
	"Primitive. Insert the argument at the next position in the Stream
	represented by the receiver. Fail if the collection of this stream is not an
	Array or a String. Fail if the stream is positioned at its end, or if the
	position is out of bounds in the collection. Fail if the argument is not
	of the right type for the collection. Optional. See Object documentation
	whatIsAPrimitive."

	<primitive: 66>
	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: 
			[position _ position + 1.
			^collection byteAt: position put: anObject]! !
!ZipEncoder methodsFor: 'initialization' stamp: 'sd 1/30/2004 15:24' overrides: 16945886!
close
	self flush.
	encodedStream close.! !
!ZipEncoder methodsFor: 'initialization' stamp: 'ar 12/30/1999 15:51'!
commit
	encodedStream next: position putAll: collection.
	position _ readLimit _ 0.! !
!ZipEncoder methodsFor: 'initialization' stamp: 'ar 12/30/1999 15:51' overrides: 16945731!
flush
	self flushBits.
	self commit.! !
!ZipEncoder methodsFor: 'initialization' stamp: 'ar 1/2/2000 16:35'!
flushBits
	"Flush currently unsent bits"
	[bitPosition > 0] whileTrue:[
		self nextBytePut: (bitBuffer bitAnd: 255).
		bitBuffer _ bitBuffer bitShift: -8.
		bitPosition _ bitPosition - 8].
	bitPosition _ 0.! !
!ZipEncoder methodsFor: 'initialization' stamp: 'jmv 2/17/2010 22:09' overrides: 50405197!
on: aCollectionOrStream
	(aCollectionOrStream is: #Stream)
		ifTrue:[encodedStream _ aCollectionOrStream]
		ifFalse:[	encodedStream _ WriteStream on: aCollectionOrStream].
	encodedStream isBinary
		ifTrue:[super on: (ByteArray new: 4096)]
		ifFalse:[super on: (String new: 4096)].
	bitPosition _ bitBuffer _ 0.! !
!ZipEncoder methodsFor: 'private' stamp: 'ar 1/2/2000 16:38' overrides: 16983276!
pastEndPut: anObject
	"Flush the current buffer and store the new object at the beginning"
	self commit.
	^self nextBytePut: anObject asInteger! !
!ZipEncoder methodsFor: 'private' stamp: 'ar 2/2/2001 15:47'!
privateSendBlock: literalStream with: distanceStream with: litTree with: distTree
	"Send the current block using the encodings from the given literal/length and distance tree"
	| lit dist code extra sum |
	<primitive: 'primitiveZipSendBlock' module: 'ZipPlugin'>
	sum _ 0.
	[lit _ literalStream next.
	dist _ distanceStream next.
	lit == nil] whileFalse:[
		dist = 0 ifTrue:["lit is a literal"
			sum _ sum + 1.
			self nextBits: (litTree bitLengthAt: lit)
				put: (litTree codeAt: lit).
		] ifFalse:["lit is match length"
			sum _ sum + lit + MinMatch.
			code _ (MatchLengthCodes at: lit + 1).
			self nextBits: (litTree bitLengthAt: code)
				put: (litTree codeAt: code).
			extra _ ExtraLengthBits at: code-NumLiterals.
			extra = 0 ifFalse:[
				lit _ lit - (BaseLength at: code-NumLiterals).
				self nextBits: extra put: lit.
			].
			dist _ dist - 1.
			dist < 256
				ifTrue:[code _ DistanceCodes at: dist + 1]
				ifFalse:[code _ DistanceCodes at: 257 + (dist bitShift: -7)].
			"self assert:[code < MaxDistCodes]."
			self nextBits: (distTree bitLengthAt: code)
				put: (distTree codeAt: code).
			extra _ ExtraDistanceBits at: code+1.
			extra = 0 ifFalse:[
				dist _ dist - (BaseDistance at: code+1).
				self nextBits: extra put: dist.
			].
		].
	].
	^sum! !
!ZipEncoder methodsFor: 'block encoding' stamp: 'ar 12/30/1999 18:39'!
sendBlock: literalStream with: distanceStream with: litTree with: distTree
	"Send the current block using the encodings from the given literal/length and distance tree"
	| result |
	result _ 0.
	[literalStream atEnd] whileFalse:[
		result _ result + (self privateSendBlock: literalStream
						with: distanceStream with: litTree with: distTree).
		self commit.
	].
	self nextBits: (litTree bitLengthAt: EndBlock) put: (litTree codeAt: EndBlock).
	^result! !
!CRCError methodsFor: 'as yet unclassified' stamp: 'nk 3/7/2004 15:56' overrides: 16848974!
isResumable
	^true! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!
ascii

	self bufferStream ascii! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:42'!
binary

	self bufferStream binary! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:43'!
bufferStream

	^bufferStream ifNil: [bufferStream _ RWBinaryOrTextStream on: (ByteArray new: 5000)].
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:26'!
close
	
	"we don't want to until user is really done"
	

! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:26'!
closed

	^false! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:18'!
fileOutClass: extraClass andObject: theObject
	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."

	| class srefStream |

	self timeStamp.

	extraClass ifNotNil: [
		class _ extraClass.	"A specific class the user wants written"
		class sharedPools size > 0 ifTrue: [
			class shouldFileOutPools ifTrue: [class fileOutSharedPoolsOn: self]
		].
		class fileOutOn: self moveSource: false toFile: 0
	].

	"Append the object's raw data"
	srefStream _ SmartRefStream on: self.
	srefStream nextPut: theObject.  "and all subobjects"
	srefStream close.		"also closes me - well it thinks it does, anyway"
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:16'!
flushBuffer

	| data |
	bufferStream ifNil: [^self].
	data _ bufferStream contents asByteArray.
	gZipStream nextPutAll: data.
	positionThusFar _ positionThusFar + data size.
	bufferStream _ nil.
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'jmv 3/13/2012 12:12'!
newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self bufferStream newLine! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:23'!
next

	^self bufferStream next! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:42'!
nextChunkPut: aString

	self bufferStream nextChunkPut: aString! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!
nextPut: aByte

	^self bufferStream nextPut: aByte
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:24'!
nextPutAll: aString

	^aString writeOnGZIPByteStream: self
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:41'!
nextPutAllBytes: aString

	^self bufferStream nextPutAll: aString
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:36'!
nextPutAllWordArray: aWordArray

	| ba hackwa hackba blt rowsAtATime sourceOrigin rowsRemaining |

	self flag: #bob.		"do we need to be concerned by bytesPerElement??"
	ba _ nil.
	rowsAtATime _ 2000.		"or 8000 bytes"
	hackwa _ Form new hackBits: aWordArray.
	sourceOrigin _ 0@0.
	[(rowsRemaining _ hackwa height - sourceOrigin y) > 0] whileTrue: [
		rowsAtATime _ rowsAtATime min: rowsRemaining.
		(ba isNil or: [ba size ~= (rowsAtATime * 4)]) ifTrue: [
			ba _ ByteArray new: rowsAtATime * 4.
			hackba _ Form new hackBits: ba.
			blt _ (BitBlt toForm: hackba) sourceForm: hackwa.
		].
		blt 
			combinationRule: Form over;
			sourceOrigin: sourceOrigin;
			destX: 0 destY: 0 width: 4 height: rowsAtATime;
			copyBits.
		self bufferStream nextPutAll: ba.
		self flushBuffer.
		sourceOrigin _ sourceOrigin x @ (sourceOrigin y + rowsAtATime).
	].
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'jmv 2/26/2016 16:19'!
nextSignedInt32Put: int32 bigEndian: bigEndian

	^self bufferStream nextSignedInt32Put: int32 bigEndian: bigEndian! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/22/2000 18:42'!
nextStringPut: s 
	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."

	| length |
	(length _ s size) < 192
		ifTrue: [self nextPut: length]
		ifFalse: 
			[self nextPut: (length digitAt: 4)+192.
			self nextPut: (length digitAt: 3).
			self nextPut: (length digitAt: 2).
			self nextPut: (length digitAt: 1)].
	self nextPutAll: s.
	^s! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'ar 5/17/2001 19:08'!
nextWordsPutAll: aCollection
	"Write the argument a word-like object in big endian format on the receiver.
	May be used to write other than plain word-like objects (such as ColorArray)."
	^self nextPutAllWordArray: aCollection! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:22'!
originalContents

	^''		"used only to determine if we are byte-structured"! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:12'!
position

	^self bufferStream position + positionThusFar! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 19:13'!
reallyClose

	self flushBuffer.
	gZipStream close.
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:30'!
reopen

	"ignore"! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 08:30'!
setToEnd

	"ignore"! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:21'!
skip: aNumber

	^self bufferStream skip: aNumber
! !
!GZipSurrogateStream methodsFor: 'as yet unclassified' stamp: 'jmv 3/13/2012 12:35'!
timeStamp
	"Append the current time to the receiver as a String."
	self bufferStream nextChunkPut:	"double string quotes and !!s"
		(String streamContents: [:s | Smalltalk timeStamp: s]) printString.
	self bufferStream newLine! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 19:41'!
bitLength
	^bitLength ifNil:[0]! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/30/1999 14:28'!
code
	^code ifNil:[0]! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:51'!
code: aCode
	self assert:[aCode >= 0 and:[(1 bitShift: bitLength) > aCode]].
	code _ aCode.! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:36'!
frequency
	^frequency! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/28/1999 00:56'!
frequency: aNumber
	frequency _ aNumber! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/26/1999 10:44'!
height
	^height! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!
left
	^left! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!
left: aNode
	aNode parent: self.
	left _ aNode.! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!
parent
	^parent! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!
parent: aNode
	parent _ aNode! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!
right
	^right! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!
right: aNode
	aNode parent: self.
	right _ aNode.! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43' overrides: 16902254!
value
	^value! !
!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:45'!
computeHeight
	^self isLeaf
		ifTrue:[height _ 0]
		ifFalse:[height _ (left computeHeight max: right computeHeight) + 1].! !
!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/25/1999 18:14'!
leafNodes
	self isLeaf
		ifTrue:[^Array with: self]
		ifFalse:[^left leafNodes, right leafNodes]! !
!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 12:05'!
setBitLengthTo: bl
	bitLength _ bl! !
!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:46'!
setValue: v frequency: f height: h
	value _ v.
	frequency _ f.
	height _ h.! !
!ZipEncoderNode methodsFor: 'encoding' stamp: 'jmv 3/2/2010 11:31'!
encodeBitLength: blCounts from: aTree
	| index |
	"Note: If bitLength is not nil then the tree must be broken"
	bitLength ifNotNil: [ self error:'Huffman tree is broken'].
	bitLength _ parent
		ifNil: [0]
		ifNotNil: [ parent bitLength + 1].
	self isLeaf ifTrue:[
		index _ bitLength + 1.
		blCounts at: index put: (blCounts at: index) + 1.
	] ifFalse:[
		left encodeBitLength: blCounts from: aTree.
		right encodeBitLength: blCounts from: aTree.
	]! !
!ZipEncoderNode methodsFor: 'encoding' stamp: 'ar 12/27/1999 14:27'!
rotateToHeight: maxHeight
	"Rotate the tree to achieve maxHeight depth"
	| newParent |
	height < 4 ifTrue:[^self].
	self left: (left rotateToHeight: maxHeight-1).
	self right: (right rotateToHeight: maxHeight-1).
	height _ (left height max: right height) + 1.
	height <= maxHeight ifTrue:[^self].
	(left height - right height) abs <= 2 ifTrue:[^self].
	left height < right height ifTrue:[
		right right height >= right left height ifTrue:[
			newParent _ right.
			self right: newParent left.
			newParent left: self.
		] ifFalse:[
			newParent _ right left.
			right left: newParent right.
			newParent right: right.
			self right: newParent left.
			newParent left: self.
		].
	] ifFalse:[
		left left height >= left right height ifTrue:[
			newParent _ left.
			self left: newParent right.
			newParent right: self.
		] ifFalse:[
			newParent _ left right.
			left right: newParent left.
			newParent left: left.
			self left: newParent right.
			newParent right: self.
		].
	].
	parent computeHeight.
	^parent! !
!ZipEncoderNode methodsFor: 'testing' stamp: 'ar 12/24/1999 23:17'!
isLeaf
	^left == nil! !
!ZipEncoderNode class methodsFor: 'instance creation' stamp: 'ar 12/26/1999 10:47'!
value: v frequency: f height: h
	^self new setValue: v frequency: f height: h! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:43'!
bitLengthAt: index
	^bitLengths at: index+1! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:32'!
bitLengths
	"Return an array of all bitLength values for valid codes"
	^bitLengths! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:04'!
codeAt: index
	^codes at: index+1! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:24'!
codes
	"Return an array of all valid codes"
	^codes! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 17:15'!
maxCode
	^maxCode! !
!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:45'!
maxCode: aNumber
	maxCode _ aNumber.! !
!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/30/1999 14:26'!
bitLengths: blArray codes: codeArray
	bitLengths _ blArray as: WordArray.
	codes _ codeArray as: WordArray.
	self assert:[(self bitLengthAt: maxCode) > 0].! !
!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/26/1999 11:02'!
reverseBits: code length: length
	"Bit reverse the given code"
	| result bit bits |
	result _ 0.
	bits _ code.
	1 to: length do:[:i|
		bit _ bits bitAnd: 1.
		result _ result << 1 bitOr: bit.
		bits _ bits >> 1].
	^result! !
!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/30/1999 14:26'!
setValuesFrom: nodeList
	self bitLengths: (nodeList collect:[:n| n bitLength] from: 1 to: maxCode+1)
		codes: (nodeList collect:[:n| n code] from: 1 to: maxCode+1).! !
!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:34'!
buildCodes: nodeList counts: blCounts maxDepth: depth
	"Build the codes for all nodes"
	| nextCode code node length |
	nextCode _ WordArray new: depth+1.
	code _ 0.
	1 to: depth do:[:bits|
		code _ (code + (blCounts at: bits)) << 1.
		nextCode at: bits+1 put: code].
	self assert:[(code + (blCounts at: depth+1) - 1) = (1 << depth - 1)].
	0 to: maxCode do:[:n|
		node _ nodeList at: n+1.
		length _ node bitLength.
		length = 0 ifFalse:[
			code _ nextCode at: length+1.
			node code: (self reverseBits: code length: length).
			nextCode at: length+1 put: code+1.
		].
	].! !
!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!
buildHierarchyFrom: aHeap
	"Build the node hierarchy based on the leafs in aHeap"
	| left right parent |
	[aHeap size > 1] whileTrue:[
		left _ aHeap removeFirst.
		right _ aHeap removeFirst.
		parent _ ZipEncoderNode value: -1 
			frequency: (left frequency + right frequency)
			height: (left height max: right height) + 1.
		left parent: parent.
		right parent: parent.
		parent left: left.
		parent right: right.
		aHeap add: parent].
	^aHeap removeFirst
! !
!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 14:19'!
buildTree: nodeList maxDepth: depth
	"Build either the literal or the distance tree"
	| heap rootNode blCounts |
	heap _ Heap new: nodeList size // 3.
	heap sortBlock: self nodeSortBlock.
	"Find all nodes with non-zero frequency and add to heap"
	maxCode _ 0.
	nodeList do:[:dNode|
		dNode frequency = 0 ifFalse:[
			maxCode _ dNode value.
			heap add: dNode]].
	"The pkzip format requires that at least one distance code exists,
	and that at least one bit should be sent even if there is only one
	possible code. So to avoid special checks later on we force at least
	two codes of non zero frequency."
	heap size = 0 ifTrue:[
		self assert:[maxCode = 0].
		heap add: nodeList first.
		heap add: nodeList second.
		maxCode _ 1].
	heap size = 1 ifTrue:[
		nodeList first frequency = 0
			ifTrue:[heap add: nodeList first]
			ifFalse:[heap add: nodeList second].
		maxCode _ maxCode max: 1].
	rootNode _ self buildHierarchyFrom: heap.
	rootNode height > depth ifTrue:[
		rootNode _ rootNode rotateToHeight: depth.
		rootNode height > depth ifTrue:[self error:'Cannot encode tree']].
	blCounts _ WordArray new: depth+1.
	rootNode encodeBitLength: blCounts from: self.
	self buildCodes: nodeList counts: blCounts maxDepth: depth.
	self setValuesFrom: nodeList.! !
!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:24'!
buildTreeFrom: frequencies maxDepth: depth
	"Build the receiver from the given frequency values"
	| nodeList |
	nodeList _ Array new: frequencies size.
	1 to: frequencies size do:[:i|
		nodeList at: i put: (ZipEncoderNode value: i-1 frequency: (frequencies at: i) height: 0)
	].
	self buildTree: nodeList maxDepth: depth.! !
!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!
nodeSortBlock
	^[:n1 :n2|
		n1 frequency = n2 frequency
			ifTrue:[n1 height <= n2 height]
			ifFalse:[n1 frequency <= n2 frequency]].! !
!ZipEncoderTree class methodsFor: 'instance creation' stamp: 'ar 12/30/1999 01:25'!
buildTreeFrom: frequencies maxDepth: depth
	^self new buildTreeFrom: frequencies maxDepth: depth! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 19:09'!
addDirectory: aFileName
	^self addDirectory: aFileName as: aFileName
! !
!Archive methodsFor: 'archive operations' stamp: 'nk 12/20/2002 14:57'!
addDirectory: aFileName as: anotherFileName
	| newMember |
	newMember _ self memberClass newFromDirectory: aFileName.
	self addMember: newMember.
	newMember localFileName: anotherFileName.
	^newMember! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:29'!
addFile: aFileName
	^self addFile: aFileName as: aFileName! !
!Archive methodsFor: 'archive operations' stamp: 'nk 12/20/2002 15:03'!
addFile: aFileName as: anotherFileName
	| newMember |
	newMember _ self memberClass newFromFile: aFileName.
	self addMember: newMember.
	newMember localFileName: anotherFileName.
	^newMember! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 19:09'!
addMember: aMember
	^members addLast: aMember! !
!Archive methodsFor: 'archive operations' stamp: 'nk 12/20/2002 15:03'!
addString: aString as: aFileName
	| newMember |
	newMember _ self memberClass newFromString: aString named: aFileName.
	self addMember: newMember.
	newMember localFileName: aFileName.
	^newMember! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/24/2001 14:12'!
canWriteToFileNamed: aFileName
	"Catch attempts to overwrite existing zip file"
	^(members anySatisfy: [ :ea | ea usesFileNamed: aFileName ]) not.
! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!
contentsOf: aMemberOrName
	| member |
	member _ self member: aMemberOrName.
	member ifNil: [ ^nil ].
	^member contents! !
!Archive methodsFor: 'archive operations' stamp: 'pb 5/25/2016 01:06'!
extractMember: aMemberOrName
	| member |
	member _ self member: aMemberOrName.
	member ifNil: [ ^nil ].
	member extractToFileNamed: member localFileName inDirectory: DirectoryEntry currentDirectory! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!
extractMember: aMemberOrName toFileNamed: aFileName
	| member |
	member _ self member: aMemberOrName.
	member ifNil: [ ^nil ].
	member extractToFileNamed: aFileName! !
!Archive methodsFor: 'archive operations' stamp: 'pb 5/25/2016 01:06'!
extractMemberWithoutPath: aMemberOrName
	self extractMemberWithoutPath: aMemberOrName inDirectory: DirectoryEntry currentDirectory! !
!Archive methodsFor: 'archive operations' stamp: 'jmv 5/31/2016 10:35'!
extractMemberWithoutPath: aMemberOrName inDirectory: aDirectoryEntry
	| member |
	member _ self member: aMemberOrName.
	member ifNil: [ ^nil ].
	member extractToFileNamed: member localFileName asFileEntry name inDirectory: aDirectoryEntry! !
!Archive methodsFor: 'archive operations' stamp: 'jmv 3/2/2010 08:56'!
memberNamed: aString
	"Return the first member whose zip name or local file name matches aString, or nil"
	^members detect: [ :ea | ea fileName = aString or: [ ea localFileName = aString ]] ifNone: nil! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 18:00'!
memberNames
	^members collect: [ :ea | ea fileName ]! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 17:58'!
members
	^members! !
!Archive methodsFor: 'archive operations' stamp: 'nk 12/20/2002 14:50'!
membersMatching: aString
	^members select: [ :ea | (aString match: ea fileName) or: [ aString match: ea localFileName ] ]! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 17:59'!
numberOfMembers
	^members size! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!
removeMember: aMemberOrName
	| member |
	member _ self member: aMemberOrName.
	member ifNotNil: [ members remove: member ].
	^member! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 07:57'!
replaceMember: aMemberOrName with: newMember
	| member |
	member _ self member: aMemberOrName.
	member ifNotNil: [ members replaceAll: member with: newMember ].
	^member! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/22/2001 17:24'!
setContentsOf: aMemberOrName to: aString
	| newMember oldMember |
	oldMember _ self member: aMemberOrName.
	newMember _ (self memberClass newFromString: aString named: oldMember fileName)
		copyFrom: oldMember.
	self replaceMember: oldMember with: newMember.! !
!Archive methodsFor: 'archive operations' stamp: 'nk 2/21/2001 20:58'!
writeTo: aStream
	self subclassResponsibility! !
!Archive methodsFor: 'archive operations' stamp: 'pb 5/25/2016 01:35'!
writeToFileNamed: aFileName

	"Catch attempts to overwrite existing zip file"
	(self canWriteToFileNamed: aFileName)
		ifFalse: [ ^self error: (aFileName, ' is needed by one or more members in this archive') ].
	aFileName asFileEntry writeStreamDo: [ :stream |
		self writeTo: stream ]! !
!Archive methodsFor: 'initialization' stamp: 'nk 2/21/2001 17:58' overrides: 16920235!
initialize
	members _ OrderedCollection new.! !
!Archive methodsFor: 'private' stamp: 'nk 2/22/2001 07:56'!
member: aMemberOrName
	^(members includes: aMemberOrName)
		ifTrue: [ aMemberOrName ]
		ifFalse: [ self memberNamed: aMemberOrName ].! !
!Archive methodsFor: 'private' stamp: 'nk 2/21/2001 18:14'!
memberClass
	self subclassResponsibility! !
!ZipArchive methodsFor: 'initialization' stamp: 'ar 3/2/2001 18:47'!
close
	self members do:[:m| m close].! !
!ZipArchive methodsFor: 'initialization' stamp: 'nk 2/22/2001 17:20' overrides: 50598347!
initialize
	super initialize.
	writeEOCDOffset _ writeCentralDirectoryOffset _ 0.
	zipFileComment _ ''.
! !
!ZipArchive methodsFor: 'archive operations' stamp: 'jmv 7/17/2017 15:47:50'!
extractAllTo: aDirectoryEntry
	"Extract all elements to the given directory"
	Utilities informUserDuring: [ :barBlock | self extractAllTo: aDirectoryEntry informing: barBlock]! !
!ZipArchive methodsFor: 'archive operations' stamp: 'jmv 7/17/2017 15:47:41'!
extractAllTo: aDirectoryEntry informing: barBlock
	"Extract all elements to the given directory"
	^self extractAllTo: aDirectoryEntry informing: barBlock overwrite: false! !
!ZipArchive methodsFor: 'archive operations' stamp: 'jmv 7/17/2017 15:50:56'!
extractAllTo: aDirectory informing: barBlock overwrite: allOverwrite
	"Extract all elements to the given directory"
	| dir overwriteAll response |
	overwriteAll := allOverwrite.
	self members do:[:entry|
		entry isDirectory ifTrue:[
			barBlock ifNotNil:[barBlock value: 'Creating ', entry fileName].
			dir := (entry fileName findTokens:'/') 
					inject: aDirectory into:[:base :part| base / part].
			dir assureExistence.
		].
	].
	self members do:[:entry|
		entry isDirectory ifFalse:[
			barBlock ifNotNil:[barBlock value: 'Extracting ', entry fileName].
			response := entry extractInDirectory: aDirectory overwrite: overwriteAll.
			response == #retryWithOverwrite ifTrue:[
				overwriteAll := true.
				response := entry extractInDirectory: aDirectory overwrite: overwriteAll.
			].
			response == #abort ifTrue:[^self].
			response == #failed ifTrue:[
				(self confirm: 'Failed to extract ', entry fileName, '. Proceed?') ifFalse:[^self].
			].
		].
	].
! !
!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 18:26' overrides: 50598358!
memberClass
	^ZipArchiveMember! !
!ZipArchive methodsFor: 'private' stamp: 'jmv 2/26/2016 16:28'!
readEndOfCentralDirectoryFrom: aStream
	"Read EOCD, starting from position before signature."
	| signature zipFileCommentLength |
	signature _ self readSignatureFrom: aStream.
	signature = EndOfCentralDirectorySignature ifFalse: [ ^self error: 'bad signature at ', aStream position printString ].

	aStream nextUnsignedInt16BigEndian: false. "# of this disk"
	aStream nextUnsignedInt16BigEndian: false. "# of disk with central dir start"
	aStream nextUnsignedInt16BigEndian: false. "# of entries in central dir on this disk"
	aStream nextUnsignedInt16BigEndian: false. "total # of entries in central dir"
	centralDirectorySize _ aStream nextUnsignedInt32BigEndian: false. "size of central directory"
	centralDirectoryOffsetWRTStartingDiskNumber _ aStream nextUnsignedInt32BigEndian: false. "offset of start of central directory"
	zipFileCommentLength _ aStream nextUnsignedInt16BigEndian: false. "zip file comment"
	zipFileComment _ aStream next: zipFileCommentLength.
! !
!ZipArchive methodsFor: 'private' stamp: 'nk 2/23/2001 09:19'!
readMembersFrom: stream named: fileName
	| newMember signature |
	[
		newMember _ self memberClass newFromZipFile: stream named: fileName.
		signature _ self readSignatureFrom: stream.
		signature = EndOfCentralDirectorySignature ifTrue: [ ^self ].
		signature = CentralDirectoryFileHeaderSignature
			ifFalse: [ self error: 'bad CD signature at ', (stream position - 4) hex ].
		newMember readFrom: stream.
		newMember looksLikeDirectory ifTrue: [ newMember _ newMember asDirectory ].
		self addMember: newMember.
	] repeat.! !
!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 20:09'!
readSignatureFrom: stream
	"Returns next signature from given stream, leaves stream positioned afterwards."

	| signatureData | 
	signatureData _ String new: 4.
	stream next: 4 into: signatureData.
	({ CentralDirectoryFileHeaderSignature . LocalFileHeaderSignature . EndOfCentralDirectorySignature }
		includes: signatureData)
			ifFalse: [ ^self error: 'bad signature ', signatureData asHex, ' at position ', (stream position - 4) asString ].
	^signatureData
! !
!ZipArchive methodsFor: 'private' stamp: 'nk 2/21/2001 20:19'!
writeCentralDirectoryTo: aStream
	| offset |
	offset _ writeCentralDirectoryOffset.
	members do: [ :member |
		member writeCentralDirectoryFileHeaderTo: aStream.
		offset _ offset + member centralDirectoryHeaderSize.
	].
	writeEOCDOffset _ offset.
	self writeEndOfCentralDirectoryTo: aStream.

! !
!ZipArchive methodsFor: 'private' stamp: 'jmv 2/26/2016 16:37'!
writeEndOfCentralDirectoryTo: aStream

	aStream nextPutAll: EndOfCentralDirectorySignature.
	aStream nextUnsignedInt16Put: 0 bigEndian: false. "diskNumber"
	aStream nextUnsignedInt16Put: 0 bigEndian: false. "diskNumberWithStartOfCentralDirectory"
	aStream nextUnsignedInt16Put: members size bigEndian: false. "numberOfCentralDirectoriesOnThisDisk"
	aStream nextUnsignedInt16Put: members size bigEndian: false. "numberOfCentralDirectories"
	aStream nextUnsignedInt32Put: writeEOCDOffset - writeCentralDirectoryOffset bigEndian: false. "size of central dir"
	aStream nextUnsignedInt32Put: writeCentralDirectoryOffset bigEndian: false. "offset of central dir"
	aStream nextUnsignedInt16Put: zipFileComment size bigEndian: false. "zip file comment"
	zipFileComment isEmpty ifFalse: [ aStream nextPutAll: zipFileComment ].

! !
!ZipArchive methodsFor: 'accessing' stamp: 'nk 3/27/2002 11:23'!
prependedDataSize
	"Answer the size of whatever data exists before my first member.
	Assumes that I was read from a file or stream (i.e. the first member is a ZipFileMember)"
	^members isEmpty
		ifFalse: [ members first localHeaderRelativeOffset ]
		ifTrue: [ centralDirectoryOffsetWRTStartingDiskNumber ]! !
!ZipArchive methodsFor: 'accessing' stamp: 'nk 2/24/2001 13:44'!
zipFileComment
	^zipFileComment asString! !
!ZipArchive methodsFor: 'accessing' stamp: 'nk 2/24/2001 13:43'!
zipFileComment: aString
	zipFileComment _ aString! !
!ZipArchive methodsFor: 'reading' stamp: 'pb 5/25/2016 01:51'!
readFrom: aStreamOrFileName
	| stream name eocdPosition |
	stream _ (aStreamOrFileName is: #Stream)
		ifTrue: [name _ aStreamOrFileName name. aStreamOrFileName]
		ifFalse: [(name _ aStreamOrFileName) asFileEntry readStream].
	stream binary.
	eocdPosition _ self class findEndOfCentralDirectoryFrom: stream.
	eocdPosition <= 0 ifTrue: [self error: 'can''t find EOCD position'].
	self readEndOfCentralDirectoryFrom: stream.
	stream position: eocdPosition - centralDirectorySize.
	self readMembersFrom: stream named: name! !
!ZipArchive methodsFor: 'writing' stamp: 'nk 2/23/2001 10:29' overrides: 50598331!
writeTo: stream
	stream binary.
	members do: [ :member |
		member writeTo: stream.
		member endRead.
	].
	writeCentralDirectoryOffset _ stream position.
	self writeCentralDirectoryTo: stream.
	! !
!ZipArchive methodsFor: 'writing' stamp: 'nk 3/27/2002 10:42'!
writeTo: stream prepending: aString
	stream binary.
	stream nextPutAll: aString.
	members do: [ :member |
		member writeTo: stream.
		member endRead.
	].
	writeCentralDirectoryOffset _ stream position.
	self writeCentralDirectoryTo: stream.
	! !
!ZipArchive methodsFor: 'writing' stamp: 'pb 5/25/2016 01:51'!
writeTo: stream prependingFileNamed: aFileName
	| prepended buffer |
	stream binary.
	prepended _ aFileName asFileEntry readStream.
	prepended binary.
	buffer _ ByteArray new: (prepended size min: 32768).
	[ prepended atEnd ] whileFalse: [ | bytesRead |
		bytesRead _ prepended readInto: buffer startingAt: 1 count: buffer size.
		stream next: bytesRead putAll: buffer startingAt: 1
	].
	members do: [ :member |
		member writeTo: stream.
		member endRead.
	].
	writeCentralDirectoryOffset _ stream position.
	self writeCentralDirectoryTo: stream.
	! !
!ZipArchive methodsFor: 'writing' stamp: 'jmv 5/31/2016 11:24'!
writeToFileNamed: aFileName prepending: aString

	"Catch attempts to overwrite existing zip file"
	(self canWriteToFileNamed: aFileName)
		ifFalse: [ ^self error: (aFileName, ' is needed by one or more members in this archive') ].
	aFileName asFileEntry forceWriteStreamDo: [ :stream |
		self writeTo: stream prepending: aString ]! !
!ZipArchive methodsFor: 'writing' stamp: 'jmv 5/31/2016 11:24'!
writeToFileNamed: aFileName prependingFileNamed: anotherFileName

	"Catch attempts to overwrite existing zip file"
	(self canWriteToFileNamed: aFileName)
		ifFalse: [ ^self error: (aFileName, ' is needed by one or more members in this archive') ].
	aFileName asFileEntry forceWriteStreamDo: [ :stream |
		self writeTo: stream prependingFileNamed: anotherFileName ]! !
!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:13'!
compressionDeflated
	^CompressionDeflated! !
!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:12'!
compressionLevelDefault
	^CompressionLevelDefault! !
!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:12'!
compressionLevelNone
	^CompressionLevelNone ! !
!ZipArchive class methodsFor: 'constants' stamp: 'nk 2/22/2001 14:13'!
compressionStored
	^CompressionStored! !
!ZipArchive class methodsFor: 'constants' stamp: 'jmv 11/2/2010 12:40'!
findEndOfCentralDirectoryFrom: stream
	"Seek in the given stream to the end, then read backwards until we find the
	signature of the central directory record. Leave the file positioned right
	before the signature.

	Answers the file position of the EOCD, or 0 if not found."

	| data fileLength seekOffset pos maxOffset |
	stream setToEnd.
	fileLength _ stream position.
	"If the file length is less than 18 for the EOCD length plus 4 for the signature, we have a problem"
	fileLength < 22 ifTrue: [^ self error: 'file is too short'].
	
	seekOffset _ 0.
	pos _ 0.
	data _ String new: 4100.
	maxOffset _ 40960 min: fileLength.	"limit search range to 40K"

	[
		seekOffset _ (seekOffset + 4096) min: fileLength.
		stream position: fileLength - seekOffset.
		data _ stream next: (4100 min: seekOffset) into: data startingAt: 1.
		pos _ self
			lastIndexOfPKSignature: EndOfCentralDirectorySignature
			in: data.
		pos = 0 and: [seekOffset < maxOffset]
	] whileTrue.

	^ pos > 0
		ifTrue: [ | newPos | stream position: (newPos _ (stream position + pos - seekOffset - 1)). newPos]
		ifFalse: [0]! !
!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:28'!
lastIndexOfPKSignature: aSignature in: data
	"Answer the last index in data where aSignature (4 bytes long) occurs, or 0 if not found"
	| a b c d |
	a := aSignature first.
	b := aSignature second.
	c := aSignature third.
	d := aSignature fourth.
	(data size - 3) to: 1 by: -1 do: [ :i |
		(((data at: i) = a)
			and: [ ((data at: i + 1) = b)
				and: [ ((data at: i + 2) = c)
					and: [ ((data at: i + 3) = d) ]]])
						ifTrue: [ ^i ]
	].
	^0! !
!ZipArchive class methodsFor: 'constants' stamp: 'ar 2/27/2001 13:38'!
validSignatures
	"Return the valid signatures for a zip file"
	^Array 
		with: LocalFileHeaderSignature
		with: CentralDirectoryFileHeaderSignature
		with: EndOfCentralDirectorySignature! !
!ZipArchive class methodsFor: 'file list services' stamp: 'pb 2/26/2020 13:51:11'!
fileReaderServicesForFileEntry: aFileEntry suffix: suffix
	"FileList buttons that are swe know about."

	suffix = 'mcz'
		ifTrue: [ ^ {
			CodePackageFile serviceInstallMonticelloPackage .
			CodeFileBrowser serviceBrowseMCZCode
		} ].
	^#()! !
!ZipArchive class methodsFor: 'file format' stamp: 'pb 5/25/2016 01:51'!
isZipArchive: aStreamOrFileName
	"Answer whether the given filename represents a valid zip file."

	| stream eocdPosition |
	stream _ (aStreamOrFileName is: #Stream)
		ifTrue: [aStreamOrFileName]
		ifFalse: [aStreamOrFileName asFileEntry readStream ].
	stream ifNil: [^ false].
	"nil happens sometimes somehow"
	stream size < 22 ifTrue: [^ false].
	stream binary.
	eocdPosition _ self findEndOfCentralDirectoryFrom: stream.
	stream ~= aStreamOrFileName ifTrue: [stream close].
	^ eocdPosition > 0! !
!ArchiveMember methodsFor: 'initialization' stamp: 'ar 3/2/2001 18:46'!
close
! !
!ArchiveMember methodsFor: 'initialization' stamp: 'nk 3/7/2004 16:05' overrides: 16920235!
initialize
	fileName _ ''.
	isCorrupt _ false.! !
!ArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 16:00'!
fileName
	^fileName! !
!ArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 16:00'!
fileName: aName
	fileName _ aName! !
!ArchiveMember methodsFor: 'accessing' stamp: 'nk 3/7/2004 16:16'!
isCorrupt
	^isCorrupt ifNil: [ isCorrupt _ false ]! !
!ArchiveMember methodsFor: 'accessing' stamp: 'nk 3/7/2004 16:06'!
isCorrupt: aBoolean
	"Mark this member as being corrupt."
	isCorrupt := aBoolean! !
!ArchiveMember methodsFor: 'accessing' stamp: 'jmv 10/27/2015 18:12'!
localFileName: aString
	"Set my internal filename.
	Returns the (possibly new) filename.
	aString will be translated from local FS format into Unix format."

	^fileName _ aString copyReplaceAll: '\' with: '/'.! !
!ArchiveMember methodsFor: 'testing' stamp: 'nk 2/21/2001 19:43'!
usesFileNamed: aFileName
	"Do I require aFileName? That is, do I care if it's clobbered?"
	^false! !
!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:33'!
newDirectoryNamed: aString
	self subclassResponsibility! !
!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:32'!
newFromFile: aFileName
	self subclassResponsibility! !
!ArchiveMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/21/2001 18:32'!
newFromString: aString
	self subclassResponsibility! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 21:55'!
asDirectory
	^ZipDirectoryMember new copyFrom: self! !
!ZipArchiveMember methodsFor: 'private' stamp: 'jmv 2/16/2011 18:29'!
dosToSqueakTime: dt
	"DOS years start at 1980, so add 1980."
	| year mon mday hour min sec date time |

	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).
	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).
	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).
	date := Date newDay: mday month: mon year: year+1980.

	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).
	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).
	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).
	time := ((( hour * 60 ) + min ) * 60 ) + sec.

	^date secondsSinceSqueakEpoch + time

	! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/23/2001 08:24'!
endRead
	readDataRemaining _ 0.! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 23:57'!
mapPermissionsFromUnix: unixPerms
	^ unixPerms bitShift: 16.! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/21/2001 23:58'!
mapPermissionsToUnix: dosPerms
	^ dosPerms bitShift: -16.! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 2/22/2001 20:42'!
readRawChunk: n
	self subclassResponsibility! !
!ZipArchiveMember methodsFor: 'private' stamp: 'nk 4/28/2002 21:53'!
rewindData
	readDataRemaining _  (desiredCompressionMethod = CompressionDeflated
		and: [ compressionMethod = CompressionDeflated ])
			ifTrue: [ compressedSize ]
			ifFalse: [ uncompressedSize ].
! !
!ZipArchiveMember methodsFor: 'private' stamp: 'KLG 4/14/2021 17:14:13'!
squeakToDosTime: secs
	"Convert to MS-DOS time format
	See: https://docs.microsoft.com/de-de/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime?redirectedfrom=MSDN
	"

	| dosTime dateTime |

	dateTime _ Time dateAndTimeFromSeconds: 
		(secs isInteger
			ifFalse: [ secs secondsSinceSqueakEpoch ]
			ifTrue: [ secs ]).
	dosTime _ (dateTime second second) bitShift: -1.
	dosTime _ dosTime bitOr: ((dateTime second minute) bitShift: 5).
	dosTime _ dosTime bitOr: ((dateTime second hour) bitShift: 11).
	dosTime _ dosTime bitOr: ((dateTime first dayOfMonth) bitShift: `16 + 0`).
	dosTime _ dosTime bitOr: ((dateTime first monthIndex) bitShift: `16 + 5`).
	dosTime _ dosTime bitOr: (((dateTime first yearNumber) - 1980) bitShift: `16 + 9`).
	self assert: dosTime >= 0.
	^ dosTime
! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 09:44'!
centralDirectoryHeaderSize
	^ 46 + fileName size + cdExtraField size + fileComment size! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 08:00'!
clearExtraFields
	cdExtraField _ ''.
	localExtraField _ ''.! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:38'!
compressedSize
	"Return the compressed size for this member.
	This will not be set for members that were constructed from strings
	or external files until after the member has been written."
	^compressedSize! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:02'!
compressionMethod
	"Returns my compression method. This is the method that is
	currently being used to compress my data.

	This will be CompressionStored for added string or file members,
	or CompressionStored or CompressionDeflated (others are possible but not handled)"

	^compressionMethod! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:28'!
crc32
	^crc32! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:35'!
crc32String
	| hexString |
	hexString _ crc32 hex.
	^('00000000' copyFrom: 1 to: 11 - (hexString size)) , (hexString copyFrom: 4 to: hexString size)! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:10'!
desiredCompressionLevel
	^desiredCompressionLevel! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:14'!
desiredCompressionLevel: aNumber
	"Set my desiredCompressionLevel
	This is the method that will be used to write.
	Returns prior desiredCompressionLevel.

	Valid arguments are 0 (CompressionLevelNone) through 9,
	including 6 (CompressionLevelDefault).

	0 (CompressionLevelNone) will change the desiredCompressionMethod
	to CompressionStored. All other arguments will change the
	desiredCompressionMethod to CompressionDeflated."

	| old |
	old _ desiredCompressionLevel.
	desiredCompressionLevel _ aNumber.
	desiredCompressionMethod _ (aNumber > 0)
		ifTrue: [ CompressionDeflated ]
		ifFalse: [ CompressionStored ].
	^old! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/21/2001 22:03'!
desiredCompressionMethod
	"Get my desiredCompressionMethod.
	This is the method that will be used to write"

	^desiredCompressionMethod! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 11:25'!
desiredCompressionMethod: aNumber
	"Set my desiredCompressionMethod
	This is the method that will be used to write.
	Answers prior desiredCompressionMethod.

	Only CompressionDeflated or CompressionStored are valid arguments.

	Changing to CompressionStored will change my desiredCompressionLevel
	to CompressionLevelNone; changing to CompressionDeflated will change my
	desiredCompressionLevel to CompressionLevelDefault."

	| old |
	old _ desiredCompressionMethod.
	desiredCompressionMethod _ aNumber.
	desiredCompressionLevel _ (aNumber = CompressionDeflated)
			ifTrue: [ CompressionLevelDefault ]
			ifFalse: [ CompressionLevelNone ].
	compressionMethod = CompressionStored ifTrue: [ compressedSize _ uncompressedSize ].
	^old.! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:25'!
fileComment
	^fileComment! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:25'!
fileComment: aString
	fileComment _ aString! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38'!
lastModTime
	"Return my last modification date/time stamp,
	converted to Squeak seconds"

	^self dosToSqueakTime: lastModFileDateTime! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'jmv 10/27/2015 18:16'!
localFileName
	"Answer my fileName in terms of the local directory naming convention"
	^fileName! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08'!
setLastModFileDateTimeFrom: aSmalltalkTime

	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 11/11/2002 21:03'!
splitFileName
	"Answer my name split on slash boundaries. A directory will have a trailing empty string."
	^ fileName findTokens: '/'.! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:38'!
uncompressedSize
	"Return the uncompressed size for this member."
	^uncompressedSize! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:18'!
unixFileAttributes
	^self mapPermissionsToUnix: externalFileAttributes.! !
!ZipArchiveMember methodsFor: 'accessing' stamp: 'nk 2/22/2001 00:24'!
unixFileAttributes: perms
	| oldPerms newPerms |
	oldPerms _ self mapPermissionsToUnix: externalFileAttributes.
	newPerms _  self isDirectory
			ifTrue: [ (perms bitAnd: FileAttrib bitInvert) bitOr: DirectoryAttrib ]
			ifFalse: [ (perms bitAnd: DirectoryAttrib bitInvert) bitOr: FileAttrib ].
	externalFileAttributes _ self mapPermissionsFromUnix: newPerms.
	^oldPerms.! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 2/28/2001 14:01'!
compressDataTo: aStream
	"Copy my deflated data to the given stream."
	| encoder startPos endPos |

	encoder _ ZipWriteStream on: aStream.
	startPos _ aStream position.

	[ readDataRemaining > 0 ] whileTrue: [ | data |
		data _ self readRawChunk: (4096 min: readDataRemaining).
		encoder nextPutAll: data asByteArray.
		readDataRemaining _ readDataRemaining - data size.
	].
	encoder finish. "not close!!"
	endPos _ aStream position.
	compressedSize _ endPos - startPos.
	crc32 _ encoder crc.
! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 11:04'!
copyDataTo: aStream

	compressionMethod = CompressionStored ifTrue: [ ^self copyDataWithCRCTo: aStream ].

	self copyRawDataTo: aStream.! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 3/7/2004 15:42'!
copyDataWithCRCTo: aStream
	"Copy my data to aStream. Also set the CRC-32.
	Only used when compressionMethod = desiredCompressionMethod = CompressionStored"

	uncompressedSize _ compressedSize _ readDataRemaining.

	crc32 _ 16rFFFFFFFF.

	[ readDataRemaining > 0 ] whileTrue: [ | data |
		data _ self readRawChunk: (4096 min: readDataRemaining).
		aStream nextPutAll: data.
		crc32 _ ZipWriteStream updateCrc: crc32 from: 1 to: data size in: data.
		readDataRemaining _ readDataRemaining - data size.
	].

	crc32 _ crc32 bitXor: 16rFFFFFFFF.
! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 11:04'!
copyRawDataTo: aStream

	[ readDataRemaining > 0 ] whileTrue: [ | data |
		data _ self readRawChunk: (4096 min: readDataRemaining).
		aStream nextPutAll: data.
		readDataRemaining _ readDataRemaining - data size.
	].
! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/24/2001 17:57'!
copyRawDataTo: aStream from: start to: finish

	readDataRemaining _ readDataRemaining min: finish - start + 1.

	self readRawChunk: start - 1.

	[ readDataRemaining > 0 ] whileTrue: [ | data |
		data _ self readRawChunk: (32768 min: readDataRemaining).
		aStream nextPutAll: data.
		readDataRemaining _ readDataRemaining - data size.
	].
! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'jmv 2/26/2016 16:51'!
refreshLocalFileHeaderTo: aStream
	"Re-writes my local header to the given stream.
	To be called after writing the data stream.
	Assumes that fileName and localExtraField sizes didn't change since last written."

	| here |
	here _ aStream position.
	aStream position: writeLocalHeaderRelativeOffset.

	aStream nextPutAll: LocalFileHeaderSignature.
	aStream nextUnsignedInt16Put: versionNeededToExtract bigEndian: false.
	aStream nextUnsignedInt16Put: bitFlag bigEndian: false.
	aStream nextUnsignedInt16Put: desiredCompressionMethod bigEndian: false.
	aStream nextUnsignedInt32Put: lastModFileDateTime bigEndian: false.
	aStream nextUnsignedInt32Put: crc32 bigEndian: false.
	aStream nextUnsignedInt32Put: (desiredCompressionMethod = CompressionStored
												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]) bigEndian: false.
	aStream nextUnsignedInt32Put: uncompressedSize bigEndian: false.
	aStream nextUnsignedInt16Put: fileName size bigEndian: false.
	aStream nextUnsignedInt16Put: localExtraField size bigEndian: false.

	aStream position: here! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'jmv 2/26/2016 16:53'!
writeCentralDirectoryFileHeaderTo: aStream
	"C2 v3 V4 v5 V2"

	aStream nextPutAll: CentralDirectoryFileHeaderSignature.
	aStream nextPut: versionMadeBy.
	aStream nextPut: fileAttributeFormat.

	aStream nextUnsignedInt16Put: versionNeededToExtract bigEndian: false.
	aStream nextUnsignedInt16Put: bitFlag bigEndian: false.
	aStream nextUnsignedInt16Put: desiredCompressionMethod bigEndian: false.

	aStream nextUnsignedInt32Put: lastModFileDateTime bigEndian: false.

	"These next 3 should have been updated during the write of the data"
	aStream nextUnsignedInt32Put: crc32 bigEndian: false.
	aStream nextUnsignedInt32Put: (desiredCompressionMethod = CompressionStored
												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]) bigEndian: false.
	aStream nextUnsignedInt32Put: uncompressedSize bigEndian: false.

	aStream nextUnsignedInt16Put: fileName size bigEndian: false.
	aStream nextUnsignedInt16Put: cdExtraField size bigEndian: false.
	aStream nextUnsignedInt16Put: fileComment size bigEndian: false.
	aStream nextUnsignedInt16Put: 0 bigEndian: false.		"diskNumberStart"
	aStream nextUnsignedInt16Put: internalFileAttributes bigEndian: false.

	aStream nextUnsignedInt32Put: externalFileAttributes bigEndian: false.
	aStream nextUnsignedInt32Put: writeLocalHeaderRelativeOffset bigEndian: false.

	aStream nextPutAll: fileName asByteArray.
	aStream nextPutAll: cdExtraField asByteArray.
	aStream nextPutAll: fileComment asByteArray.! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'jmv 2/26/2016 16:54'!
writeDataDescriptorTo: aStream
	"This writes a data descriptor to the given stream.
	Assumes that crc32, writeOffset, and uncompressedSize are
	set correctly (they should be after a write).
	Further, the local file header should have the
	GPBF_HAS_DATA_DESCRIPTOR_MASK (8) bit set."

	aStream nextUnsignedInt32Put: crc32 bigEndian: false.
	aStream nextUnsignedInt32Put: compressedSize bigEndian: false.
	aStream nextUnsignedInt32Put: uncompressedSize bigEndian: false! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15'!
writeDataTo: aStream
	"Copy my (possibly inflated or deflated) data to the given stream.
	This might do compression, decompression, or straight copying, depending
	on the values of compressionMethod and desiredCompressionMethod"

	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case
	data may be produced by the compressor (i.e., '' zipped size > 0) and must
	be stored in the file or else other utilities will treat the zip file as corrupt."

	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])
		ifTrue: [ ^self compressDataTo: aStream ].

	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])
		ifTrue: [ ^self uncompressDataTo: aStream ].

	self copyDataTo: aStream.! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'nk 2/24/2001 18:01'!
writeDataTo: aStream from: start to: finish
	"Copy my (possibly inflated or deflated) data to the given stream.
	But only the specified byte range.
	This might do decompression, or straight copying, depending
	on the values of compressionMethod and desiredCompressionMethod"

	uncompressedSize = 0 ifTrue: [ ^self ].	"nothing to do because no data"
	start > finish ifTrue: [ ^self ].
	start > uncompressedSize ifTrue: [ ^self ].

	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])
		ifTrue: [ ^self error: 'only supports uncompression or copying right now' ].

	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])
		ifTrue: [ ^self uncompressDataTo: aStream from: start to: finish ].

	self copyRawDataTo: aStream from: start to: finish.! !
!ZipArchiveMember methodsFor: 'private-writing' stamp: 'jmv 2/26/2016 16:55'!
writeLocalFileHeaderTo: aStream
	"Write my local header to a file handle.
	Stores the offset to the start of the header in my
	writeLocalHeaderRelativeOffset member."

	aStream nextPutAll: LocalFileHeaderSignature.
	aStream nextUnsignedInt16Put: versionNeededToExtract bigEndian: false.
	aStream nextUnsignedInt16Put: bitFlag bigEndian: false.
	aStream nextUnsignedInt16Put: desiredCompressionMethod bigEndian: false.

	aStream nextUnsignedInt32Put: lastModFileDateTime bigEndian: false.
	aStream nextUnsignedInt32Put: crc32 bigEndian: false.
	aStream nextUnsignedInt32Put: (desiredCompressionMethod = CompressionStored
												ifTrue: [ uncompressedSize ] ifFalse: [ compressedSize ]) bigEndian: false.
	aStream nextUnsignedInt32Put: uncompressedSize bigEndian: false.

	aStream nextUnsignedInt16Put: fileName size bigEndian: false.
	aStream nextUnsignedInt16Put: localExtraField size bigEndian: false.

	aStream nextPutAll: fileName asByteArray.
	aStream nextPutAll: localExtraField asByteArray! !
!ZipArchiveMember methodsFor: 'reading' stamp: 'ar 2/27/2001 14:30'!
contentStream
	"Answer my contents as a string."
	| s |
	s _ RWBinaryOrTextStream on: (String new: self uncompressedSize).
	self extractTo: s.
	^s reset! !
!ZipArchiveMember methodsFor: 'reading' stamp: 'jmv 10/8/2017 17:07:26'!
contents
	"Answer my contents as a string."
	| s |
	s _ RWBinaryOrTextStream on: (String new: self uncompressedSize).
	self extractTo: s.
	s useCharacters.
	^s contents! !
!ZipArchiveMember methodsFor: 'reading' stamp: 'jmv 10/8/2017 17:07:29'!
contentsFrom: start to: finish
	"Answer my contents as a string."
	| s |
	s _ RWBinaryOrTextStream on: (String new: finish - start + 1).
	self extractTo: s from: start to: finish.
	s useCharacters.
	^s contents! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'jmv 5/31/2016 10:38'!
extractInDirectory: aDirectoryEntry

	self extractToFileNamed: self localFileName inDirectory: aDirectoryEntry
! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'NM 9/21/2021 15:23:04'!
extractInDirectory: aDirectory overwrite: overwriteAll
	"Extract this entry into the given directory. Answer #okay, #failed, #abort, or #retryWithOverwrite."
	| path fileDir file index localName |
	path := fileName findTokens:'/'.
	localName := path last.
	fileDir := path allButLast inject: aDirectory into:[:base :part| base / part].
	fileDir assureExistence.
	"file := [fileDir privateNewFile: localName] on: FileExistsException do:[:ex| ex return: nil]."
	file := [FileIOAccessor new privateNewFile: (aDirectory /  (self fileName))] on: FileExistsException do:[:ex| ex return: nil].
	file ifNil:[
		overwriteAll ifFalse:[
			[index := (PopUpMenu labelArray:{
						'Yes, overwrite'. 
						'No, don''t overwrite'. 
						'Overwrite ALL files'.
						'Cancel operation'
					} lines: #(2)) startUpWithCaption: fileName, ' already exists. Overwrite?'.
			index == nil] whileTrue.
			index = 4 ifTrue:[^#abort].
			index = 3 ifTrue:[^#retryWithOverwrite].
			index = 2 ifTrue:[^#okay].
		].
		file := [fileDir privateForceNewFile: localName] on: Error do:[:ex| ex return].
		file ifNil:[^#failed].
	].
	self extractTo: file.
	file close.
	^#okay! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'nk 2/22/2001 18:03'!
extractTo: aStream
	| oldCompression |
	self isEncrypted ifTrue: [ self error: 'encryption is unsupported' ].
	aStream binary.
	oldCompression _ self desiredCompressionMethod: CompressionStored.
	self rewindData.
	self writeDataTo: aStream.
	self desiredCompressionMethod: oldCompression.
	self endRead.! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'nk 2/24/2001 18:03'!
extractTo: aStream from: start to: finish
	| oldCompression |
	self isEncrypted ifTrue: [ self error: 'encryption is unsupported' ].
	aStream binary.
	oldCompression _ self desiredCompressionMethod: CompressionStored.
	self rewindData.
	self writeDataTo: aStream from: start to: finish.
	self desiredCompressionMethod: oldCompression.
	self endRead.! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'pb 5/25/2016 01:16'!
extractToFileNamed: aFileName

	self extractToFileNamed: aFileName inDirectory: DirectoryEntry currentDirectory! !
!ZipArchiveMember methodsFor: 'extraction' stamp: 'NM 9/21/2021 15:23:13'!
extractToFileNamed: aLocalFileName inDirectory: aDirectoryEntry

	self isEncrypted ifTrue: [ ^self error: 'encryption unsupported' ].
	self isDirectory
		ifFalse: [
			(aDirectoryEntry / aLocalFileName) forceWriteStreamDo: [ :stream |
				self extractTo: stream ] ]
		ifTrue: [
			(aDirectoryEntry / aLocalFileName) asDirectoryEntry assureExistence ]! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:40'!
hasDataDescriptor
	^ (bitFlag bitAnd: 8)	~= 0 "GPBF_HAS_DATA_DESCRIPTOR_MASK"! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:00'!
isDirectory
	^false! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:39'!
isEncrypted
	"Return true if this member is encrypted (this is unsupported)"
	^ (bitFlag bitAnd: 1) ~= 0! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:41'!
isTextFile
	"Returns true if I am a text file.
	Note that this module does not currently do anything with this flag
	upon extraction or storage.
	That is, bytes are stored in native format whether or not they came
	from a text file."
	^ (internalFileAttributes bitAnd: 1) ~= 0
! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:43'!
isTextFile: aBoolean
	"Set whether I am a text file.
	Note that this module does not currently do anything with this flag
	upon extraction or storage.
	That is, bytes are stored in native format whether or not they came
	from a text file."
	internalFileAttributes _ aBoolean
		ifTrue: [ internalFileAttributes bitOr: 1 ]
		ifFalse: [ internalFileAttributes bitAnd: 1 bitInvert ]
! !
!ZipArchiveMember methodsFor: 'testing' stamp: 'nk 2/21/2001 20:38'!
looksLikeDirectory
	^false! !
!ZipArchiveMember methodsFor: 'initialization' stamp: 'nk 2/24/2001 16:16' overrides: 50598752!
initialize
	super initialize.
	lastModFileDateTime _ 0.
	fileAttributeFormat _ FaUnix.
	versionMadeBy _ 20.
	versionNeededToExtract _ 20.
	bitFlag _ 0.
	compressionMethod _ CompressionStored.
	desiredCompressionMethod _ CompressionDeflated.
	desiredCompressionLevel _ CompressionLevelDefault.
	internalFileAttributes _ 0.
	externalFileAttributes _ 0.
	fileName _ ''.
	cdExtraField _ ''.
	localExtraField _ ''.
	fileComment _ ''.
	crc32 _ 0.
	compressedSize _ 0.
	uncompressedSize _ 0.
	self unixFileAttributes: DefaultFilePermissions.! !
!ZipArchiveMember methodsFor: 'writing' stamp: 'nk 2/23/2001 11:28'!
writeTo: aStream
	self rewindData.
	writeLocalHeaderRelativeOffset _ aStream position.
	self writeLocalFileHeaderTo: aStream.
	self writeDataTo: aStream.
	self refreshLocalFileHeaderTo: aStream.! !
!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27'!
newFromDirectory: aFileName
	^ZipDirectoryMember newNamed: aFileName! !
!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27' overrides: 50598792!
newFromFile: aFileName
	^ZipNewFileMember newNamed: aFileName! !
!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:25'!
newFromString: aString named: aFileName
	^ZipStringMember newFrom: aString named: aFileName! !
!ZipArchiveMember class methodsFor: 'instance creation' stamp: 'nk 2/21/2001 20:40'!
newFromZipFile: stream named: fileName
	^ZipFileMember newFrom: stream named: fileName! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 11/11/2002 21:46'!
canonicalizeFileName
	"For security reasons, make all paths relative and remove any ../ portions"

	[fileName beginsWith: '/'] whileTrue: [fileName := fileName allButFirst].
	fileName := fileName copyReplaceAll: '../' with: ''! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'jmv 2/26/2016 16:30'!
readCentralDirectoryFileHeaderFrom: aStream
	"Assumes aStream positioned after signature"

	| fileNameLength extraFieldLength fileCommentLength |

	versionMadeBy _ aStream next.
	fileAttributeFormat _ aStream next.

	versionNeededToExtract _ aStream nextUnsignedInt16BigEndian: false.
	bitFlag _ aStream nextUnsignedInt16BigEndian: false.
	compressionMethod _ aStream nextUnsignedInt16BigEndian: false.

	lastModFileDateTime _ aStream nextUnsignedInt32BigEndian: false.
	crc32 _ aStream nextUnsignedInt32BigEndian: false.
	compressedSize _ aStream nextUnsignedInt32BigEndian: false.
	uncompressedSize _ aStream nextUnsignedInt32BigEndian: false.

	fileNameLength _ aStream nextUnsignedInt16BigEndian: false.
	extraFieldLength _ aStream nextUnsignedInt16BigEndian: false.
	fileCommentLength _ aStream nextUnsignedInt16BigEndian: false.
	aStream nextUnsignedInt16BigEndian: false. 	"disk number start"
	internalFileAttributes _ aStream nextUnsignedInt16BigEndian: false.

	externalFileAttributes _ aStream nextUnsignedInt32BigEndian: false.
	localHeaderRelativeOffset _ aStream nextUnsignedInt32BigEndian: false.

	fileName _ (aStream next: fileNameLength) asString.
	cdExtraField _ (aStream next: extraFieldLength) asByteArray.
	fileComment _ (aStream next: fileCommentLength) asString.

	self desiredCompressionMethod: compressionMethod! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 11/11/2002 21:48'!
readFrom: aStream 
	"assumes aStream positioned after CD header; leaves stream positioned after my CD entry"

	self readCentralDirectoryFileHeaderFrom: aStream.
	self readLocalDirectoryFileHeaderFrom: aStream.
	self endRead.
	self canonicalizeFileName.
! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'jmv 2/26/2016 16:31'!
readLocalDirectoryFileHeaderFrom: aStream 
	"Positions stream as necessary. Will return stream to its original position"

	| fileNameLength extraFieldLength xcrc32 xcompressedSize xuncompressedSize sig oldPos |

	oldPos _ aStream position.

	aStream position: localHeaderRelativeOffset.

	sig _ aStream next: 4.
	sig = LocalFileHeaderSignature asByteArray
		ifFalse: [ aStream position: oldPos.
				^self error: 'bad LH signature at ', localHeaderRelativeOffset hex ].

	versionNeededToExtract _ aStream nextUnsignedInt16BigEndian: false.
	bitFlag _ aStream nextUnsignedInt16BigEndian: false.
	compressionMethod _ aStream nextUnsignedInt16BigEndian: false.

	lastModFileDateTime _ aStream nextUnsignedInt32BigEndian: false.
	xcrc32 _ aStream nextUnsignedInt32BigEndian: false.
	xcompressedSize _ aStream nextUnsignedInt32BigEndian: false.
	xuncompressedSize _ aStream nextUnsignedInt32BigEndian: false.

	fileNameLength _ aStream nextUnsignedInt16BigEndian: false.
	extraFieldLength _ aStream nextUnsignedInt16BigEndian: false.

	fileName _ (aStream next: fileNameLength) asString.
	localExtraField _ (aStream next: extraFieldLength) asByteArray.

	dataOffset _ aStream position.

	"Don't trash these fields if we already got them from the central directory"
	self hasDataDescriptor ifFalse: [
		crc32 _ xcrc32.
		compressedSize _ xcompressedSize.
		uncompressedSize _ xuncompressedSize.
	].

	aStream position: oldPos.! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/22/2001 20:46' overrides: 50598838!
readRawChunk: n
	^stream next: n! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'nk 2/23/2001 09:56' overrides: 50598842!
rewindData
	super rewindData.
	(stream isNil or: [ stream closed ])
		ifTrue: [ self error: 'stream missing or closed' ].
	stream position: (localHeaderRelativeOffset + 4).
	self skipLocalDirectoryFileHeaderFrom: stream.! !
!ZipFileMember methodsFor: 'private-reading' stamp: 'jmv 2/26/2016 16:31'!
skipLocalDirectoryFileHeaderFrom: aStream 
	"Assumes that stream is positioned after signature."

	|  extraFieldLength fileNameLength |
	aStream next: 22.
	fileNameLength _ aStream nextUnsignedInt16BigEndian: false.
	extraFieldLength _ aStream nextUnsignedInt16BigEndian: false.
	aStream next: fileNameLength.
	aStream next: extraFieldLength.
	dataOffset _ aStream position! !
!ZipFileMember methodsFor: 'initialization' stamp: 'ar 3/2/2001 18:46' overrides: 50598748!
close
	stream ifNotNil:[stream close].! !
!ZipFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:52' overrides: 50599460!
initialize
	super initialize.
	crc32 _ 0.
	localHeaderRelativeOffset _ 0.
	dataOffset _ 0.! !
!ZipFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:51'!
stream: aStream externalFileName: aFileName
	stream _ aStream.
	externalFileName _ aFileName.! !
!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 11:04' overrides: 50599056!
copyDataTo: aStream

	self copyRawDataTo: aStream.! !
!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 3/27/2002 11:20'!
localHeaderRelativeOffset
	^localHeaderRelativeOffset! !
!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 3/7/2004 16:08'!
uncompressDataTo: aStream

	| decoder buffer chunkSize crcErrorMessage |
	decoder _ ZipReadStream on: stream.
	decoder expectedCrc: self crc32.
	buffer _ ByteArray new: (32768 min: readDataRemaining).
	crcErrorMessage _ nil.

	[[ readDataRemaining > 0 ] whileTrue: [
		chunkSize _ 32768 min: readDataRemaining.
		buffer _ decoder next: chunkSize into: buffer startingAt: 1.
		aStream next: chunkSize putAll: buffer startingAt: 1.
		readDataRemaining _ readDataRemaining - chunkSize.
	]] on: CRCError do: [ :ex | crcErrorMessage _ ex messageText. ex proceed ].

	crcErrorMessage ifNotNil: [ self isCorrupt: true. CRCError signal: crcErrorMessage ]

! !
!ZipFileMember methodsFor: 'private-writing' stamp: 'nk 2/24/2001 17:52'!
uncompressDataTo: aStream from: start to: finish

	| decoder buffer chunkSize |
	decoder _ FastInflateStream on: stream.
	readDataRemaining _ readDataRemaining min: finish - start + 1.
	buffer _ ByteArray new: (32768 min: readDataRemaining).
	decoder next: start - 1.

	[ readDataRemaining > 0 ] whileTrue: [
		chunkSize _ 32768 min: readDataRemaining.
		buffer _ decoder next: chunkSize into: buffer startingAt: 1.
		aStream next: chunkSize putAll: buffer startingAt: 1.
		readDataRemaining _ readDataRemaining - chunkSize.
	].
! !
!ZipFileMember methodsFor: 'testing' stamp: 'nk 2/21/2001 21:52' overrides: 50599456!
looksLikeDirectory
	^fileName last = $/
		and: [ uncompressedSize = 0 ]! !
!ZipFileMember methodsFor: 'testing' stamp: 'jmv 10/14/2015 17:28' overrides: 50598781!
usesFileNamed: aFileName
	"Do I require aFileName? That is, do I care if it's clobbered?"

	^externalFileName asFileEntry = aFileName asFileEntry! !
!ZipFileMember class methodsFor: 'as yet unclassified' stamp: 'nk 2/22/2001 17:31'!
newFrom: stream named: fileName
	^(self new) stream: stream externalFileName: fileName! !
!ZipDirectoryMember methodsFor: 'private' stamp: 'nk 2/21/2001 21:55' overrides: 50598801!
asDirectory
	^self! !
!ZipDirectoryMember methodsFor: 'private' stamp: 'nk 3/27/2002 11:30' overrides: 50599630!
rewindData! !
!ZipDirectoryMember methodsFor: 'private' stamp: 'cmm 9/16/2010 18:59' overrides: 50599209!
writeDataTo: aStream
       "Write nothing. Directories have no contents to write."! !
!ZipDirectoryMember methodsFor: 'accessing' stamp: 'nk 2/23/2001 10:00' overrides: 50598953!
desiredCompressionMethod: aNumber! !
!ZipDirectoryMember methodsFor: 'accessing' stamp: 'jmv 10/14/2015 17:34' overrides: 50598772!
localFileName: aString
	| fe |
	super localFileName: aString.
	fileName last = $/ ifFalse: [ fileName _ fileName, '/' ].
	fe _ fileName asDirectoryEntry.
	fe exists ifTrue: [
		self setLastModFileDateTimeFrom: fe modificationTime ]! !
!ZipDirectoryMember methodsFor: 'initialization' stamp: 'nk 2/23/2001 10:01' overrides: 50599660!
initialize
	super initialize.
	super desiredCompressionMethod: CompressionStored.! !
!ZipDirectoryMember methodsFor: 'testing' stamp: 'nk 2/22/2001 00:00' overrides: 50599421!
isDirectory
	^true! !
!ZipDirectoryMember methodsFor: 'testing' stamp: 'nk 3/27/2002 11:29' overrides: 50599730!
usesFileNamed: aName
	^false! !
!ZipDirectoryMember class methodsFor: 'as yet unclassified' stamp: 'nk 12/20/2002 14:57'!
newNamed: aFileName
	^(self new) localFileName: aFileName; yourself! !
!ZipNewFileMember methodsFor: 'initialization' stamp: 'ar 3/2/2001 18:50' overrides: 50598748!
close
	stream ifNotNil:[stream close].! !
!ZipNewFileMember methodsFor: 'initialization' stamp: 'pb 5/25/2016 01:51'!
from: aFileName
	| entry |
	compressionMethod _ CompressionStored.
	"Now get the size, attributes, and timestamps, and see if the file exists"
	stream _ aFileName asFileEntry readStream.
	self localFileName: (externalFileName _ stream name).
	entry _ aFileName asFileEntry.
	compressedSize _ uncompressedSize _ entry fileSize.
	desiredCompressionMethod _ compressedSize > 0 ifTrue: [ CompressionDeflated ] ifFalse: [ CompressionStored ].
	self setLastModFileDateTimeFrom: entry modificationTime
! !
!ZipNewFileMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:56' overrides: 50599460!
initialize
	super initialize.
	externalFileName _ ''.! !
!ZipNewFileMember methodsFor: 'private' stamp: 'nk 2/22/2001 20:48' overrides: 50598838!
readRawChunk: n
	^stream next: n! !
!ZipNewFileMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 09:58' overrides: 50598842!
rewindData
	super rewindData.
	readDataRemaining _ stream size.
	stream position: 0.! !
!ZipNewFileMember methodsFor: 'testing' stamp: 'jmv 10/14/2015 17:28' overrides: 50598781!
usesFileNamed: aFileName
	"Do I require aFileName? That is, do I care if it's clobbered?"

	^externalFileName asFileEntry = aFileName asFileEntry! !
!ZipNewFileMember class methodsFor: 'instance creation' stamp: 'nk 2/22/2001 17:27'!
newNamed: aFileName
	^(self new) from: aFileName! !
!ZipStringMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 16:47' overrides: 50599308!
contents
	^contents! !
!ZipStringMember methodsFor: 'initialization' stamp: 'jmv 4/17/2013 11:57'!
contents: aString
	contents _ aString.
	compressedSize _ uncompressedSize _ aString size.
	"set the file date to now"
	self setLastModFileDateTimeFrom: Time localSecondClock! !
!ZipStringMember methodsFor: 'initialization' stamp: 'nk 2/22/2001 20:50' overrides: 50599460!
initialize
	super initialize.
	self contents: ''.
	compressionMethod _ desiredCompressionMethod _ CompressionStored.
! !
!ZipStringMember methodsFor: 'private' stamp: 'nk 2/22/2001 20:51' overrides: 50598838!
readRawChunk: n
	^stream next: n! !
!ZipStringMember methodsFor: 'private-writing' stamp: 'nk 2/23/2001 10:28' overrides: 50598842!
rewindData
	super rewindData.
	stream _ ReadStream on: contents.
	readDataRemaining _ contents size.! !
!ZipStringMember class methodsFor: 'as yet unclassified' stamp: 'nk 12/20/2002 15:06'!
newFrom: aString named: aFileName
	^(self new) contents: aString; localFileName: aFileName; yourself! !
!CodeFileBrowser class methodsFor: '*Compression' stamp: 'jmv 10/2/2015 16:55'!
browseMCZCode: aFileEntry
	"Browse the selected file."

	CodeFileBrowserWindow browseMCZFile: aFileEntry! !
!CodeFileBrowser class methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:26:10'!
serviceBrowseMCZCode
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'browse code'
		selector: #browseMCZCode:
		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'code'
		icon: #editFindReplaceIcon)
			argumentGetter: [ :fileList |
				fileList selectedFileEntry ]! !
!ChangeList class methodsFor: '*Compression' stamp: 'jmv 4/4/2020 12:59:40'!
browseMCZContents: aFileEntry
	"Browse the selected file."
	|  unzipped changeList fullName packageFile pkName |
	
	"For Monticello packages we do as we do with our own .pck.st files: Instead of just browsing
	contents, also include what is no longer part of the package (and should therefore be removed on install)
	See #browsePackageContents:
	However, this was never tested to run!!"
	self flag: #jmvVer.

	fullName _ aFileEntry pathName.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	aFileEntry readStreamDo: [ :stream |
		unzipped _ stream asUnZippedStream: 'snapshot/source.st'.
		unzipped ascii.
		changeList _ self new scanFile: unzipped from: 0 to: unzipped size.
		stream reset.
		packageFile _ CodePackageFile new.
		packageFile
			buildFileStream: unzipped
			packageName: pkName
			fullName: fullName.
	].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new className: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry pathName! !
!ChangeList class methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:27:25'!
serviceMCZContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'see file contents'
		selector: #browseMCZContents:
		description: 'open a code file contents tool on this file'
		buttonLabel: 'contents'
		icon: #changesIcon)
			argumentGetter: [ :fileList |
				fileList selectedFileEntry ]! !
!FileList methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:55:02'!
compressFile
	"Compress the currently selected file"

	self fullName asFileEntry readStream compressFile.
	self updateFileList! !
!FileList methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:38:30'!
serviceCompressFile
	"Answer a service for compressing a file"

	^ SimpleServiceEntry
		provider: self
		label: 'compress'
		selector: #compressFile
		description: 'compress file'
		buttonLabel: 'compress'
		icon: #goBottomIcon! !
!ArrayedCollection methodsFor: '*Compression' stamp: 'tk 3/7/2001 18:07'!
writeOnGZIPByteStream: aStream 
	"We only intend this for non-pointer arrays.  Do nothing if I contain pointers."

	self class isPointers | self class isWords not ifTrue: [^ super writeOnGZIPByteStream: aStream].
		"super may cause an error, but will not be called."
	
	aStream nextPutAllWordArray: self! !
!String methodsFor: '*Compression' stamp: 'jmv 9/5/2016 22:13:54'!
unzipped
	|  magic1 magic2 |
	magic1 _ (self at: 1) numericValue.
	magic2 _ (self at: 2) numericValue.
	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse: [ ^self ].
	^ (GZipReadStream on: self) upToEnd! !
!PositionableStream methodsFor: '*Compression' stamp: 'jmv 6/10/2013 20:40'!
asZLibReadStream
	^ ZLibReadStream on: collection from: position+1 to: readLimit! !
!ReadWriteStream methodsFor: '*Compression' stamp: 'jmv 6/10/2013 20:39'!
asUnZippedStream
	|  isGZip outputStream first strm |
	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else."

	strm _ self binary.

	first _ strm next.
	isGZip _ (strm next * 256 + first) = (GZipConstants gzipMagic).
	strm skip: -2.
	isGZip 
		ifTrue: [ outputStream _ (RWBinaryOrTextStream with:
									(GZipReadStream on: strm) upToEnd) reset.
				strm close]
		ifFalse: [ outputStream _ strm].
	^ outputStream! !
!ReadWriteStream methodsFor: '*Compression' stamp: 'jmv 6/10/2013 20:40'!
asUnZippedStream: memberFileName
	|  strm archive which |
	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."

	strm _ self binary.
	strm isZipArchive ifFalse: [
		^self error: 'Not a Zip file' ].
	
	archive _ ZipArchive new readFrom: strm.
	which _ archive members 
		detect: [:any | any fileName  = memberFileName] 
		ifNone: nil.
	which ifNil: [
		archive close.
		^ self error: 'Can''t find requested file in archive'].
	strm _ which contentStream.
	archive close.
	^ strm! !
!ReadWriteStream methodsFor: '*Compression' stamp: 'jmv 6/10/2013 20:40'!
isZipArchive
	"Determine if this appears to be a valid Zip archive"
	|  sig |
	self binary.
	sig _ (self next: 4) asString.
	self position: self position - 4. "rewind"
	^ (ZipArchive validSignatures includes: sig)! !
!FileStream methodsFor: '*Compression' stamp: 'jmv 6/10/2013 20:39'!
viewGZipContents
	"View the contents of a gzipped file"

	|  stringContents |
	self binary.
	stringContents _ self contentsOfEntireFile.
	stringContents _ (GZipReadStream on: stringContents) upToEnd.
	stringContents _ stringContents asString withCuisLineEndings.

	Workspace new
		contents: stringContents;
		openLabel: 'Decompressed contents of: ', self localName! !
!StandardFileStream methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:57:48'!
compressFile
	"Write a new file that has the data in me compressed in GZip format."
	|  zipped buffer |

	self readOnly; binary.
	zipped _ (self name, '.gz') asFileEntry writeStream.
	zipped binary.
	zipped _ GZipWriteStream on: zipped.
	buffer _ ByteArray new: 50000.
	'Compressing ', self fullName displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[self atEnd] whileFalse: [
				barBlock value: self position.
				zipped nextPutAll: (self nextInto: buffer)].
			zipped close.
			self close ].
	 ^zipped! !
!CodeFileBrowserWindow class methodsFor: '*Compression' stamp: 'jmv 3/24/2020 11:20:46'!
browseMCZFile: aFileEntry

	| codeFile unzipped |
	aFileEntry readStreamDo: [ :stream |
		unzipped _ stream asUnZippedStream: 'snapshot/source.st'.
		unzipped ascii.
		codeFile _ (CodeFile new fullName: aFileEntry pathName; buildFrom: unzipped) ].
	CodeFileBrowser browseCodeFileEntry: codeFile! !
!CodePackageFile class methodsFor: '*Compression' stamp: 'jmv 10/2/2015 16:55'!
browseMCZCode: aFileEntry
	"Browse the selected file."

	CodeFileBrowserWindow browseMCZFile: aFileEntry! !
!CodePackageFile class methodsFor: '*Compression' stamp: 'jmv 4/4/2020 12:57:16'!
installMonticelloPackage: aFileEntry
	
	| fullName pkName unzip codePackageFile |
	fullName _ aFileEntry pathName.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	aFileEntry readStreamDo: [ :stream |
		unzip _ stream asUnZippedStream: 'snapshot/source.st'.
		unzip ascii.
		codePackageFile _ CodePackageFile new.
		codePackageFile
			buildFileStream: unzip
			packageName: pkName
			fullName: fullName.
		codePackageFile install ]! !
!CodePackageFile class methodsFor: '*Compression' stamp: 'jmv 11/3/2016 11:38:49'!
monticelloPackageNameFrom: fullName
	| localName |
	localName _ fullName asFileEntry name.
	^(localName prefixAndSuffix: $-)
		ifNotNil: [ :ary | ary first ]
		ifNil: [ localName withoutSuffix: '.mcz' ]! !
!CodePackageFile class methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:28:36'!
serviceBrowseMCZCode
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'browse code'
		selector: #browseMCZCode:
		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'code'
		icon: #editFindReplaceIcon)
			argumentGetter: [ :fileList | fileList selectedFileEntry ] ! !
!CodePackageFile class methodsFor: '*Compression' stamp: 'HAW 1/2/2019 18:29:13'!
serviceInstallMonticelloPackage
	"Answer the service of installing a Monticello package file (Squeak's compressed chunk format file for a package)"

	^ (SimpleServiceEntry
		provider: self 
		label: 'install Monticello package'
		selector: #installMonticelloPackage:
		description: 'install the Monticello package, replacing all existing code in the package (if any); create a new change set just for the installation'
		buttonLabel: 'install package'
		icon: #saveIcon)
			argumentGetter: [ :fileList | fileList selectedFileEntry ] ! !

!classDefinition: #SoundBuffer category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ArrayedCollection variableWordSubclass: #SoundBuffer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SoundBuffer category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ArrayedCollection variableWordSubclass: #SoundBuffer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SoundBuffer class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundBuffer class
	instanceVariableNames: ''!

!classDefinition: 'SoundBuffer class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundBuffer class
	instanceVariableNames: ''!

!classDefinition: #Sonogram category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ImageMorph subclass: #Sonogram
	instanceVariableNames: 'lastX scrollDelta columnForm minVal maxVal pixValMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #Sonogram category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ImageMorph subclass: #Sonogram
	instanceVariableNames: 'lastX scrollDelta columnForm minVal maxVal pixValMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'Sonogram class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Sonogram class
	instanceVariableNames: ''!

!classDefinition: 'Sonogram class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Sonogram class
	instanceVariableNames: ''!

!classDefinition: #AIFFFileReader category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AIFFFileReader
	instanceVariableNames: 'in fileType channelCount frameCount bitsPerSample samplingRate channelData channelDataOffset markers pitch gain isLooped skipDataChunk mergeIfStereo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #AIFFFileReader category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AIFFFileReader
	instanceVariableNames: 'in fileType channelCount frameCount bitsPerSample samplingRate channelData channelDataOffset markers pitch gain isLooped skipDataChunk mergeIfStereo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'AIFFFileReader class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AIFFFileReader class
	instanceVariableNames: ''!

!classDefinition: 'AIFFFileReader class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AIFFFileReader class
	instanceVariableNames: ''!

!classDefinition: #AbstractSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AbstractSound
	instanceVariableNames: 'envelopes mSecsSinceStart samplesUntilNextControl scaledVol scaledVolIncr scaledVolLimit'
	classVariableNames: 'FloatScaleFactor MaxScaledValue PitchesForBottomOctave ScaleFactor Sounds TopOfBottomOctave UnloadedSnd'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #AbstractSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AbstractSound
	instanceVariableNames: 'envelopes mSecsSinceStart samplesUntilNextControl scaledVol scaledVolIncr scaledVolLimit'
	classVariableNames: 'FloatScaleFactor MaxScaledValue PitchesForBottomOctave ScaleFactor Sounds TopOfBottomOctave UnloadedSnd'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'AbstractSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound class
	instanceVariableNames: ''!

!classDefinition: 'AbstractSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound class
	instanceVariableNames: ''!

!classDefinition: #FMSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #FMSound
	instanceVariableNames: 'initialCount count waveTable scaledWaveTableSize scaledIndex scaledIndexIncr modulation multiplier normalizedModulation scaledOffsetIndex scaledOffsetIndexIncr'
	classVariableNames: 'SineTable'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #FMSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #FMSound
	instanceVariableNames: 'initialCount count waveTable scaledWaveTableSize scaledIndex scaledIndexIncr modulation multiplier normalizedModulation scaledOffsetIndex scaledOffsetIndexIncr'
	classVariableNames: 'SineTable'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'FMSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound class
	instanceVariableNames: ''!

!classDefinition: 'FMSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound class
	instanceVariableNames: ''!

!classDefinition: #FMBassoonSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #FMBassoonSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #FMBassoonSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #FMBassoonSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'FMBassoonSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMBassoonSound class
	instanceVariableNames: ''!

!classDefinition: 'FMBassoonSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMBassoonSound class
	instanceVariableNames: ''!

!classDefinition: #FMClarinetSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #FMClarinetSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #FMClarinetSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #FMClarinetSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'FMClarinetSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMClarinetSound class
	instanceVariableNames: ''!

!classDefinition: 'FMClarinetSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMClarinetSound class
	instanceVariableNames: ''!

!classDefinition: #UnloadedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #UnloadedSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #UnloadedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
FMSound subclass: #UnloadedSound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'UnloadedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
UnloadedSound class
	instanceVariableNames: ''!

!classDefinition: 'UnloadedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
UnloadedSound class
	instanceVariableNames: ''!

!classDefinition: #LoopedSampledSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #LoopedSampledSound
	instanceVariableNames: 'initialCount count releaseCount sampleCountForRelease leftSamples rightSamples originalSamplingRate perceivedPitch gain firstSample lastSample loopEnd scaledLoopLength scaledIndex scaledIndexIncr'
	classVariableNames: 'FloatLoopIndexScaleFactor LoopIndexFractionMask LoopIndexScaleFactor'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #LoopedSampledSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #LoopedSampledSound
	instanceVariableNames: 'initialCount count releaseCount sampleCountForRelease leftSamples rightSamples originalSamplingRate perceivedPitch gain firstSample lastSample loopEnd scaledLoopLength scaledIndex scaledIndexIncr'
	classVariableNames: 'FloatLoopIndexScaleFactor LoopIndexFractionMask LoopIndexScaleFactor'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'LoopedSampledSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
LoopedSampledSound class
	instanceVariableNames: ''!

!classDefinition: 'LoopedSampledSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
LoopedSampledSound class
	instanceVariableNames: ''!

!classDefinition: #MixedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #MixedSound
	instanceVariableNames: 'sounds leftVols rightVols soundDone'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #MixedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #MixedSound
	instanceVariableNames: 'sounds leftVols rightVols soundDone'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'MixedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
MixedSound class
	instanceVariableNames: ''!

!classDefinition: 'MixedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
MixedSound class
	instanceVariableNames: ''!

!classDefinition: #PluckedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #PluckedSound
	instanceVariableNames: 'initialCount count ring scaledIndex scaledIndexIncr scaledIndexLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #PluckedSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #PluckedSound
	instanceVariableNames: 'initialCount count ring scaledIndex scaledIndexIncr scaledIndexLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'PluckedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
PluckedSound class
	instanceVariableNames: ''!

!classDefinition: 'PluckedSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
PluckedSound class
	instanceVariableNames: ''!

!classDefinition: #QueueSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #QueueSound
	instanceVariableNames: 'startTime sounds currentSound done'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #QueueSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #QueueSound
	instanceVariableNames: 'startTime sounds currentSound done'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'QueueSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
QueueSound class
	instanceVariableNames: ''!

!classDefinition: 'QueueSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
QueueSound class
	instanceVariableNames: ''!

!classDefinition: #RepeatingSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #RepeatingSound
	instanceVariableNames: 'sound iterationCount iteration samplesPerIteration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #RepeatingSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #RepeatingSound
	instanceVariableNames: 'sound iterationCount iteration samplesPerIteration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'RepeatingSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RepeatingSound class
	instanceVariableNames: ''!

!classDefinition: 'RepeatingSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RepeatingSound class
	instanceVariableNames: ''!

!classDefinition: #RestSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #RestSound
	instanceVariableNames: 'initialCount count'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #RestSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #RestSound
	instanceVariableNames: 'initialCount count'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'RestSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RestSound class
	instanceVariableNames: ''!

!classDefinition: 'RestSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RestSound class
	instanceVariableNames: ''!

!classDefinition: #ReverbSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #ReverbSound
	instanceVariableNames: 'sound tapDelays tapGains tapCount bufferSize bufferIndex leftBuffer rightBuffer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #ReverbSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #ReverbSound
	instanceVariableNames: 'sound tapDelays tapGains tapCount bufferSize bufferIndex leftBuffer rightBuffer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'ReverbSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ReverbSound class
	instanceVariableNames: ''!

!classDefinition: 'ReverbSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ReverbSound class
	instanceVariableNames: ''!

!classDefinition: #SampledSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #SampledSound
	instanceVariableNames: 'initialCount count samples originalSamplingRate samplesSize scaledIndex indexHighBits scaledIncrement'
	classVariableNames: 'CoffeeCupClink DefaultSampleTable IncrementFractionBits IncrementScaleFactor NominalSamplePitch ScaledIndexOverflow SoundLibrary'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SampledSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #SampledSound
	instanceVariableNames: 'initialCount count samples originalSamplingRate samplesSize scaledIndex indexHighBits scaledIncrement'
	classVariableNames: 'CoffeeCupClink DefaultSampleTable IncrementFractionBits IncrementScaleFactor NominalSamplePitch ScaledIndexOverflow SoundLibrary'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SampledSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SampledSound class
	instanceVariableNames: ''!

!classDefinition: 'SampledSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SampledSound class
	instanceVariableNames: ''!

!classDefinition: #SequentialSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #SequentialSound
	instanceVariableNames: 'sounds currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SequentialSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #SequentialSound
	instanceVariableNames: 'sounds currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SequentialSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SequentialSound class
	instanceVariableNames: ''!

!classDefinition: 'SequentialSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SequentialSound class
	instanceVariableNames: ''!

!classDefinition: #StreamingMonoSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #StreamingMonoSound
	instanceVariableNames: 'stream volume repeat headerStart audioDataStart streamSamplingRate totalSamples codec mixer leftoverSamples lastBufferMSecs mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #StreamingMonoSound category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #StreamingMonoSound
	instanceVariableNames: 'stream volume repeat headerStart audioDataStart streamSamplingRate totalSamples codec mixer leftoverSamples lastBufferMSecs mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'StreamingMonoSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
StreamingMonoSound class
	instanceVariableNames: ''!

!classDefinition: 'StreamingMonoSound class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
StreamingMonoSound class
	instanceVariableNames: ''!

!classDefinition: #ScorePlayer category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #ScorePlayer
	instanceVariableNames: 'score instruments overallVolume leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds activeMIDINotes midiPort midiPlayerProcess durationInTicks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #ScorePlayer category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractSound subclass: #ScorePlayer
	instanceVariableNames: 'score instruments overallVolume leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds activeMIDINotes midiPort midiPlayerProcess durationInTicks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'ScorePlayer class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ScorePlayer class
	instanceVariableNames: ''!

!classDefinition: 'ScorePlayer class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ScorePlayer class
	instanceVariableNames: ''!

!classDefinition: #CompressedSoundData category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #CompressedSoundData
	instanceVariableNames: 'channels soundClassName codecName loopEnd loopLength perceivedPitch samplingRate gain firstSample cachedSound'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #CompressedSoundData category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #CompressedSoundData
	instanceVariableNames: 'channels soundClassName codecName loopEnd loopLength perceivedPitch samplingRate gain firstSample cachedSound'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'CompressedSoundData class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
CompressedSoundData class
	instanceVariableNames: ''!

!classDefinition: 'CompressedSoundData class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
CompressedSoundData class
	instanceVariableNames: ''!

!classDefinition: #Envelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #Envelope
	instanceVariableNames: 'points loopStartIndex loopEndIndex loopStartMSecs loopMSecs target updateSelector loopEndMSecs endMSecs scale decayScale lastValue currValue valueIncr nextRecomputeTime noChangesDuringLoop'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #Envelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #Envelope
	instanceVariableNames: 'points loopStartIndex loopEndIndex loopStartMSecs loopMSecs target updateSelector loopEndMSecs endMSecs scale decayScale lastValue currValue valueIncr nextRecomputeTime noChangesDuringLoop'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'Envelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope class
	instanceVariableNames: ''!

!classDefinition: 'Envelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope class
	instanceVariableNames: ''!

!classDefinition: #PitchEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #PitchEnvelope
	instanceVariableNames: 'centerPitch'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #PitchEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #PitchEnvelope
	instanceVariableNames: 'centerPitch'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'PitchEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
PitchEnvelope class
	instanceVariableNames: ''!

!classDefinition: 'PitchEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
PitchEnvelope class
	instanceVariableNames: ''!

!classDefinition: #RandomEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #RandomEnvelope
	instanceVariableNames: 'rand lowLimit highLimit delta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #RandomEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #RandomEnvelope
	instanceVariableNames: 'rand lowLimit highLimit delta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'RandomEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RandomEnvelope class
	instanceVariableNames: ''!

!classDefinition: 'RandomEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
RandomEnvelope class
	instanceVariableNames: ''!

!classDefinition: #VolumeEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #VolumeEnvelope
	instanceVariableNames: 'targetVol mSecsForChange'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #VolumeEnvelope category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Envelope subclass: #VolumeEnvelope
	instanceVariableNames: 'targetVol mSecsForChange'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'VolumeEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
VolumeEnvelope class
	instanceVariableNames: ''!

!classDefinition: 'VolumeEnvelope class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
VolumeEnvelope class
	instanceVariableNames: ''!

!classDefinition: #SampledInstrument category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SampledInstrument
	instanceVariableNames: 'sustainedSoft sustainedLoud staccatoSoft staccatoLoud sustainedThreshold loudThreshold'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SampledInstrument category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SampledInstrument
	instanceVariableNames: 'sustainedSoft sustainedLoud staccatoSoft staccatoLoud sustainedThreshold loudThreshold'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SampledInstrument class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SampledInstrument class
	instanceVariableNames: ''!

!classDefinition: 'SampledInstrument class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SampledInstrument class
	instanceVariableNames: ''!

!classDefinition: #SoundCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundCodec
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SoundCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundCodec
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SoundCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec class
	instanceVariableNames: ''!

!classDefinition: 'SoundCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec class
	instanceVariableNames: ''!

!classDefinition: #ADPCMCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #ADPCMCodec
	instanceVariableNames: 'predicted index deltaSignMask deltaValueMask deltaValueHighBit frameSizeMask currentByte bitPosition byteIndex encodedBytes samples rightSamples sampleIndex bitsPerSample stepSizeTable indexTable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #ADPCMCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #ADPCMCodec
	instanceVariableNames: 'predicted index deltaSignMask deltaValueMask deltaValueHighBit frameSizeMask currentByte bitPosition byteIndex encodedBytes samples rightSamples sampleIndex bitsPerSample stepSizeTable indexTable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'ADPCMCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ADPCMCodec class
	instanceVariableNames: ''!

!classDefinition: 'ADPCMCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
ADPCMCodec class
	instanceVariableNames: ''!

!classDefinition: #GSMCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #GSMCodec
	instanceVariableNames: 'encodeState decodeState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #GSMCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #GSMCodec
	instanceVariableNames: 'encodeState decodeState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'GSMCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
GSMCodec class
	instanceVariableNames: ''!

!classDefinition: 'GSMCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
GSMCodec class
	instanceVariableNames: ''!

!classDefinition: #MuLawCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #MuLawCodec
	instanceVariableNames: ''
	classVariableNames: 'DecodingTable'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #MuLawCodec category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundCodec subclass: #MuLawCodec
	instanceVariableNames: ''
	classVariableNames: 'DecodingTable'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'MuLawCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
MuLawCodec class
	instanceVariableNames: ''!

!classDefinition: 'MuLawCodec class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
MuLawCodec class
	instanceVariableNames: ''!

!classDefinition: #SoundPlayer category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundPlayer
	instanceVariableNames: ''
	classVariableNames: 'ActiveSounds Buffer BufferIndex BufferMSecs LastBuffer PlayerProcess PlayerSemaphore ReadyForBuffer ReverbState SamplingRate SoundJustStarted SoundSupported Stereo UseReadySemaphore UseReverb'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SoundPlayer category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundPlayer
	instanceVariableNames: ''
	classVariableNames: 'ActiveSounds Buffer BufferIndex BufferMSecs LastBuffer PlayerProcess PlayerSemaphore ReadyForBuffer ReverbState SamplingRate SoundJustStarted SoundSupported Stereo UseReadySemaphore UseReverb'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SoundPlayer class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundPlayer class
	instanceVariableNames: ''!

!classDefinition: 'SoundPlayer class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundPlayer class
	instanceVariableNames: ''!

!classDefinition: #SoundRecorder category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundRecorder
	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordedSound recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex codec desiredSampleRate'
	classVariableNames: 'CanRecordWhilePlaying RecorderActive'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SoundRecorder category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundRecorder
	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordedSound recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex codec desiredSampleRate'
	classVariableNames: 'CanRecordWhilePlaying RecorderActive'
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SoundRecorder class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundRecorder class
	instanceVariableNames: ''!

!classDefinition: 'SoundRecorder class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundRecorder class
	instanceVariableNames: ''!

!classDefinition: #SoundInputStream category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundRecorder subclass: #SoundInputStream
	instanceVariableNames: 'bufferSize mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: #SoundInputStream category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundRecorder subclass: #SoundInputStream
	instanceVariableNames: 'bufferSize mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Synthesis'!

!classDefinition: 'SoundInputStream class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundInputStream class
	instanceVariableNames: ''!

!classDefinition: 'SoundInputStream class' category: 'Sound-Synthesis' stamp: 'VV 11/10/2022 00:44:20'!
SoundInputStream class
	instanceVariableNames: ''!

!classDefinition: #AbstractScoreEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AbstractScoreEvent
	instanceVariableNames: 'time'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #AbstractScoreEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #AbstractScoreEvent
	instanceVariableNames: 'time'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'AbstractScoreEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent class
	instanceVariableNames: ''!

!classDefinition: 'AbstractScoreEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent class
	instanceVariableNames: ''!

!classDefinition: #ControlChangeEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #ControlChangeEvent
	instanceVariableNames: 'control value channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #ControlChangeEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #ControlChangeEvent
	instanceVariableNames: 'control value channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'ControlChangeEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ControlChangeEvent class
	instanceVariableNames: ''!

!classDefinition: 'ControlChangeEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ControlChangeEvent class
	instanceVariableNames: ''!

!classDefinition: #NoteEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #NoteEvent
	instanceVariableNames: 'duration midiKey velocity channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #NoteEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #NoteEvent
	instanceVariableNames: 'duration midiKey velocity channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'NoteEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
NoteEvent class
	instanceVariableNames: ''!

!classDefinition: 'NoteEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
NoteEvent class
	instanceVariableNames: ''!

!classDefinition: #PitchBendEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #PitchBendEvent
	instanceVariableNames: 'bend channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #PitchBendEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #PitchBendEvent
	instanceVariableNames: 'bend channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'PitchBendEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
PitchBendEvent class
	instanceVariableNames: ''!

!classDefinition: 'PitchBendEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
PitchBendEvent class
	instanceVariableNames: ''!

!classDefinition: #ProgramChangeEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #ProgramChangeEvent
	instanceVariableNames: 'program channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #ProgramChangeEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #ProgramChangeEvent
	instanceVariableNames: 'program channel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'ProgramChangeEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ProgramChangeEvent class
	instanceVariableNames: ''!

!classDefinition: 'ProgramChangeEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
ProgramChangeEvent class
	instanceVariableNames: ''!

!classDefinition: #TempoEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #TempoEvent
	instanceVariableNames: 'tempo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #TempoEvent category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
AbstractScoreEvent subclass: #TempoEvent
	instanceVariableNames: 'tempo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'TempoEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
TempoEvent class
	instanceVariableNames: ''!

!classDefinition: 'TempoEvent class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
TempoEvent class
	instanceVariableNames: ''!

!classDefinition: #MIDIFileReader category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIFileReader
	instanceVariableNames: 'stream fileType trackCount ticksPerQuarter tracks trackInfo tempoMap strings track trackStream activeEvents maxNoteTicks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #MIDIFileReader category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIFileReader
	instanceVariableNames: 'stream fileType trackCount ticksPerQuarter tracks trackInfo tempoMap strings track trackStream activeEvents maxNoteTicks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'MIDIFileReader class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIFileReader class
	instanceVariableNames: ''!

!classDefinition: 'MIDIFileReader class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIFileReader class
	instanceVariableNames: ''!

!classDefinition: #MIDIInputParser category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIInputParser
	instanceVariableNames: 'cmdActionTable midiPort received rawDataBuffer sysExBuffer ignoreSysEx startTime timeNow state lastSelector lastCmdByte argByte1 argByte2'
	classVariableNames: 'DefaultMidiTable'
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #MIDIInputParser category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIInputParser
	instanceVariableNames: 'cmdActionTable midiPort received rawDataBuffer sysExBuffer ignoreSysEx startTime timeNow state lastSelector lastCmdByte argByte1 argByte2'
	classVariableNames: 'DefaultMidiTable'
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'MIDIInputParser class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIInputParser class
	instanceVariableNames: ''!

!classDefinition: 'MIDIInputParser class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIInputParser class
	instanceVariableNames: ''!

!classDefinition: #MIDIScore category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIScore
	instanceVariableNames: 'tracks trackInfo tempoMap ticksPerQuarterNote'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #MIDIScore category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDIScore
	instanceVariableNames: 'tracks trackInfo tempoMap ticksPerQuarterNote'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'MIDIScore class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIScore class
	instanceVariableNames: ''!

!classDefinition: 'MIDIScore class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDIScore class
	instanceVariableNames: ''!

!classDefinition: #MIDISynth category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDISynth
	instanceVariableNames: 'midiParser channels process'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #MIDISynth category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDISynth
	instanceVariableNames: 'midiParser channels process'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'MIDISynth class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDISynth class
	instanceVariableNames: ''!

!classDefinition: 'MIDISynth class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDISynth class
	instanceVariableNames: ''!

!classDefinition: #MIDISynthChannel category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDISynthChannel
	instanceVariableNames: 'instrument muted masterVolume channelVolume pan pitchBend activeSounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #MIDISynthChannel category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #MIDISynthChannel
	instanceVariableNames: 'instrument muted masterVolume channelVolume pan pitchBend activeSounds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'MIDISynthChannel class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDISynthChannel class
	instanceVariableNames: ''!

!classDefinition: 'MIDISynthChannel class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
MIDISynthChannel class
	instanceVariableNames: ''!

!classDefinition: #SimpleMIDIPort category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SimpleMIDIPort
	instanceVariableNames: 'portNumber accessSema lastCommandByteOut'
	classVariableNames: 'DefaultPortNumber InterfaceClockRate'
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: #SimpleMIDIPort category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SimpleMIDIPort
	instanceVariableNames: 'portNumber accessSema lastCommandByteOut'
	classVariableNames: 'DefaultPortNumber InterfaceClockRate'
	poolDictionaries: ''
	category: 'Sound-Scores'!

!classDefinition: 'SimpleMIDIPort class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
SimpleMIDIPort class
	instanceVariableNames: ''!

!classDefinition: 'SimpleMIDIPort class' category: 'Sound-Scores' stamp: 'VV 11/10/2022 00:44:20'!
SimpleMIDIPort class
	instanceVariableNames: ''!

!classDefinition: #Beeper category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #Beeper
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-System-Support'!

!classDefinition: #Beeper category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #Beeper
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Sound-System-Support'!

!classDefinition: 'Beeper class' category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Beeper class
	instanceVariableNames: 'default'!

!classDefinition: 'Beeper class' category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Beeper class
	instanceVariableNames: 'default'!

!classDefinition: #SoundSystem category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundSystem
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Sound-System-Support'!

!classDefinition: #SoundSystem category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
Object subclass: #SoundSystem
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Sound-System-Support'!

!classDefinition: 'SoundSystem class' category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
SoundSystem class
	instanceVariableNames: ''!

!classDefinition: 'SoundSystem class' category: 'Sound-System-Support' stamp: 'VV 11/10/2022 00:44:20'!
SoundSystem class
	instanceVariableNames: ''!
!SoundBuffer commentStamp: '<historical>' prior: 0!
SoundBuffers store 16 bit unsigned quantities.

Array size must be even, as two vales are stored in each word.!
!Sonogram commentStamp: '<historical>' prior: 0!
Sonograms are imageMorphs that will repeatedly plot arrays of values as black on white columns moving to the right in time and scrolling left as necessary.!
!AIFFFileReader commentStamp: '<historical>' prior: 0!
I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.
!
!UnloadedSound commentStamp: '<historical>' prior: 0!
Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!
!LoopedSampledSound commentStamp: '<historical>' prior: 0!
I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.
!
!PluckedSound commentStamp: '<historical>' prior: 0!
The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. Fractional indexing is used to allow precise tuning; without this, the pitch would be rounded to the pitch corresponding to the nearest buffer size.
!
!QueueSound commentStamp: 'efc 1/2/2003 00:30' prior: 0!
I am a queue for sound - give me a bunch of sounds to play and I will play them one at a time in the order that they are received.

Example:
"Here is a simple example which plays two sounds three times."
| clink warble queue |
clink _ SampledSound soundNamed: 'clink'.
warble _ SampledSound soundNamed: 'warble'.
queue _ QueueSound new.
3 timesRepeat:[
	queue add: clink; add: warble
].
queue play.

Structure:
 startTime 		Integer -- if present, start playing when startTime <= Time millisecondClockValue
							(schedule the sound to play later)
 sounds			SharedQueue -- the synchronized list of sounds.
 currentSound	AbstractSound -- the currently active sound
 done			Boolean -- am I done playing ?

Other:
You may want to keep track of the queue's position so that you can feed it at an appropriate rate. To do this in an event driven way, modify or subclass nextSound to notify you when appropriate. You could also poll by checking currentSound, but this is not recommended for most applications.

!
!StreamingMonoSound commentStamp: '<historical>' prior: 0!
I implement a streaming player for monophonic Sun (.au) and AIFF (.aif) audio files.
Example of use:
	(StreamingMonoSound onFileNamed: 'song.aif') play.
!
!ScorePlayer commentStamp: '<historical>' prior: 0!
This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.
!
!CompressedSoundData commentStamp: '<historical>' prior: 0!
Instances of this class hold the data resulting from compressing a sound.  Each carries a reference to the codec class that created it, so that it can reconstruct a sound similar to the original in response to the message asSound.

In order to facilitate integration with existing sounds, a CompressedSoundData instance can masquerade as a sound by caching a copy of its original sound and delegating the essential sound-playing protocol to that cached copy.  It should probably be made a subclass of AbstractSound to complete the illusion.!
!Envelope commentStamp: '<historical>' prior: 0!
An envelope models a three-stage progression for a musical note: attack, sustain, decay. Envelopes can either return the envelope value at a given time or can update some target object using a client-specified message selector.

The points instance variable holds an array of (time, value) points, where the times are in milliseconds. The points array must contain at least two points. The time coordinate of the first point must be zero and the time coordinates of subsequent points must be in ascending order, although the spacing between them is arbitrary. Envelope values between points are computed by linear interpolation.

The scale slot is initially set so that the peak of envelope matches some note attribute, such as its loudness. When entering the decay phase, the scale is adjusted so that the decay begins from the envelope's current value. This avoids a potential sharp transient when entering the decay phase.

The loopStartIndex and loopEndIndex slots contain the indices of points in the points array; if they are equal, then the envelope holds a constant value for the sustain phase of the note. Otherwise, envelope values are computed by repeatedly looping between these two points.

The loopEndMSecs slot can be set in advance (as when playing a score) or dynamically (as when responding to interactive inputs from a MIDI keyboard). In the latter case, the value of scale is adjusted to start the decay phase with the current envelope value. Thus, if a note ends before its attack is complete, the decay phase is started immediately (i.e., the attack phase is never completed).

For best results, amplitude envelopes should start and end with zero values. Otherwise, the sharp transient at the beginning or end of the note may cause audible clicks or static. For envelopes on other parameters, this may not be necessary.
!
!SampledInstrument commentStamp: '<historical>' prior: 0!
I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).
!
!SoundCodec commentStamp: '<historical>' prior: 0!
I am an abstract class that describes the protocol for sound codecs. Each codec (the name stems from "COder/DECoder") describes a particular algorithm for compressing and decompressing sound data. Most sound codecs are called 'lossy' because they lose information; the decompressed sound data is not exactly the same as the original data.
!
!ADPCMCodec commentStamp: '<historical>' prior: 0!
This is a simple ADPCM (adapative delta pulse code modulation) codec. This is a general audio codec that compresses speech, music, or sound effects equally well, and works at any sampling rate (i.e., it contains no frequency-sensitive filters). It compresses 16-bit sample data down to 5, 4, 3, or 2 bits per sample, with lower fidelity and increased noise at the lowest bit rates. Although it does not deliver state-of-the-art compressions, the algorithm is small, simple, and extremely fast, since the encode/decode primitives have been translated into C primitives.

This codec will also encode and decode all Flash .swf file compressed sound formats, both mono and stereo. (Note: stereo Flash compression is not yet implemented, but stereo decompression works.)
!
!MuLawCodec commentStamp: '<historical>' prior: 0!
I represent a mu-law (u-law) codec. I compress sound data by a factor of 2:1 by encoding the most significant 12 bits of each 16-bit sample as a signed, exponentially encoded byte. The idea is to use more resolution for smaller lower sample values. This encoding was developed for the North American phone system and a variant of it, a-law, is a European phone standard. It is a popular sound encoding on Unix platforms (.au files).
!
!SoundInputStream commentStamp: '<historical>' prior: 0!
This subclass of SoundRecorder supports real-time processing of incoming sound data. The sound input process queues raw sound buffers, allowing them to be read and processed by the client as they become available. A semaphore is used to synchronize between the record process and the client process. Since sound data is buffered, the client process may lag behind the input process without losing data.
!
!AbstractScoreEvent commentStamp: '<historical>' prior: 0!
Abstract class for timed events in a MIDI score.
!
!NoteEvent commentStamp: '<historical>' prior: 0!
Represents a note on or off event in a MIDI score.
!
!TempoEvent commentStamp: '<historical>' prior: 0!
Represents a tempo change in a MIDI score.
!
!MIDIFileReader commentStamp: '<historical>' prior: 0!
A reader for Standard 1.0 format MIDI files.
MIDI File Types:
	type 0 -- one multi-channel track
	type 1 -- one or more simultaneous tracks
	type 2 -- a number on independent single-track patterns

Instance variables:
	stream			source of MIDI data
	fileType			MIDI file type
	trackCount		number of tracks in file
	ticksPerQuarter	number of ticks per quarter note for all tracks in this file
	tracks			collects track data for non-empty tracks
	strings			collects all strings in the MIDI file
	tempoMap		nil or a MIDITrack consisting only of tempo change events
	trackStream		stream on buffer containing track chunk
	track			track being read
	activeEvents 	notes that have been turned on but not off
!
!MIDIInputParser commentStamp: '<historical>' prior: 0!
I am a parser for a MIDI data stream. I support:

	real-time MIDI recording,
	overdubbing (recording while playing),
	monitoring incoming MIDI, and
	interactive MIDI performances.

Note: MIDI controllers such as pitch benders and breath controllers generate large volumes of data which consume processor time. In cases where this information is not of interest to the program using it, it is best to filter it out as soon as possible. I support various options for doing this filtering, including filtering by MIDI channel and/or by command type.
!
!MIDIScore commentStamp: '<historical>' prior: 0!
A MIDIScore is a container for a number of MIDI tracks as well as an ambient track for such things as sounds, book page triggers and other related events.!
!MIDISynth commentStamp: '<historical>' prior: 0!
I implement a simple real-time MIDI synthesizer on platforms that support MIDI input. I work best on platforms that allow the sound buffer to be made very short--under 50 milliseconds is good and under 20 milliseconds is preferred (see below). The buffer size is changed by modifying the class initialization method of SoundPlayer and executing the do-it there to re-start the sound player.

Each instance of me takes input from a single MIDI input port. Multiple instances of me can be used to handle multiple MIDI input ports. I distribute incoming commands among my sixteen MIDISynthChannel objects. Most of the interpretation of the MIDI commands is done by these channel objects. 

Buffer size notes: At the moment, most fast PowerPC Macintosh computers can probably work with buffer sizes down to 50 milliseconds, and the Powerbook G3 works down to about 15 milliseconds. You will need to experiment to discover the minimum buffer size that does not result in clicking during sound output. (Hint: Be sure to turn off power cycling on your Powerbook. Other applications and extensions can steal cycles from Squeak, causing intermittent clicking. Experimentation may be necessary to find a configuration that works for you.)
!
!MIDISynthChannel commentStamp: '<historical>' prior: 0!
I implement one polyphonic channel of a 16-channel MIDI synthesizer. Many MIDI commands effect all the notes played on a particular channel, so I record the state for a single channel, including a list of notes currently playing.

This initial implementation is extremely spartan, having just enough functionality to play notes. Things that are not implemented include:

  1. program changes
  2. sustain pedal
  3. aftertouch (either kind)
  4. most controllers
  5. portamento
  6. mono-mode
!
!SimpleMIDIPort commentStamp: '<historical>' prior: 0!
This is a first cut at a simple MIDI output port.
!
!Beeper commentStamp: 'gk 2/26/2004 22:44' prior: 0!
Beeper provides simple audio (or in some other way) feedback to the user.

The recommended use is "Beeper beep" to give the user the equivalence of a beep. If you want to force the beep to use the primitive in the VM for beeping, then use "Beeper beepPrimitive". In either case, if sounds are disabled there will be no beep.

The actual beeping, when you use "Beeper beep", is done by sending a #play message to a registered playable object. You can register your own playable object by invoking the class side method #setDefault: passing in an object that responds to the #play message.

The default playable object is an instance of Beeper itself which implements #play on the instance side. That implementation delegates the playing of the beep to the default SoundService.

Note that #play is introduced as a common interface between AbstractSound and Beeper.
This way we can register instances of AbstractSound as playable entities, for example:

	Beeper setDefault: (SampledSound new
						setSamples: self coffeeCupClink
						samplingRate: 12000).

Then "Beeper beep" will play the coffeeCup sound.!
!SoundSystem commentStamp: '<historical>' prior: 0!
This is the sound system. A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in the application registry SoundService and can be accessed by "SoundService default" like for example:

SoundService default playSoundNamed: 'croak'

The idea is that as much sound playing as possible should go through this facade. This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.

Two basic subclasses exist at the time of this writing, the BaseSoundSystem which represents the standard Squeak sound system, and the DummySoundSystem which is a dummy implementation that can be used when there is no sound card available, or when the base sound system isn't in the image, or when you simply don't want to use the available sound card.!
!SoundBuffer class methodsFor: 'class initialization' stamp: 'jmv 2/25/2016 10:33' overrides: 16787245!
startUp
	"Check if the word order has changed from the last save."

	| la |
	la _ ShortIntegerArray classPool at: #LastSaveOrder.
	((la at: 2) = 42 and: [(la at: 1) = 13]) 
		ifTrue: [
			self allInstancesDo: [ :each | 
				BitBlt swapHalvesIn32BitWords: each ]]
			"Reverse the two 16-bit halves."
			"Another reversal happened automatically which reversed the bytes."! !
!AbstractSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:55' overrides: 50418974!
postCopy
	"A sound should copy all of the state needed to play itself, allowing two copies of a sound to play at the same time. These semantics require a recursive copy but only down to the level of immutable data. For example, a SampledSound need not copy its sample buffer. Subclasses overriding this method should include a resend to super."

	self copyEnvelopes! !
!FMSound methodsFor: 'storing' stamp: 'jmv 3/13/2012 12:34' overrides: 16903050!
storeOn: strm
	| env |
	strm nextPutAll: '(((FMSound';
		nextPutAll: ' pitch: '; print: self pitch;
		nextPutAll: ' dur: '; print: self duration;
		nextPutAll: ' loudness: '; print: self loudness; nextPutAll: ')';
		nextPutAll: ' modulation: '; print: self modulation;
		nextPutAll: ' ratio: '; print: self ratio; nextPutAll: ')'.
	1 to: envelopes size do:
		[:i | env _ envelopes at: i.
		strm newLine; nextPutAll: '    addEnvelope: '. env storeOn: strm.
		i < envelopes size ifTrue: [strm nextPutAll: ';']].
	strm  nextPutAll: ')'.
! !
!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 9/25/2000 12:06' overrides: 16902757!
objectForDataStream: refStrm
    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."

	refStrm replace: leftSamples with: leftSamples asByteArray.
	refStrm replace: rightSamples with: rightSamples asByteArray.
	"substitution will be made in DataStream nextPut:"
	^ self
! !
!MixedSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:57' overrides: 50601962!
postCopy
	"Copy my component sounds."

	super postCopy.
	self copySounds! !
!PluckedSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:56' overrides: 50601962!
postCopy

	super postCopy.
	self copyRing
! !
!RepeatingSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:58' overrides: 50601962!
postCopy
	"Copy my component sound."

	super postCopy.
	self copySound
! !
!ReverbSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:58' overrides: 50601962!
postCopy
	"Copy my component sound."

	super postCopy.
	self copySound
! !
!SequentialSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:58' overrides: 50601962!
postCopy
	"Copy my component sounds."

	super postCopy.
	self copySounds
! !
!ScorePlayer methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:58' overrides: 50601962!
postCopy
	"Copy my component sounds."

	super postCopy.
	self copySounds
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03' overrides: 16903442!
name

	^ self updateSelector allButLast
! !
!Envelope methodsFor: 'storing' stamp: 'di 2/1/98 15:45' overrides: 16903050!
storeOn: strm
	strm nextPutAll: '((' , self class name;
		nextPutAll: ' points: '; store: (points collect: [:p | p x @ (p y roundTo: 0.00001)]);
		nextPutAll: ' loopStart: '; print: loopStartIndex;
		nextPutAll: ' loopEnd: '; print: loopEndIndex; nextPutAll: ')';
		nextPutAll: ' updateSelector: '; store: self updateSelector; nextPutAll: ';';
		nextPutAll: ' scale: '; print: scale; nextPutAll: ')'.
! !
!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 1/14/1999 13:17' overrides: 50602044!
name

	^ 'random ', updateSelector
! !
!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 5/8/1998 18:48' overrides: 16787231!
shutDown
	"Stop player process, for example before snapshotting."

	self stopPlayerProcess.
	ReverbState _ nil.
! !
!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 7/11/97 12:17' overrides: 16787245!
startUp
	"Start up the player process."

	SoundPlayer initialize.
	SoundPlayer
		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000
		rate: SamplingRate
		stereo: Stereo.
! !
!ControlChangeEvent methodsFor: 'printing' stamp: 'sma 6/1/2000 09:34' overrides: 16902975!
printOn: aStream
	aStream
		nextPut: $(;
		print: time;
		nextPutAll: ': ctrl[';
		print: control;
		nextPutAll: ']=';
		print: value;
		nextPut: $)! !
!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:59' overrides: 16902975!
printOn: aStream

	aStream nextPut: $(.
	time printOn: aStream.
	aStream nextPutAll: ': '.
	aStream nextPutAll: self keyName.
	aStream space.
	duration printOn: aStream.
	aStream nextPut: $).
! !
!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42' overrides: 16902975!
printOn: aStream

	aStream nextPut: $(.
	time printOn: aStream.
	aStream nextPutAll: ': bend '.
	bend printOn: aStream.
	aStream nextPut: $).
! !
!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28' overrides: 16902975!
printOn: aStream

	aStream nextPut: $(.
	time printOn: aStream.
	aStream nextPutAll: ': prog '.
	program printOn: aStream.
	aStream nextPut: $).
! !
!TempoEvent methodsFor: 'as yet unclassified' stamp: 'jm 9/10/1998 08:37' overrides: 16902975!
printOn: aStream

	aStream nextPut: $(.
	time printOn: aStream.
	aStream nextPutAll: ': tempo '.
	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.
	aStream nextPut: $).
! !
!SoundSystem class methodsFor: 'as yet unclassified' stamp: 'jmv 6/7/2013 22:05' overrides: 16787231!
shutDown
	SoundPlayer shutDown! !
!SoundSystem methodsFor: 'misc' stamp: 'jmv 6/7/2013 21:58'!
shutDown
	SoundPlayer shutDown
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03' overrides: 16934062!
asByteArray
	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."

	| sampleCount bytes dst s |
	sampleCount _ self monoSampleCount.
	bytes _ ByteArray new: 2 * sampleCount.
	dst _ 0.
	1 to: sampleCount do: [:src |
		s _ self at: src.
		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).
		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].
	^ bytes

	! !
!SoundBuffer methodsFor: 'utilities' stamp: 'RAA 12/30/2000 18:26'!
averageEvery: nSamples from: anotherBuffer upTo: inCount

	| fromIndex sum |

	fromIndex _ 1.
	1 to: inCount // nSamples do: [ :i |
		sum _ 0.
		nSamples timesRepeat: [
			sum _ sum + (anotherBuffer at: fromIndex).
			fromIndex _ fromIndex + 1.
		].
		self at: i put: sum // nSamples.
	].
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!
downSampledLowPassFiltering: doFiltering
	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."
	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."

	| n resultBuf j |
	n _ self monoSampleCount.
	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.
	j _ 0.
	doFiltering
		ifTrue: [
			1 to: n by: 2 do: [:i |
				resultBuf at: (j _ j + 1) put:
					(((self at: i) + (self at: i + 1)) bitShift: -1)]]
		ifFalse: [
			1 to: n by: 2 do: [:i |
				resultBuf at: (j _ j + 1) put: (self at: i)]].

	^ resultBuf! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!
extractLeftChannel
	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."

	| n resultBuf j |
	n _ self monoSampleCount.
	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.
	j _ 0.
	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].
	^ resultBuf! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!
extractRightChannel
	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."

	| n resultBuf j |
	n _ self monoSampleCount.
	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.
	j _ 0.
	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].
	^ resultBuf! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!
indexOfFirstSampleOver: threshold
	"Return the index of the first sample whose absolute value is over the given threshold value. Return an index one greater than my size if no sample is over the threshold."

	1 to: self size do: [:i |
		(self at: i) abs > threshold ifTrue: [^ i]].
	^ self size + 1! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!
indexOfLastSampleOver: threshold
	"Return the index of the last sample whose absolute value is over the given threshold value. Return zero if no sample is over the threshold."

	self size to: 1 by: -1 do: [:i |
		(self at: i) abs > threshold ifTrue: [^ i]].
	^ 0
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jmv 5/14/2015 09:54'!
lowPassFiltered
	"Answer a simple low-pass filtered copy of this buffer. Assume it is monophonic."

	| sz out last this |
	sz _ self monoSampleCount.
	out _ self copy.
	last _ self at: 1.
	2 to: sz do: [:i |
		this _ self at: i.
		out at: i put: (this + last) // 2.
		last _ this].
	^ out
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 11/15/2001 18:26'!
mergeStereo
	"Answer a new SoundBuffer half the size of the receiver that mixes the left and right stereo channels of the receiver, which is assumed to contain stereo sound data."

	| n resultBuf j |
	n _ self monoSampleCount.
	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.
	j _ 0.
	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (((self at: i) + (self at: i + 1)) // 2)].
	^ resultBuf
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!
normalized: percentOfFullVolume
	"Increase my amplitudes so that the highest peak is the given percent of full volume. For example 's normalized: 50' would normalize to half of full volume."

	| peak s mult |
	peak _ 0.
	1 to: self size do: [:i |
		s _ (self at: i) abs.
		s > peak ifTrue: [peak _ s]].
	mult _ (32767.0 * percentOfFullVolume) / (100.0 * peak).
	1 to: self size do: [:i | self at: i put: (mult * (self at: i)) asInteger].
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jmv 2/26/2016 17:09'!
saveAsAIFFFileSamplingRate: rate on: aBinaryStream
	"Store this mono sound buffer in AIFF file format with the given sampling rate on the given stream."

	| sampleCount s swapBytes |
	sampleCount _ self monoSampleCount.
	aBinaryStream nextPutAll: 'FORM' asByteArray.
	aBinaryStream nextSignedInt32Put: (2 * sampleCount) + ((7 * 4) + 18) bigEndian: true.
	aBinaryStream nextPutAll: 'AIFF' asByteArray.
	aBinaryStream nextPutAll: 'COMM' asByteArray.
	aBinaryStream nextSignedInt32Put: 18 bigEndian: true.
	aBinaryStream nextUnsignedInt16Put: 1 bigEndian: true.  "channels"
	aBinaryStream nextSignedInt32Put: sampleCount bigEndian: true.
	aBinaryStream nextUnsignedInt16Put: 16 bigEndian: true.  "bits/sample"
	self storeExtendedFloat: rate on: aBinaryStream.
	aBinaryStream nextPutAll: 'SSND' asByteArray.
	aBinaryStream nextSignedInt32Put: (2 * sampleCount) + 8 bigEndian: true.
	aBinaryStream nextSignedInt32Put: 0 bigEndian: true.
	aBinaryStream nextSignedInt32Put: 0 bigEndian: true.

	(aBinaryStream isKindOf: StandardFileStream) ifTrue: [
		"optimization: write sound buffer directly to file"
		swapBytes _ Smalltalk isLittleEndian.
		swapBytes ifTrue: [self reverseEndianness].  "make big endian"
		aBinaryStream next: (self size // 2) putAll: self startingAt: 1.  "size in words"
		swapBytes ifTrue: [self reverseEndianness].  "revert to little endian"
		^ self].

	1 to: sampleCount do: [:i |
		s _ self at: i.
		aBinaryStream nextPut: ((s bitShift: -8) bitAnd: 16rFF).
		aBinaryStream nextPut: (s bitAnd: 16rFF)].
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jm 3/28/1999 07:23'!
splitStereo
	"Answer an array of two SoundBuffers half the size of the receiver consisting of the left and right channels of the receiver (which is assumed to contain stereo sound data)."

	| n leftBuf rightBuf leftIndex rightIndex |
	n _ self monoSampleCount.
	leftBuf _ SoundBuffer newMonoSampleCount: n // 2.
	rightBuf _ SoundBuffer newMonoSampleCount: n // 2.
	leftIndex _ rightIndex _ 0.
	1 to: n by: 2 do: [:i |
		leftBuf at: (leftIndex _ leftIndex + 1) put: (self at: i).
		rightBuf at: (rightIndex _ rightIndex + 1) put: (self at: i + 1)].
	^ Array with: leftBuf with: rightBuf
! !
!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!
trimmedThreshold: threshold

	| start end |
	start _ self indexOfFirstSampleOver: threshold.
	end _  self indexOfLastSampleOver: threshold.
	start > end ifTrue: [^ SoundBuffer new].
	start _ (start - 200) max: 1.
	end _ (end + 200) min: self size.
	^ self copyFrom: start to: end
! !
!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03' overrides: 16901507!
at: index
	"Return the 16-bit integer value at the given index of the receiver."

	<primitive: 143>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber ifTrue: [^ self at: index truncated].
	self errorNonIntegerIndex.
! !
!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03' overrides: 16901525!
at: index put: value
	"Store the given 16-bit integer at the given index in the receiver."

	<primitive: 144>
	index isInteger
		ifTrue: [
			(index >= 1 and: [index <= self size])
				ifTrue: [self errorImproperStore]
				ifFalse: [self errorSubscriptBounds: index]].
	index isNumber ifTrue: [^ self at: index truncated put: value].
	self errorNonIntegerIndex.
! !
!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/2/97 16:07'!
primFill: aPositiveInteger
	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."
	"Note: Since 16-bit word arrays are not built into the virtual machine, this primitive fills by 32-bit words."

	<primitive: 145>
	self errorImproperStore.
! !
!SoundBuffer methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46' overrides: 16781647!
bytesPerElement
	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."
	^ 2! !
!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:00'!
monoSampleCount
	"Return the number of monaural 16-bit samples that fit into this SoundBuffer."

	^ super size * 2
! !
!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:28' overrides: 16781372!
size
	"Return the number of 16-bit sound samples that fit in this sound buffer. To avoid confusion, it is better to get the size of SoundBuffer using monoSampleCount or stereoSampleCount."

	^ self monoSampleCount
! !
!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:01'!
stereoSampleCount
	"Return the number of stereo slices that fit into this SoundBuffer. A stereo 'slice' consists of two 16-bit samples, one for each channel."

	^ super size
! !
!SoundBuffer methodsFor: 'objects from disk' stamp: 'jmv 2/15/2008 00:49' overrides: 16781652!
restoreEndianness
	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.
	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."

	| hack blt |
	Smalltalk isLittleEndian ifTrue: [
		"The implementation is a hack, but fast for large ranges"
		hack _ Form new hackBits: self.
		blt _ (BitBlt toForm: hack) sourceForm: hack.
		blt combinationRule: Form reverse.  "XOR"
		blt sourceY: 0; destY: 0; height: self size; width: 1.
		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"
		blt sourceX: 1; destX: 0; copyBits.
		blt sourceX: 0; destX: 1; copyBits.
		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"
		blt sourceX: 3; destX: 2; copyBits.
		blt sourceX: 2; destX: 3; copyBits].

! !
!SoundBuffer methodsFor: 'objects from disk' stamp: 'jm 10/29/2001 19:53'!
reverseEndianness
	"Swap the bytes of each 16-bit word, using a fast BitBlt hack."

	| hack blt |
	hack _ Form new hackBits: self.
	blt _ (BitBlt toForm: hack) sourceForm: hack.
	blt combinationRule: Form reverse.  "XOR"
	blt sourceY: 0; destY: 0; height: self size; width: 1.
	blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"
	blt sourceX: 1; destX: 0; copyBits.
	blt sourceX: 0; destX: 1; copyBits.
	blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"
	blt sourceX: 3; destX: 2; copyBits.
	blt sourceX: 2; destX: 3; copyBits.
! !
!SoundBuffer methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:31' overrides: 50599985!
writeOnGZIPByteStream: aStream 
	
	aStream nextPutAllWordArray: self! !
!SoundBuffer class methodsFor: 'class initialization' stamp: 'jmv 12/15/2014 21:51' overrides: 16904184!
initialize
	"SoundBuffer initialize"
	Smalltalk addToStartUpList: self! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'RAA 12/30/2000 18:20'!
averageEvery: nSamples from: anotherBuffer upTo: inCount

	^(self newMonoSampleCount: inCount // nSamples)
		averageEvery: nSamples 
		from: anotherBuffer 
		upTo: inCount! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:39'!
fromArray: anArray
	"Return a new SoundBuffer whose contents are copied from the given Array or ByteArray."

	| new |
	new _ SoundBuffer newMonoSampleCount: anArray size.
	1 to: anArray size do: [:i | new at: i put: (anArray at: i)].
	^ new
! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 8/15/1998 14:35'!
fromByteArray: aByteArray
	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."

	| n buf src w |
	n _ aByteArray size // 2.
	buf _ SoundBuffer newMonoSampleCount: n.
	src _ 1.
	1 to: n do: [:i |
		w _ ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).
		w > 32767 ifTrue: [w _ w - 65536].
		buf at: i put: w.
		src _ src + 2].
	^ buf
! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 13:25' overrides: 16785654!
new: anInteger
	"See the comment in newMonoSampleCount:. To avoid confusion, it is best to create new instances using newMonoSampleCount: or newStereoSampleCount:."

	^ self newMonoSampleCount: anInteger
! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:44'!
newMonoSampleCount: anInteger
	"Return a SoundBuffer large enough to hold the given number of monaural samples (i.e., 16-bit words)."
	"Details: The size is rounded up to an even number, since the underlying representation is in terms of 32-bit words."

	^ self basicNew: (anInteger + 1) // 2
! !
!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:52'!
newStereoSampleCount: anInteger
	"Return a SoundBuffer large enough to hold the given number of stereo slices. A stereo 'slice' consists of two 16-bit samples, one for each channel."

	^ self basicNew: anInteger
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/16/2011 10:26'!
extent: aPoint minVal: min maxVal: max scrollDelta: d
	minVal _ min.
	maxVal _ max.
	scrollDelta _ d.
	self morphExtent: aPoint.

" try following with scrolldelta = 1, 20, 200
	| s data |
	s _ Sonogram new extent: 200@50
				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.
	World addMorph: s.
	data _ (1 to: 133) collect: [:i | 0.0].
	1 to: 300 do:
		[:i | data at: (i\\133)+1 put: 1.0.
		s plotColumn: data.
		data at: (i\\133)+1 put: 0.0.
		World doOneCycleNow].
	s delete	
"! !
!Sonogram methodsFor: 'all' stamp: 'jmv 1/21/2015 23:56'!
plotColumn: dataArray

	| chm1 i normVal r |
	chm1 _ columnForm height - 1.
	0 to: chm1 do: [ :y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidateLocalRect: r! !
!Sonogram methodsFor: 'all' stamp: 'jmv 3/14/2011 09:26'!
scroll
	image copy: (scrollDelta@0 extent: (image width-scrollDelta)@image height)
			from: image to: 0@0 rule: Form over.
	lastX _ lastX - scrollDelta.
	self redrawNeeded! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:22' overrides: 16794280!
morphExtent: newExtent
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[:i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!
bitsPerSample

	^ bitsPerSample
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!
channelCount

	^ channelCount
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!
channelData

	^ channelData
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 10/20/2001 15:07'!
channelDataOffset

	^ channelDataOffset
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!
frameCount

	^ frameCount
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!
gain

	^ gain
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!
isLooped

	^ isLooped
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!
isStereo

	^ channelData size = 2
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!
leftSamples

	^ channelData at: 1
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!
loopEnd

	^ markers last last
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!
loopLength

	^ markers last last - markers first last
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!
markers

	^ markers
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!
pitch

	^ pitch
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!
rightSamples

	^ channelData at: 2
! !
!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!
samplingRate

	^ samplingRate
! !
!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!
pitchForKey: midiKey
	"Convert my MIDI key number to a pitch and return it."

	| indexInOctave octave p |
	indexInOctave _ (midiKey \\ 12) + 1.
	octave _ (midiKey // 12) + 1.
	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"
	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677
		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.
	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)
! !
!AIFFFileReader methodsFor: 'other' stamp: 'jm 1/14/1999 10:11'!
sound
	"Answer the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."

	| snd rightSnd |
	snd _ SampledSound
		samples: (channelData at: 1)
		samplingRate: samplingRate.
	self isStereo ifTrue: [
		rightSnd _ SampledSound
			samples: (channelData at: 2)
			samplingRate: samplingRate.
		snd _ MixedSound new
			add: snd pan: 0;
			add: rightSnd pan: 1.0].
	^ snd
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!
readChunk: chunkType size: chunkSize
	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."

	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].
	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].
	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].
	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].
	in skip: chunkSize.  "skip unknown chunks"
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 2/26/2016 16:59'!
readCommonChunk: chunkSize
	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."

	| compressionType |
	channelCount _ in nextUnsignedInt16BigEndian: true.
	frameCount _ in nextUnsignedInt32BigEndian: true.
	bitsPerSample _ in nextUnsignedInt16BigEndian: true.
	samplingRate _ self readExtendedFloat.
	chunkSize > 18 ifTrue: [
		fileType = 'AIFF'
			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].
		compressionType _ (in next: 4) asString.
		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].
		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 4/11/2019 14:01:46'!
readExtendedFloat
	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."
	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."

	| signAndExp mantissa sign exp |
	signAndExp _ in nextUnsignedInt16BigEndian: true.
	"scaled by (2 raisedTo: -64) below"
	mantissa _ (in nextUnsignedInt32BigEndian: true) << 32 + (in nextUnsignedInt32BigEndian: true).
	(signAndExp bitAnd: 16r8000) = 0
		ifTrue: [sign _ 1.0]
		ifFalse: [sign _ -1.0].
	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."
	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 2/26/2016 17:00'!
readFrom: aBinaryStream
	"Read AIFF data from the given binary stream."
	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."

	| sz end chunkType chunkSize p |
	in _ aBinaryStream.

	"read FORM chunk"
	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].
	sz _ in nextUnsignedInt32BigEndian: true.
	end _ in position + sz.
	fileType _ (in next: 4) asString.

	[in atEnd not and: [in position < end]] whileTrue: [
		chunkType _ (in next: 4) asString.
		chunkSize _ in nextUnsignedInt32BigEndian: true.
		p _ in position.
		self readChunk: chunkType size: chunkSize.
		(in position = (p + chunkSize))
			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].
		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 2/26/2016 16:57'!
readInstrumentChunk: chunkSize

	| midiKey detune lowNote highNote lowVelocity highVelocity
	  sustainMode sustainStartID sustainEndID
	  releaseMode releaseStartID releaseEndID |

	midiKey _ in next.
	detune _ in next.
	lowNote _ in next.
	highNote _ in next.
	lowVelocity _ in next.
	highVelocity _ in next.
	gain _ in nextUnsignedInt16BigEndian: true.
	sustainMode _ in nextUnsignedInt16BigEndian: true.
	sustainStartID _ in nextUnsignedInt16BigEndian: true.
	sustainEndID _ in nextUnsignedInt16BigEndian: true.
	releaseMode _ in nextUnsignedInt16BigEndian: true.
	releaseStartID _ in nextUnsignedInt16BigEndian: true.
	releaseEndID _ in nextUnsignedInt16BigEndian: true.
	isLooped _ sustainMode = 1.
	(isLooped and: [markers notNil]) ifTrue: [
		((markers first last > frameCount) or:
		 [markers last last > frameCount]) ifTrue: [
			"bad loop data; some sample CD files claim to be looped but aren't"
			isLooped _ false]].
	pitch _ self pitchForKey: midiKey.
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 2/26/2016 17:00'!
readMarkerChunk: chunkSize

	| markerCount id position labelBytes label |
	markerCount _ in nextUnsignedInt16BigEndian: true.
	markers _ Array new: markerCount.
	1 to: markerCount do: [:i |
		id _ in nextUnsignedInt16BigEndian: true.
		position _ in nextUnsignedInt32BigEndian: true.
		labelBytes _ in next.
		label _ (in next: labelBytes) asString.
		labelBytes even ifTrue: [in skip: 1].
		markers at: i put: (Array with: id with: label with: position)].

! !
!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:58'!
readMergedStereoChannelDataFrom: s
	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."

	| buf w1 w2 |
	buf _ channelData at: 1.
	bitsPerSample = 8
		ifTrue: [
			1 to: frameCount do: [:i |
				w1 _ s next.
				w1 > 127 ifTrue: [w1 _ w1 - 256].
				w2 _ s next.
				w2 > 127 ifTrue: [w2 _ w2 - 256].
				buf at: i put: ((w1 + w2) bitShift: 7)]]
		ifFalse: [
			1 to: frameCount do: [:i |
				w1 _ (s next bitShift: 8) + s next.
				w1 > 32767 ifTrue: [w1 _ w1 - 65536].
				w2 _ (s next bitShift: 8) + s next.
				w2 > 32767 ifTrue: [w2 _ w2 - 65536].
				buf at: i put: ((w1 + w2) bitShift: -1)]].
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:53'!
readMonoChannelDataFrom: s
	"Read monophonic channel data from the given stream. Each frame contains a single sample."

	| buf w |
	buf _ channelData at: 1.  "the only buffer"
	bitsPerSample = 8
		ifTrue: [
			1 to: frameCount do: [:i |
				w _ s next.
				w > 127 ifTrue: [w _ w - 256].
				buf at: i put: (w bitShift: 8)]]
		ifFalse: [
			1 to: frameCount do: [:i |
				w _ (s next bitShift: 8) + s next.
				w > 32767 ifTrue: [w _ w - 65536].
				buf at: i put: w]].
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:55'!
readMultiChannelDataFrom: s
	"Read multi-channel data from the given stream. Each frame contains channelCount samples."

	| w |
	bitsPerSample = 8
		ifTrue: [
			1 to: frameCount do: [:i |
				1 to: channelCount do: [:ch |
					w _ s next.
					w > 127 ifTrue: [w _ w - 256].
					(channelData at: ch) at: i put: (w bitShift: 8)]]]
		ifFalse: [
			1 to: frameCount do: [:i |
				1 to: channelCount do: [:ch |
					w _ (s next bitShift: 8) + s next.
					w > 32767 ifTrue: [w _ w - 65536].
					(channelData at: ch) at: i put: w]]].
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jmv 2/26/2016 17:00'!
readSamplesChunk: chunkSize
	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."

	| offset blockSize bytesOfSamples s |
	offset _ in nextUnsignedInt32BigEndian: true.
	blockSize _ in nextUnsignedInt32BigEndian: true.
	((offset ~= 0) or: [blockSize ~= 0])
		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].
	bytesOfSamples _ chunkSize - 8.
	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))
		ifFalse: [self error: 'actual sample count does not match COMM chunk'].

	channelDataOffset _ in position.  "record stream position for start of data"
	skipDataChunk ifTrue: [in skip: (chunkSize - 8). ^ self].  "if skipDataChunk, skip sample data"

	(mergeIfStereo and: [channelCount = 2])
		ifTrue: [
			channelData _ Array with: (SoundBuffer newMonoSampleCount: frameCount)]
		ifFalse: [
			channelData _
				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].

	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))
		ifTrue: [s _ ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"
		ifFalse: [s _ in].  "not enough space to buffer; read directly from file"

	"mono and stereo are special-cased for better performance"
	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].
	channelCount = 2 ifTrue: [
		mergeIfStereo
			ifTrue: [channelCount _ 1. ^ self readMergedStereoChannelDataFrom: s]
			ifFalse: [^ self readStereoChannelDataFrom: s]].
	self readMultiChannelDataFrom: s.
! !
!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:56'!
readStereoChannelDataFrom: s
	"Read stereophonic channel data from the given stream. Each frame contains two samples."

	| left right w |
	left _ channelData at: 1.
	right _ channelData at: 2.
	bitsPerSample = 8
		ifTrue: [
			1 to: frameCount do: [:i |
				w _ s next.
				w > 127 ifTrue: [w _ w - 256].
				left at: i put: (w bitShift: 8).
				w _ s next.
				w > 127 ifTrue: [w _ w - 256].
				right at: i put: (w bitShift: 8)]]
		ifFalse: [
			1 to: frameCount do: [:i |
				w _ (s next bitShift: 8) + s next.
				w > 32767 ifTrue: [w _ w - 65536].
				left at: i put: w.
				w _ (s next bitShift: 8) + s next.
				w > 32767 ifTrue: [w _ w - 65536].
				right at: i put: w]].
! !
!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!
readFromFile: fileName
	"Read the AIFF file of the given name."
	"AIFFFileReader new readFromFile: 'test.aiff'"

	self readFromFile: fileName
		mergeIfStereo: false
		skipDataChunk: false.
! !
!AIFFFileReader methodsFor: 'reading' stamp: 'pb 5/25/2016 01:30'!
readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag
	"Read the AIFF file of the given name. See comment in readFromStream:mergeIfStereo:skipDataChunk:."
	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"

	fileName asFileEntry readStreamDo: [ :strm |
		strm binary.
		self readFromStream: strm mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag ]! !
!AIFFFileReader methodsFor: 'reading'!
readFromStream: aBinaryStream mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag
	"Read an AIFF file from the given binary stream. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."

	mergeIfStereo _ mergeFlag.
	skipDataChunk _ skipDataFlag.
	isLooped _ false.
	gain _ 1.0.
	self readFrom: aBinaryStream.
! !
!AbstractSound methodsFor: 'copying' stamp: 'jm 12/17/97 22:22'!
copyEnvelopes
	"Private!! Support for copying. Copy my envelopes."

	envelopes _ envelopes collect: [:e | e copy target: self].
! !
!AbstractSound methodsFor: 'copying' stamp: 'di 3/4/1999 21:29'!
sounds
	"Allows simple sounds to behave as, eg, sequential sounds"

	^ Array with: self! !
!AbstractSound methodsFor: 'composition'!
+ aSound
	"Return the mix of the receiver and the argument sound."

	^ MixedSound new
		add: self;
		add: aSound
! !
!AbstractSound methodsFor: 'composition'!
, aSound
	"Return the concatenation of the receiver and the argument sound."

	^ SequentialSound new
		add: self;
		add: aSound
! !
!AbstractSound methodsFor: 'composition' stamp: 'jm 2/2/1999 15:53'!
asSound

	^ self
! !
!AbstractSound methodsFor: 'composition' stamp: 'jm 12/17/97 18:00'!
delayedBy: seconds
	"Return a composite sound consisting of a rest for the given amount of time followed by the receiver."

	^ (RestSound dur: seconds), self
! !
!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/17/97 22:23'!
addEnvelope: anEnvelope
	"Add the given envelope to my envelopes list."

	anEnvelope target: self.
	envelopes _ envelopes copyWith: anEnvelope.
! !
!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/15/97 17:02'!
envelopes
	"Return my collection of envelopes."

	^ envelopes
! !
!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!
removeAllEnvelopes
	"Remove all envelopes from my envelopes list."

	envelopes _ #().
! !
!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/15/97 17:02'!
removeEnvelope: anEnvelope
	"Remove the given envelope from my envelopes list."

	envelopes _ envelopes copyWithout: anEnvelope.
! !
!AbstractSound methodsFor: 'volume' stamp: 'RAA 8/11/2000 11:51'!
adjustVolumeTo: vol overMSecs: mSecs
	"Adjust the volume of this sound to the given volume, a number in the range [0.0..1.0], over the given number of milliseconds. The volume will be changed a little bit on each sample until the desired volume is reached."

	| newScaledVol |

	self flag: #bob.		"I removed the upper limit to allow making sounds louder. hmm..."

	newScaledVol _ (32768.0 * vol) truncated.
	newScaledVol = scaledVol ifTrue: [^ self].
	scaledVolLimit _ newScaledVol.
	"scaledVolLimit > ScaleFactor ifTrue: [scaledVolLimit _ ScaleFactor]."
	scaledVolLimit < 0 ifTrue: [scaledVolLimit _ 0].
	mSecs = 0
		ifTrue: [  "change immediately"
			scaledVol _ scaledVolLimit.
			scaledVolIncr _ 0]
		ifFalse: [
			scaledVolIncr _
				((scaledVolLimit - scaledVol) * 1000) // (self samplingRate * mSecs)].
! !
!AbstractSound methodsFor: 'volume' stamp: 'jm 12/17/97 17:39'!
initialVolume: vol
	"Set the initial volume of this sound to the given volume, a number in the range [0.0..1.0]."

	scaledVol _ (((vol asFloat min: 1.0) max: 0.0) * ScaleFactor) rounded.
	scaledVolLimit _ scaledVol.
	scaledVolIncr _ 0.
! !
!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!
loudness
	"Answer the current volume setting for this sound."

	^ scaledVol asFloat / ScaleFactor asFloat! !
!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!
volumeEnvelopeScaledTo: scalePoint
	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."

	self error: 'not yet implemented'.
! !
!AbstractSound methodsFor: 'conversion' stamp: 'jm 12/16/2001 13:26'!
asSampledSound
	"Answer a SampledSound containing my samples. If the receiver is some kind of sampled sound, the resulting SampledSound will have the same original sampling rate as the receiver."

	^ SampledSound samples: self samples samplingRate: self originalSamplingRate
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 1/26/98 22:05'!
computeSamplesForSeconds: seconds
	"Compute the samples of this sound without outputting them, and return the resulting buffer of samples."

	| buf |
	self reset.
	buf _ SoundBuffer newStereoSampleCount: (self samplingRate * seconds) asInteger.
	self playSampleCount: buf stereoSampleCount into: buf startingAt: 1.
	^ buf
! !
!AbstractSound methodsFor: 'playing' stamp: 'ar 12/5/1998 22:20'!
isPlaying
	"Return true if the receiver is currently playing"
	^ SoundPlayer isPlaying: self! !
!AbstractSound methodsFor: 'playing' stamp: 'di 5/30/1999 12:46'!
millisecondsSinceStart

	^ mSecsSinceStart! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 8/24/97 20:48'!
pause
	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."

	SoundPlayer pauseSound: self.! !
!AbstractSound methodsFor: 'playing' stamp: 'gk 2/24/2004 22:23'!
play
	"Play this sound to the sound output port in real time."

	SoundPlayer playSound: self.! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!
playAndWaitUntilDone
	"Play this sound to the sound ouput port and wait until it has finished playing before returning."

	SoundPlayer playSound: self.
	[self samplesRemaining > 0] whileTrue.
	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!
playChromaticRunFrom: startPitch to: endPitch
	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."

	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!
playSampleCount: n into: aSoundBuffer startingAt: startIndex
	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."

	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |
	fullVol _ AbstractSound scaleFactor.
	samplesBetweenControlUpdates _ self samplingRate // self controlRate.
	pastEnd _ startIndex + n.  "index just after the last sample"
	i _ startIndex.
	[i < pastEnd] whileTrue: [
		remainingSamples _ self samplesRemaining.
		remainingSamples <= 0 ifTrue: [^ self].
		count _ pastEnd - i.
		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].
		remainingSamples < count ifTrue: [count _ remainingSamples].
		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.
		samplesUntilNextControl _ samplesUntilNextControl - count.
		samplesUntilNextControl <= 0 ifTrue: [
			self doControl.
			samplesUntilNextControl _ samplesBetweenControlUpdates].
		i _ i + count].
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!
playSilently
	"Compute the samples of this sound without outputting them. Used for performance analysis."

	| bufSize buf |
	self reset.
	bufSize _ self samplingRate // 10.
	buf _ SoundBuffer newStereoSampleCount: bufSize.
	[self samplesRemaining > 0] whileTrue: [
		buf primFill: 0.
		self playSampleCount: bufSize into: buf startingAt: 1].
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 1/26/98 22:06'!
playSilentlyUntil: startTime
	"Compute the samples of this sound without outputting them. Used to fast foward to a particular starting time. The start time is given in seconds."

	| buf startSample nextSample samplesRemaining n |
	self reset.
	buf _ SoundBuffer newStereoSampleCount: (self samplingRate // 10).
	startSample _ (startTime * self samplingRate) asInteger.
	nextSample _ 1.
	[self samplesRemaining > 0] whileTrue: [
		nextSample >= startSample ifTrue: [^ self].
		samplesRemaining _ startSample - nextSample.
		samplesRemaining > buf stereoSampleCount
			ifTrue: [n _ buf stereoSampleCount]
			ifFalse: [n _ samplesRemaining].
		self playSampleCount: n into: buf startingAt: 1.
		nextSample _ nextSample + n].
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 3/4/98 13:16'!
resumePlaying
	"Resume playing this sound from where it last stopped."

	SoundPlayer resumePlaying: self.
! !
!AbstractSound methodsFor: 'playing' stamp: 'jm 12/16/2001 13:22'!
samples
	"Answer a monophonic sample buffer containing my samples. The left and write channels are merged."
	"Warning: This may require a lot of memory!!"

	^ (self computeSamplesForSeconds: self duration) mergeStereo
! !
!AbstractSound methodsFor: 'playing' stamp: 'jmv 4/1/2009 21:36'!
viewSamples
	"Open a WaveEditor on my samples."

"	WaveEditor openOn: self samples"! !
!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/15/97 14:15'!
controlRate
	"Answer the number of control changes per second."

	^ 100
! !
!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/16/2001 13:14'!
originalSamplingRate
	"For sampled sounds, answer the sampling rate used to record the stored samples. For other sounds, this is the same as the playback sampling rate."

	^ SoundPlayer samplingRate
! !
!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/17/97 18:00'!
samplingRate
	"Answer the sampling rate in samples per second."

	^ SoundPlayer samplingRate
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!
doControl
	"Update the control parameters of this sound using its envelopes, if any."
	"Note: This is only called at a small fraction of the sampling rate."

	| pitchModOrRatioChange |
	envelopes size > 0 ifTrue: [
		pitchModOrRatioChange _ false.
		1 to: envelopes size do: [:i |
			((envelopes at: i) updateTargetAt: mSecsSinceStart)
				ifTrue: [pitchModOrRatioChange _ true]].
		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].
	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 2/4/98 08:56'!
internalizeModulationAndRatio
	"Overridden by FMSound. This default implementation does nothing."
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."

	self subclassResponsibility.
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!
reset
	"Reset my internal state for a replay. Methods that override this method should do super reset."

	mSecsSinceStart _ 0.
	samplesUntilNextControl _ 0.
	envelopes size > 0 ifTrue: [
		1 to: envelopes size do: [:i | (envelopes at: i) reset]].
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 17:57'!
samplesRemaining
	"Answer the number of samples remaining until the end of this sound. A sound with an indefinite ending time should answer some large integer such as 1000000."

	^ 1000000
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!
stopAfterMSecs: mSecs
	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!
stopGracefully
	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."

	| decayInMs env |
	envelopes isEmpty
		ifTrue: [
			self adjustVolumeTo: 0 overMSecs: 10.
			decayInMs _ 10]
		ifFalse: [
			env _ envelopes first.
			decayInMs _ env attackTime + env decayTime].
	self duration: (mSecsSinceStart + decayInMs) / 1000.0.
	self stopAfterMSecs: decayInMs.
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 14:21'!
storeSample: sample in: aSoundBuffer at: sliceIndex leftVol: leftVol rightVol: rightVol
	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, this method is hand-inlined into all sound generation methods that use it."

	| i s |
		leftVol > 0 ifTrue: [
			i _ (2 * sliceIndex) - 1.
			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		rightVol > 0 ifTrue: [
			i _ 2 * sliceIndex.
			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
! !
!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 17:57'!
updateVolume
	"Increment the volume envelope of this sound. To avoid clicks, the volume envelope must be interpolated at the sampling rate, rather than just at the control rate like other envelopes. At the control rate, the volume envelope computes the slope and next target volume volume for the current segment of the envelope (i.e., it sets the rate of change for the volume parameter). When that target volume is reached, incrementing is stopped until a new increment is set."
	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, it is hand-inlined into all sound generation methods that use it."

		scaledVolIncr ~= 0 ifTrue: [
			scaledVol _ scaledVol + scaledVolIncr.
			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:
			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])
				ifTrue: [  "reached the limit; stop incrementing"
					scaledVol _ scaledVolLimit.
					scaledVolIncr _ 0]].
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 12/9/97 11:31'!
duration: seconds
	"Scale my envelopes to the given duration. Subclasses overriding this method should include a resend to super."

	envelopes do: [:e | e duration: seconds].
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 2/4/98 09:54' overrides: 16920235!
initialize

	envelopes _ #().
	mSecsSinceStart _ 0.
	samplesUntilNextControl _ 0.
	scaledVol _ (1.0 * ScaleFactor) rounded.
	scaledVolIncr _ 0.
	scaledVolLimit _ scaledVol.
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 3/24/1999 12:03'!
loudness: aNumber
	"Initialize my volume envelopes and initial volume. Subclasses overriding this method should include a resend to super."

	| vol |
	vol _ (aNumber asFloat max: 0.0) min: 1.0.
	envelopes do: [:e |
		(e isKindOf: VolumeEnvelope) ifTrue: [e scale: vol]].
	self initialVolume: vol.
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!
nameOrNumberToPitch: aStringOrNumber
	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."

	aStringOrNumber isNumber
		ifTrue: [^ aStringOrNumber asFloat]
		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!
setPitch: pitchNameOrNumber dur: d loudness: l
	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."

	| p |
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	envelopes do: [:e |
		e volume: l.
		e centerPitch: p].
	self initialVolume: l.
	self duration: d.
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!
soundForMidiKey: midiKey dur: d loudness: l
	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."

	^ self copy
		setPitch: (AbstractSound pitchForMIDIKey: midiKey)
		dur: d
		loudness: l
! !
!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!
soundForPitch: pitchNameOrNumber dur: d loudness: l
	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."

	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l
! !
!AbstractSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 22:34'!
isStereo
	"Answer true if this sound has distinct left and right channels. (Every sound plays into a stereo sample buffer, but most sounds, which produce exactly the same samples on both channels, are not stereo.)"

	^ false
! !
!AbstractSound methodsFor: 'file i/o' stamp: 'pb 5/25/2016 01:35'!
storeAIFFOnFileNamed: fileName
	"Store this sound as a AIFF file of the given name."

	fileName asFileEntry writeStreamDo: [ :strm |
		strm binary.
		self storeAIFFSamplesOn: strm ]! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 2/26/2016 17:03'!
storeAIFFSamplesOn: aBinaryStream
	"Store this sound as a 16-bit AIFF file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."

	| samplesToStore channelCount dataByteCount |
	samplesToStore _ (self duration * self samplingRate) ceiling.
	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].
	dataByteCount _ samplesToStore * channelCount * 2.

	"write AIFF file header:"
	aBinaryStream nextPutAll: 'FORM' asByteArray.
	aBinaryStream nextSignedInt32Put: ((7 * 4) + 18) + dataByteCount bigEndian: true.
	aBinaryStream nextPutAll: 'AIFF' asByteArray.
	aBinaryStream nextPutAll: 'COMM' asByteArray.
	aBinaryStream nextSignedInt32Put: 18 bigEndian: true.
	aBinaryStream nextUnsignedInt16Put: channelCount bigEndian: true.
	aBinaryStream nextSignedInt32Put: samplesToStore bigEndian: true.
	aBinaryStream nextUnsignedInt16Put: 16 bigEndian: true.  "bits/sample"
	self storeExtendedFloat: self samplingRate on: aBinaryStream.
	aBinaryStream nextPutAll: 'SSND' asByteArray.
	aBinaryStream nextSignedInt32Put: dataByteCount + 8 bigEndian: true.
	aBinaryStream nextSignedInt32Put: 0 bigEndian: true.
	aBinaryStream nextSignedInt32Put: 0 bigEndian: true.

	"write data:"
	self storeSampleCount: samplesToStore bigEndian: true on: aBinaryStream.
! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 4/11/2019 15:33:07'!
storeExtendedFloat: aNumber on: aBinaryStream
	"Store an Apple extended-precision 80-bit floating point number on the given stream."
	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."

	| n isNeg exp mantissa |
	n _ aNumber asFloat.
	isNeg _ false.
	n < 0.0 ifTrue: [
		n _ 0.0 - n.
		isNeg _ true].
	exp _ (n log: 2.0) ceiling.
	mantissa _ (n * (2 raisedTo: 64 - exp)) truncated.
	exp _ exp + 16r4000 - 2.  "not sure why the -2 is needed..."
	isNeg ifTrue: [exp _ exp bitOr: 16r8000].  "set sign bit"
	aBinaryStream nextPut: ((exp bitShift: -8) bitAnd: 16rFF).
	aBinaryStream nextPut: (exp bitAnd: 16rFF).
	aBinaryStream nextUnsignedInt32Put: mantissa >> 32 bigEndian: true.
	aBinaryStream nextUnsignedInt32Put: (mantissa bitAnd: 16rFFFFFFFF) bigEndian: true.! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 7/17/2017 15:39:47'!
storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.

	'Storing audio...' displayProgressAt: Sensor mousePoint
		from: 0 to: samplesToStore during: [:barBlock | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				barBlock value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream nextSignedInt16Put: (out at: i) bigEndian: bigEndianFlag ]].
				remaining _ remaining - bufSize]]! !
!AbstractSound methodsFor: 'file i/o' stamp: 'pb 5/25/2016 01:35'!
storeWAVOnFileNamed: fileName
	"Store this sound as a 16-bit Windows WAV file of the given name."

	fileName asFileEntry writeStreamDo: [ :strm |
		strm binary.
		self storeWAVSamplesOn: strm ]! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 2/26/2016 16:33'!
storeWAVSamplesOn: aBinaryStream
	"Store this sound as a 16-bit Windows WAV file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."

	| samplesToStore channelCount dataByteCount samplesPerSec bytesPerSec |
	samplesToStore _ (self duration * self samplingRate) ceiling.
	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].
	dataByteCount _ samplesToStore * channelCount * 2.
	samplesPerSec _ self samplingRate rounded.
	bytesPerSec _ samplesPerSec * channelCount * 2.

	"file header"
	aBinaryStream
		nextPutAll: 'RIFF' asByteArray;
		nextUnsignedInt32Put: dataByteCount + 36 bigEndian: false;	"total length of all chunks"
		nextPutAll: 'WAVE' asByteArray.

	"format chunk"
	aBinaryStream
		nextPutAll: 'fmt ' asByteArray;
		nextUnsignedInt32Put: 16 bigEndian: false;	"length of this chunk"
		nextUnsignedInt16Put: 1 bigEndian: false;	"format tag"
		nextUnsignedInt16Put: channelCount bigEndian: false;
		nextUnsignedInt32Put: samplesPerSec bigEndian: false;
		nextUnsignedInt32Put: bytesPerSec bigEndian: false;
		nextUnsignedInt16Put: 4 bigEndian: false;	"alignment"
		nextUnsignedInt16Put: 16 bigEndian: false.	"bits per sample"

	"data chunk"
	aBinaryStream
		nextPutAll: 'data' asByteArray;
		nextUnsignedInt32Put: dataByteCount bigEndian: false.  "length of this chunk"

	self storeSampleCount: samplesToStore bigEndian: false on: aBinaryStream.
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:38'!
bachFugue
	"Play a fugue by J. S. Bach using and instance of me as the sound for all four voices."
	"PluckedSound bachFugue play"

	^ self bachFugueOn: self default
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 18:27'!
bachFugueOn: aSound
	"Play a fugue by J. S. Bach using the given sound as the sound for all four voices."
	"PluckedSound bachFugue play"

	^ MixedSound new
		add: (self bachFugueVoice1On: aSound) pan: 1.0;
		add: (self bachFugueVoice2On: aSound) pan: 0.0;
		add: (self bachFugueVoice3On: aSound) pan: 1.0;
		add: (self bachFugueVoice4On: aSound) pan: 0.0.
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:51'!
bachFugueVoice1On: aSound
	"Voice one of a fugue by J. S. Bach."

	^ self noteSequenceOn: aSound from: #(
		(1047 0.15 268)
		(988  0.15 268)
		(1047 0.30 268)
		(784  0.30 268)
		(831  0.30 268)
		(1047 0.15 268)
		(988  0.15 268)
		(1047 0.30 268)
		(1175 0.30 268)
		(784  0.30 268)
		(1047 0.15 268)
		(988  0.15 268)
		(1047 0.30 268)
		(1175 0.30 268)
		(698  0.15 268)
		(784  0.15 268)
		(831  0.60 268)
		(784  0.15 268)
		(698  0.15 268)
		(622  0.15 268)
		(1047 0.15 268)
		(988  0.15 268)
		(880  0.15 268)
		(784  0.15 268)
		(698  0.15 268)
		(622  0.15 268)
		(587  0.15 268)
		(523  0.30 268)
		(1245 0.30 268)
		(1175 0.30 268)
		(1047 0.30 268)
		(932  0.30 268)
		(880  0.30 268)
		(932  0.30 268)
		(1047 0.30 268)
		(740  0.30 268)
		(784  0.30 268)
		(880  0.30 268)
		(740  0.30 268)
		(784  0.60 268)
		(rest 0.15)
		(523  0.15 268)
		(587  0.15 268)
		(622  0.15 268)
		(698  0.15 268)
		(784  0.15 268)
		(831  0.45 268)
		(587  0.15 268)
		(622  0.15 268)
		(698  0.15 268)
		(784  0.15 268)
		(880  0.15 268)
		(932  0.45 268)
		(622  0.15 268)
		(698  0.15 268)
		(784  0.15 268)
		(831  0.15 268)
		(784  0.15 268)
		(698  0.15 268)
		(622  0.15 268)
		(587  0.30 268)
		(1047 0.15 268)
		(988  0.15 268)
		(1047 0.60 268)
		(rest 0.9)
		(1397 0.30 268)
		(1245 0.30 268)
		(1175 0.30 268)
		(rest 0.3)
		(831  0.30 268)
		(784  0.30 268)
		(698  0.30 268)
		(784  0.30 268)
		(698  0.15 268)
		(622  0.15 268)
		(698  0.30 268)
		(587  0.30 268)
		(784  0.60 268)
		(rest 0.3)
		(988  0.30 268)
		(1047 0.30 268)
		(1047 0.15 268)
		(988  0.15 268)
		(1047 0.30 268)
		(784  0.30 268)
		(831  0.60 268)
		(rest 0.3)
		(880  0.30 268)
		(932  0.30 268)
		(932  0.15 268)
		(880  0.15 268)
		(932  0.30 268)
		(698  0.30 268)
		(784  0.60 268)
		(rest 0.3)
		(784  0.30 268)
		(831  0.30 268)
		(831  0.30 268)
		(784  0.30 268)
		(698  0.30 268)
		(rest 0.3)
		(415  0.30 268)
		(466  0.30 268)
		(523  0.30 268)
		(rest 0.3)
		(415  0.15 268)
		(392  0.15 268)
		(415  0.30 268)
		(349  0.30 268)
		(466  0.30 268)
		(523  0.30 268)
		(466  0.30 268)
		(415  0.30 268)
		(466  0.30 268)
		(392  0.30 268)
		(349  0.30 268)
		(311  0.30 268)
		(349  0.30 268)
		(554  0.30 268)
		(523  0.30 268)
		(466  0.30 268)
		(523  0.30 268)
		(415  0.30 268)
		(392  0.30 268)
		(349  0.30 268)
		(392  0.30 268)
		(784  0.15 268)
		(740  0.15 268)
		(784  0.30 268)
		(523  0.30 268)
		(622  0.30 268)
		(784  0.15 268)
		(740  0.15 268)
		(784  0.30 268)
		(880  0.30 268)
		(587  0.30 268)
		(784  0.15 268)
		(740  0.15 268)
		(784  0.30 268)
		(880  0.30 268)
		(523  0.15 268)
		(587  0.15 268)
		(622  0.60 268)
		(587  0.15 268)
		(523  0.15 268)
		(466  0.30 346)
		(rest 0.45)
		(587  0.15 346)
		(659  0.15 346)
		(740  0.15 346)
		(784  0.15 346)
		(880  0.15 346)
		(932  0.45 346)
		(659  0.15 346)
		(698  0.15 346)
		(784  0.15 346)
		(880  0.15 346)
		(932  0.15 346)
		(1047 0.45 346)
		(740  0.15 346)
		(784  0.15 346)
		(880  0.15 346)
		(932  0.30 346)
		(622  0.15 346)
		(587  0.15 346)
		(622  0.30 346)
		(392  0.30 346)
		(415  0.30 346)
		(698  0.15 346)
		(622  0.15 346)
		(698  0.30 346)
		(440  0.30 346)
		(466  0.30 346)
		(784  0.15 346)
		(698  0.15 346)
		(784  0.30 346)
		(494  0.30 346)
		(523  0.15 346)
		(698  0.15 346)
		(622  0.15 346)
		(587  0.15 346)
		(523  0.15 346)
		(466  0.15 346)
		(440  0.15 346)
		(392  0.15 346)
		(349  0.30 346)
		(831  0.30 346)
		(784  0.30 346)
		(698  0.30 346)
		(622  0.30 346)
		(587  0.30 346)
		(622  0.30 346)
		(698  0.30 346)
		(494  0.30 346)
		(523  0.30 346)
		(587  0.30 346)
		(494  0.30 346)
		(523  0.60 346)
		(rest 0.3)
		(659  0.30 346)
		(698  0.30 346)
		(698  0.15 346)
		(659  0.15 346)
		(698  0.30 346)
		(523  0.30 346)
		(587  0.60 346)
		(rest 0.3)
		(587  0.30 346)
		(622  0.30 346)
		(622  0.15 346)
		(587  0.15 346)
		(622  0.30 346)
		(466  0.30 346)
		(523  1.20 346)
		(523  0.30 346)
		(587  0.15 346)
		(622  0.15 346)
		(698  0.15 346)
		(622  0.15 346)
		(698  0.15 346)
		(587  0.15 346)
		(494  0.30 457)
		(rest 0.6)
		(494  0.30 457)
		(523  0.30 457)
		(rest 0.6)
		(622  0.30 457)
		(587  0.30 457)
		(rest 0.6)
		(698  0.60 457)
		(rest 0.6)
		(698  0.30 457)
		(622  0.30 457)
		(831  0.30 457)
		(784  0.30 457)
		(698  0.30 457)
		(622  0.30 457)
		(587  0.30 457)
		(622  0.30 457)
		(698  0.30 457)
		(494  0.30 457)
		(523  0.30 457)
		(587  0.30 457)
		(494  0.30 457)
		(494  0.30 457)
		(523  0.30 457)
		(rest 0.3)
		(523  0.30 457)
		(698  0.15 457)
		(587  0.15 457)
		(622  0.15 457)
		(523  0.45 457)
		(494  0.30 457)
		(523  0.60 457)
		(rest 0.3)
		(659  0.30 268)
		(698  0.60 268)
		(rest 0.3)
		(698  0.30 268)
		(698  0.30 268)
		(622  0.15 268)
		(587  0.15 268)
		(622  0.30 268)
		(698  0.30 268)
		(587  0.40 268)
		(rest 0.4)
		(587  0.40 268)
		(rest 0.4)
		(523  1.60 268)).! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!
bachFugueVoice2On: aSound
	"Voice two of a fugue by J. S. Bach."

	^ self noteSequenceOn: aSound from: #(
		(rest 4.8)
		(1568 0.15 346)
		(1480 0.15 346)
		(1568 0.30 346)
		(1047 0.30 346)
		(1245 0.30 346)
		(1568 0.15 346)
		(1480 0.15 346)
		(1568 0.30 346)
		(1760 0.30 346)
		(1175 0.30 346)
		(1568 0.15 346)
		(1480 0.15 346)
		(1568 0.30 346)
		(1760 0.30 346)
		(1047 0.15 346)
		(1175 0.15 346)
		(1245 0.60 346)
		(1175 0.15 346)
		(1047 0.15 346)
		(932  0.30 346)
		(1245 0.15 346)
		(1175 0.15 346)
		(1245 0.30 346)
		(784  0.30 346)
		(831  0.30 346)
		(1397 0.15 346)
		(1245 0.15 346)
		(1397 0.30 346)
		(880  0.30 346)
		(932  0.30 346)
		(1568 0.15 346)
		(1397 0.15 346)
		(1568 0.30 346)
		(988  0.30 346)
		(1047 0.30 346)
		(1175 0.15 346)
		(1245 0.15 346)
		(1397 0.90 346)
		(1245 0.15 346)
		(1175 0.15 346)
		(1047 0.15 346)
		(932  0.15 346)
		(831  0.15 346)
		(784  0.15 346)
		(698  0.30 346)
		(1661 0.30 346)
		(1568 0.30 346)
		(1397 0.30 346)
		(1245 0.30 346)
		(1175 0.30 346)
		(1245 0.30 346)
		(1397 0.30 346)
		(988  0.30 346)
		(1047 0.30 346)
		(1175 0.30 346)
		(988  0.30 346)
		(1047 0.30 457)
		(1568 0.15 457)
		(1480 0.15 457)
		(1568 0.30 457)
		(1175 0.30 457)
		(1245 0.60 457)
		(rest 0.3)
		(1319 0.30 457)
		(1397 0.30 457)
		(1397 0.15 457)
		(1319 0.15 457)
		(1397 0.30 457)
		(1047 0.30 457)
		(1175 0.60 457)
		(rest 0.3)
		(1175 0.30 457)
		(1245 0.30 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1245 0.30 457)
		(932  0.30 457)
		(1047 0.30 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1245 0.30 457)
		(1397 0.30 457)
		(932  0.30 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1245 0.30 457)
		(1397 0.30 457)
		(831  0.15 457)
		(932  0.15 457)
		(1047 0.60 457)
		(932  0.15 457)
		(831  0.15 457)
		(784  0.15 457)
		(622  0.15 457)
		(698  0.15 457)
		(784  0.15 457)
		(831  0.15 457)
		(932  0.15 457)
		(1047 0.15 457)
		(1175 0.15 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1047 0.15 457)
		(1175 0.15 457)
		(1245 0.15 457)
		(1397 0.15 457)
		(1568 0.15 457)
		(1760 0.15 457)
		(1865 0.15 457)
		(698  0.15 457)
		(784  0.15 457)
		(831  0.15 457)
		(932  0.15 457)
		(1047 0.15 457)
		(1175 0.15 457)
		(1319 0.15 457)
		(1397 0.15 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1245 0.15 457)
		(1397 0.15 457)
		(1568 0.15 457)
		(1760 0.15 457)
		(1976 0.15 457)
		(2093 0.30 457)
		(1976 0.15 457)
		(1760 0.15 457)
		(1568 0.15 457)
		(1397 0.15 457)
		(1245 0.15 457)
		(1175 0.15 457)
		(1047 0.30 457)
		(1245 0.30 457)
		(1175 0.30 457)
		(1047 0.30 457)
		(932  0.30 457)
		(880  0.30 457)
		(932  0.30 457)
		(1047 0.30 457)
		(740  0.30 457)
		(784  0.30 457)
		(880  0.30 457)
		(740  0.30 457)
		(784  0.30 457)
		(1175 0.15 457)
		(1047 0.15 457)
		(1175 0.30 457)
		(rest 0.6)
		(1319 0.15 457)
		(1175 0.15 457)
		(1319 0.30 457)
		(rest 0.6)
		(1480 0.15 457)
		(1319 0.15 457)
		(1480 0.30 457)
		(rest 0.6)
		(784  0.15 457)
		(698  0.15 457)
		(784  0.30 457)
		(rest 0.6)
		(880  0.15 457)
		(784  0.15 457)
		(880  0.30 457)
		(rest 0.6)
		(988  0.15 457)
		(880  0.15 457)
		(988  0.30 457)
		(rest 0.6)
		(1047 0.15 457)
		(988  0.15 457)
		(1047 0.30 457)
		(784  0.30 457)
		(831  0.30 457)
		(1047 0.15 457)
		(988  0.15 457)
		(1047 0.30 457)
		(1175 0.30 457)
		(784  0.30 457)
		(1047 0.15 457)
		(988  0.15 457)
		(1047 0.30 457)
		(1175 0.30 457)
		(698  0.15 457)
		(784  0.15 457)
		(831  0.60 457)
		(784  0.15 457)
		(698  0.15 457)
		(622  0.30 457)
		(1047 0.15 457)
		(988  0.15 457)
		(1047 0.30 457)
		(784  0.30 457)
		(831  0.60 457)
		(rest 0.3)
		(880  0.30 457)
		(932  0.30 457)
		(932  0.15 457)
		(880  0.15 457)
		(932  0.30 457)
		(698  0.30 457)
		(784  0.60 457)
		(rest 0.3)
		(784  0.60 457)
		(831  0.15 457)
		(932  0.15 457)
		(1047 0.15 457)
		(988  0.15 457)
		(1047 0.15 457)
		(831  0.15 457)
		(698  1.20 457)
		(698  0.30 591)
		(1175 0.15 591)
		(1047 0.15 591)
		(1175 0.30 591)
		(698  0.30 591)
		(622  0.30 591)
		(1245 0.15 591)
		(1175 0.15 591)
		(1245 0.30 591)
		(784  0.30 591)
		(698  0.30 591)
		(1397 0.15 591)
		(1245 0.15 591)
		(1397 0.30 591)
		(831  0.30 591)
		(784  0.15 591)
		(1397 0.15 591)
		(1245 0.15 591)
		(1175 0.15 591)
		(1047 0.15 591)
		(988  0.15 591)
		(880  0.15 591)
		(784  0.15 591)
		(1047 0.30 591)
		(1397 0.30 591)
		(1245 0.30 591)
		(1175 0.30 591)
		(rest 0.3)
		(831  0.30 591)
		(784  0.30 591)
		(698  0.30 591)
		(784  0.30 591)
		(698  0.15 591)
		(622  0.15 591)
		(698  0.30 591)
		(587  0.30 591)
		(831  0.30 591)
		(784  0.30 591)
		(rest 0.3)
		(880  0.30 591)
		(988  0.30 591)
		(1047 0.30 591)
		(698  0.15 591)
		(622  0.15 591)
		(587  0.15 591)
		(523  0.15 591)
		(523  0.30 591)
		(1047 0.15 346)
		(988  0.15 346)
		(1047 0.30 346)
		(784  0.30 346)
		(831  0.30 346)
		(1047 0.15 346)
		(988  0.15 346)
		(1047 0.30 346)
		(1175 0.30 346)
		(784  0.30 346)
		(1047 0.15 346)
		(988  0.15 346)
		(1047 0.30 346)
		(1175 0.30 346)
		(698  0.20 346)
		(784  0.20 346)
		(831  0.80 346)
		(784  0.20 346)
		(698  0.20 346)
		(659  1.60 346)).
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!
bachFugueVoice3On: aSound
	"Voice three of a fugue by J. S. Bach."

	^ self noteSequenceOn: aSound from: #(
		(rest 14.4)
		(523  0.15 457)
		(494  0.15 457)
		(523  0.30 457)
		(392  0.30 457)
		(415  0.30 457)
		(523  0.15 457)
		(494  0.15 457)
		(523  0.30 457)
		(587  0.30 457)
		(392  0.30 457)
		(523  0.15 457)
		(494  0.15 457)
		(523  0.30 457)
		(587  0.30 457)
		(349  0.15 457)
		(392  0.15 457)
		(415  0.60 457)
		(392  0.15 457)
		(349  0.15 457)
		(311  0.15 457)
		(523  0.15 457)
		(494  0.15 457)
		(440  0.15 457)
		(392  0.15 457)
		(349  0.15 457)
		(311  0.15 457)
		(294  0.15 457)
		(262  0.15 457)
		(294  0.15 457)
		(311  0.15 457)
		(294  0.15 457)
		(262  0.15 457)
		(233  0.15 457)
		(208  0.15 457)
		(196  0.15 457)
		(175  0.15 457)
		(466  0.15 457)
		(415  0.15 457)
		(392  0.15 457)
		(349  0.15 457)
		(311  0.15 457)
		(294  0.15 457)
		(262  0.15 457)
		(233  0.15 457)
		(262  0.15 457)
		(294  0.15 457)
		(262  0.15 457)
		(233  0.15 457)
		(208  0.15 457)
		(196  0.15 457)
		(175  0.15 457)
		(156  0.15 457)
		(415  0.15 457)
		(392  0.15 457)
		(349  0.15 457)
		(311  0.15 457)
		(277  0.15 457)
		(262  0.15 457)
		(233  0.15 457)
		(208  0.30 457)
		(523  0.30 457)
		(466  0.30 457)
		(415  0.30 457)
		(392  0.30 457)
		(349  0.30 457)
		(392  0.30 457)
		(415  0.30 457)
		(294  0.30 457)
		(311  0.30 457)
		(349  0.30 457)
		(294  0.30 457)
		(311  0.30 457)
		(415  0.30 457)
		(392  0.30 457)
		(349  0.30 457)
		(392  0.30 457)
		(311  0.30 457)
		(294  0.30 457)
		(262  0.30 457)
		(294  0.30 457)
		(466  0.30 457)
		(415  0.30 457)
		(392  0.30 457)
		(415  0.30 457)
		(349  0.30 457)
		(311  0.30 457)
		(294  0.30 457)
		(311  0.30 457)
		(rest 1.2)
		(262  0.30 457)
		(233  0.30 457)
		(220  0.30 457)
		(rest 0.3)
		(311  0.30 457)
		(294  0.30 457)
		(262  0.30 457)
		(294  0.30 457)
		(262  0.15 457)
		(233  0.15 457)
		(262  0.30 457)
		(294  0.30 457)
		(196  0.30 591)
		(466  0.15 591)
		(440  0.15 591)
		(466  0.30 591)
		(294  0.30 591)
		(311  0.30 591)
		(523  0.15 591)
		(466  0.15 591)
		(523  0.30 591)
		(330  0.30 591)
		(349  0.30 591)
		(587  0.15 591)
		(523  0.15 591)
		(587  0.30 591)
		(370  0.30 591)
		(392  0.60 591)
		(rest 0.15)
		(196  0.15 591)
		(220  0.15 591)
		(247  0.15 591)
		(262  0.15 591)
		(294  0.15 591)
		(311  0.45 591)
		(220  0.15 591)
		(233  0.15 591)
		(262  0.15 591)
		(294  0.15 591)
		(311  0.15 591)
		(349  0.45 591)
		(247  0.15 591)
		(262  0.15 591)
		(294  0.15 591)
		(311  0.30 591)
		(rest 0.6)
		(330  0.30 591)
		(349  0.30 591)
		(175  0.30 591)
		(156  0.30 591)
		(147  0.30 591)
		(rest 0.3)
		(208  0.30 591)
		(196  0.30 591)
		(175  0.30 591)
		(196  0.30 591)
		(175  0.15 591)
		(156  0.15 591)
		(175  0.30 591)
		(196  0.30 591)
		(262  0.15 591)
		(294  0.15 591)
		(311  0.15 591)
		(294  0.15 591)
		(262  0.15 591)
		(233  0.15 591)
		(208  0.15 591)
		(196  0.15 591)
		(175  0.15 591)
		(466  0.15 591)
		(415  0.15 591)
		(392  0.15 591)
		(349  0.15 591)
		(311  0.15 591)
		(294  0.15 591)
		(262  0.15 591)
		(233  0.15 591)
		(262  0.15 591)
		(294  0.15 591)
		(262  0.15 591)
		(233  0.15 591)
		(208  0.15 591)
		(196  0.15 591)
		(175  0.15 591)
		(156  0.15 591)
		(415  0.15 591)
		(392  0.15 591)
		(349  0.15 591)
		(311  0.15 591)
		(294  0.15 591)
		(262  0.15 591)
		(233  0.15 591)
		(208  0.15 591)
		(233  0.15 591)
		(262  0.15 591)
		(233  0.15 591)
		(208  0.15 591)
		(196  0.15 591)
		(175  0.15 591)
		(156  0.15 591)
		(147  0.15 591)
		(392  0.15 591)
		(349  0.15 591)
		(311  0.15 591)
		(294  0.15 591)
		(262  0.15 591)
		(247  0.15 591)
		(220  0.15 591)
		(196  0.60 772)
		(196  0.60 772)
		(rest 0.15)
		(196  0.15 772)
		(220  0.15 772)
		(247  0.15 772)
		(262  0.15 772)
		(294  0.15 772)
		(311  0.15 772)
		(349  0.15 772)
		(392  0.15 772)
		(349  0.15 772)
		(415  0.15 772)
		(392  0.15 772)
		(349  0.15 772)
		(311  0.15 772)
		(294  0.15 772)
		(262  0.15 772)
		(247  0.30 772)
		(262  0.15 772)
		(494  0.15 772)
		(262  0.30 772)
		(196  0.30 772)
		(208  0.30 772)
		(262  0.15 772)
		(247  0.15 772)
		(262  0.30 772)
		(294  0.30 772)
		(196  0.30 772)
		(262  0.15 772)
		(247  0.15 772)
		(262  0.30 772)
		(294  0.30 772)
		(175  0.15 772)
		(196  0.15 772)
		(208  0.60 772)
		(196  0.15 772)
		(175  0.15 772)
		(156  0.60 772)
		(rest 0.3)
		(311  0.30 772)
		(294  0.30 772)
		(262  0.30 772)
		(392  0.30 772)
		(196  0.30 772)
		(262  3.60 268)
		(494  0.40 268)
		(rest 0.4)
		(494  0.40 268)
		(rest 0.4)
		(392  1.60 268)).
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!
bachFugueVoice4On: aSound
	"Voice four of a fugue by J. S. Bach."

	^ self noteSequenceOn: aSound from: #(
		(rest 61.2)
		(131  0.15 500)
		(123  0.15 500)
		(131  0.30 500)
		(98   0.30 500)
		(104  0.30 500)
		(131  0.15 500)
		(123  0.15 500)
		(131  0.30 500)
		(147  0.30 500)
		(98   0.30 500)
		(131  0.15 500)
		(123  0.15 500)
		(131  0.30 500)
		(147  0.30 500)
		(87   0.15 500)
		(98   0.15 500)
		(104  0.60 500)
		(98   0.15 500)
		(87   0.15 500)
		(78   0.60 500)
		(rest 0.3)
		(156  0.30 500)
		(147  0.30 500)
		(131  0.30 500)
		(196  0.30 500)
		(98   0.30 500)
		(131  3.60 268)
		(131  3.20 205)).
! !
!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:45'!
stereoBachFugue
	"Play fugue by J. S. Bach in stereo using different timbres."
	"AbstractSound stereoBachFugue play"

	"(AbstractSound bachFugueVoice1On: FMSound flute1) play"
	"(AbstractSound bachFugueVoice1On: PluckedSound default) play"

	^ MixedSound new
		add: (self bachFugueVoice1On: FMSound oboe1) pan: 0.2;
		add: (self bachFugueVoice2On: FMSound organ1) pan: 0.8;
		add: (self bachFugueVoice3On: PluckedSound default) pan: 0.4;
		add: (self bachFugueVoice4On: FMSound brass1) pan: 0.6.
! !
!AbstractSound class methodsFor: 'utilities' stamp: 'DSM 9/5/2000 13:50'!
busySignal: count
	"AbstractSound busySignal: 3"
	| m s |
	s _ SequentialSound new.
	m _ MixedSound new.
	m	add: (FMSound new setPitch: 480 dur: 0.5 loudness: 0.5);
		add: (FMSound new setPitch: 620 dur: 0.5 loudness: 0.5).
	s add: m.
	s add: (FMSound new setPitch: 1 dur: 0.5 loudness: 0).
	^ (RepeatingSound repeat: s count: count) play.

! !
!AbstractSound class methodsFor: 'utilities' stamp: 'eem 6/11/2008 12:40'!
dial: aString
	| s |
	"AbstractSound dial: '867-5309'" "ask for Jenny"

	s := SequentialSound new.
	aString do: [ :c | | index lo hi m |
		c = $,
			ifTrue: [ s add: (FMSound new setPitch: 1 dur: 1 loudness: 0) ]
			ifFalse: [
				(index := ('123A456B789C*0#D' indexOf: c)) > 0
					ifTrue: [
						lo := #(697 770 852 941) at: (index - 1 // 4 + 1).
						hi := #(1209 1336 1477 1633) at: (index - 1 \\ 4 + 1).
						m := MixedSound new.
						m add: (FMSound new setPitch: lo dur: 0.15 loudness: 0.5).
						m add: (FMSound new setPitch: hi dur: 0.15 loudness: 0.5).
						s add: m.
						s add: (FMSound new setPitch: 1 dur: 0.05 loudness: 0)]]].
	^ s play.

! !
!AbstractSound class methodsFor: 'utilities' stamp: 'DSM 9/5/2000 13:49'!
dialTone: duration
	"AbstractSound dialTone: 2"
	| m |
	m _ MixedSound new.
	m add: (FMSound new setPitch: 350 dur: duration loudness: 0.5).
	m add: (FMSound new setPitch: 440 dur: duration loudness: 0.5).
	m play.
	^ m! !
!AbstractSound class methodsFor: 'utilities' stamp: 'DSM 9/5/2000 13:50'!
hangUpWarning: count
	"AbstractSound hangUpWarning: 20"
	| m s |
	s _ SequentialSound new.
	m _ MixedSound new.
	m	add: (FMSound new setPitch: 1400 dur: 0.1 loudness: 0.5);
		add: (FMSound new setPitch: 2060 dur: 0.1 loudness: 0.5).
	s add: m; add: (FMSound new setPitch: 1 dur: 0.1 loudness: 0).
	^ (RepeatingSound repeat: s count: count) play

! !
!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!
indexOfBottomOctavePitch: p
	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."

	1 to: PitchesForBottomOctave size do: [:i |
		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].
	self error: 'implementation error: argument pitch should be below or within the bottom octave'.
! !
!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!
midiKeyForPitch: pitchNameOrNumber
	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."
	"AbstractSound midiKeyForPitch: 440.0"

	| p octave i midiKey |
	pitchNameOrNumber isNumber
		ifTrue: [p _ pitchNameOrNumber asFloat]
		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].
	octave _ -1.
	[p >= TopOfBottomOctave] whileTrue: [
		octave _ octave + 1.
		p _ p / 2.0].

	i _ self indexOfBottomOctavePitch: p.
	(i > 1) ifTrue: [
		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)
			ifTrue: [i _ i - 1]].

	midiKey _ ((octave * 12) + 11 + i).
	midiKey > 127 ifTrue: [midiKey _ 127].
	^ midiKey
! !
!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!
pitchForMIDIKey: midiKey
	"Answer the pitch for the given MIDI key."
	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"

	| indexInOctave octave |
	indexInOctave _ (midiKey \\ 12) + 1.
	octave _ (midiKey // 12) + 1.
	^ (PitchesForBottomOctave at: indexInOctave) *
		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)
! !
!AbstractSound class methodsFor: 'utilities' stamp: 'jmv 2/6/2010 20:32'!
pitchForName: aString
	"AbstractSound pitchForName: 'c2'"
	"#(c 'c#' d eb e f fs g 'g#' a bf b) collect: [ :s | AbstractSound pitchForName: s, '4']"

	| s modifier octave i j noteName p |
	s _ ReadStream on: aString.
	modifier _ $n.
	noteName _ s next.
	(s atEnd not and: [ s peek isDigit ]) ifFalse: [ modifier _ s next ].
	octave _ s atEnd
		ifTrue: [ 4 ]
		ifFalse: [ Integer readFrom: s ].
	octave < 0 ifTrue: [ self error: 'cannot use negative octave number' ].
	i _ 'cdefgab' indexOf: noteName.
	i = 0 ifTrue: [ self error: 'bad note name: ', noteName asString ].
	i _ #(2 4 6 7 9 11 13) at: i.
	j _ 's#fb' indexOf: modifier.
	j = 0 ifFalse: [ i _ i + (#(1 1 -1 -1) at: j) ].  "i is now in range: [1..14]"
	"Table generator: (1 to: 14) collect: [ :i | 16.3516 * (2.0 raisedTo: (i - 2) asFloat / 12.0)]"
	p _ #(15.4339 16.3516 17.3239 18.354 19.4454 20.6017 21.8268 23.1247 24.4997 25.9565 27.5 29.1352 30.8677 32.7032) at: i.
	p _ p * (2.0 raisedToInteger: octave).
	^ p
! !
!AbstractSound class methodsFor: 'utilities' stamp: 'jmv 3/13/2012 12:13'!
pitchTable
	"AbstractSound pitchTable"

	| out i |
	out := WriteStream on: (String new: 1000).
	i := 12.
	0 to: 8 do: [:octave |
		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName | | note |
			note := noteName, octave printString.
			out nextPutAll: note; tab.
			out nextPutAll: i printString; tab.
			out nextPutAll: (AbstractSound pitchForName: note) printString; newLine.
			i := i + 1]].
	^ out contents
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!
chromaticPitchesFrom: aPitch

	| halfStep pitch |
	halfStep _ 2.0 raisedTo: (1.0 / 12.0).
	pitch _ aPitch isNumber
			ifTrue: [aPitch]
			ifFalse: [self pitchForName: aPitch].
	pitch _ pitch / halfStep.
	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!
chromaticRunFrom: startPitch to: endPitch on: aSound
	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."
	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"

	| scale halfStep pEnd p |
	scale _ SequentialSound new.
	halfStep _ 2.0 raisedTo: (1.0 / 12.0).
	endPitch isNumber
		ifTrue: [pEnd _ endPitch asFloat]
		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].
	startPitch isNumber
		ifTrue: [p _ startPitch asFloat]
		ifFalse: [p _ AbstractSound pitchForName: startPitch].
	[p <= pEnd] whileTrue: [
		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).
		p _ p * halfStep].
	^ scale
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:35'!
chromaticScale
	"PluckedSound chromaticScale play"

	^ self chromaticScaleOn: self default
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/31/98 16:14'!
chromaticScaleOn: aSound
	"PluckedSound chromaticScale play"

	^ self noteSequenceOn: aSound
		from: (((self chromaticPitchesFrom: #c4) copyFrom: 1 to: 13)
			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!
hiMajorScale
	"FMSound hiMajorScale play"

	^ self hiMajorScaleOn: self default
! !
!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:00'!
hiMajorScaleOn: aSound
	"FMSound hiMajorScale play"

	^ self majorScaleOn: aSound from: #c6! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!
lowMajorScale
	"PluckedSound lowMajorScale play"

	^ self lowMajorScaleOn: self default
! !
!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:01'!
lowMajorScaleOn: aSound
	"PluckedSound lowMajorScale play"

	^ self majorScaleOn: aSound from: #c3! !
!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:04'!
majorChord
	"FMSound majorChord play"
	^ self majorChordOn: self default from: #c4! !
!AbstractSound class methodsFor: 'examples' stamp: 'eem 6/11/2008 12:41'!
majorChordOn: aSound from: aPitch
	"FMSound majorChord play"

	| score majorScale leadingRest pan |
	majorScale := self majorPitchesFrom: aPitch.
	score := MixedSound new.
	leadingRest := pan := 0.
	#(1 3 5 8) do: [:noteIndex | | note |
		note := aSound
					soundForPitch: (majorScale at: noteIndex)
					dur: 2.0 - leadingRest
					loudness: 0.3.
		score add: (RestSound dur: leadingRest), note pan: pan.
		leadingRest := leadingRest + 0.2.
		pan := pan + 0.3].
	^ score
! !
!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 14:45'!
majorPitchesFrom: aPitch
	| chromatic |
	chromatic _ self chromaticPitchesFrom: aPitch.
	^ #(1 3 5 6 8 10 12 13 15 13 12 10 8 6 5 3 1) collect: [:i | chromatic at: i].
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:34'!
majorScale
	"FMSound majorScale play"

	^ self majorScaleOn: self default
! !
!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:00'!
majorScaleOn: aSound
	"FMSound majorScale play"

	^ self majorScaleOn: aSound from: #c5! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!
majorScaleOn: aSound from: aPitch
	"FMSound majorScale play"

	^ self noteSequenceOn: aSound
		from: ((self majorPitchesFrom: aPitch)
			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jmv 3/1/2010 14:41'!
majorScaleOn: aSound from: aPitch octaves: octaveCount
	"(AbstractSound majorScaleOn: FMSound oboe1 from: #c2 octaves: 5) play"

	| startingPitch pitches |
	startingPitch _ aPitch isNumber
		ifTrue: [aPitch]
		ifFalse: [self pitchForName: aPitch].
	pitches _ OrderedCollection new.
	0 to: octaveCount - 1 do: [ :i | | chromatic |
		chromatic _ self chromaticPitchesFrom: startingPitch * (2 raisedTo: i).
		#(1 3 5 6 8 10 12) do: [ :j | pitches addLast: (chromatic at: j)]].
	pitches addLast: startingPitch * (2 raisedTo: octaveCount).
	^ self noteSequenceOn: aSound
		from: (pitches collect: [ :pitch | Array with: pitch with: 0.5 with: 300])
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:32'!
scaleTest
	"AbstractSound scaleTest play"

	^ MixedSound new
		add: FMSound majorScale pan: 0;
		add: (PluckedSound lowMajorScale delayedBy: 0.5) pan: 1.0.
! !
!AbstractSound class methodsFor: 'examples' stamp: 'jmv 1/14/2013 21:11'!
testFMInteractively
	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."
	"AbstractSound testFMInteractively"

	| s mousePt lastVal status mod ratio |
	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.
	s _ FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.

	SoundPlayer playSound: s.
	lastVal _ nil.
	[Sensor isAnyButtonPressed] whileFalse: [
		mousePt _ Sensor mousePoint.
		mousePt ~= lastVal ifTrue: [
			mod _ mousePt x asFloat / 20.0.
			ratio _ mousePt y asFloat / 20.0.
			s modulation: mod ratio: ratio.
			lastVal _ mousePt.
			status _
'mod: ', mod printString, '
ratio: ', ratio printString.
			status displayOn: Display at: 10@10]].

	SoundPlayer shutDown.
! !
!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 1/5/98 17:40'!
default
	"Return a default sound prototype for this class, with envelopes if appropriate. (This is in contrast to new, which returns a raw instance without envelopes.)"

	^ self new
! !
!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:26'!
dur: d
	"Return a rest of the given duration."

	^ self basicNew setDur: d
! !
!AbstractSound class methodsFor: 'instance creation' stamp: 'eem 6/11/2008 12:41'!
noteSequenceOn: aSound from: anArray
	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."
	| score |
	score := SequentialSound new.
	anArray do: [:el | | pitch |
		el size = 3
			ifTrue: [
				pitch := el at: 1.
				pitch isNumber ifFalse: [pitch := self pitchForName: pitch].
				score add: (
					aSound
						soundForPitch: pitch
						dur: (el at: 2)
						loudness: (el at: 3) / 1000.0)]
			ifFalse: [
				score add: (RestSound dur: (el at: 2))]].
	^ score
! !
!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:27'!
pitch: p dur: d loudness: l
	"Return a new sound object for a note with the given parameters."

	^ self new setPitch: p dur: d loudness: l
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!
fileOutSoundLibrary
	"File out the current sound library."
	"AbstractSound fileOutSoundLibrary"

	self fileOutSoundLibrary: Sounds.
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'pb 5/25/2016 01:35'!
fileOutSoundLibrary: aDictionary
	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."
	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."

	| fileName refStream |
	(aDictionary isKindOf: Dictionary)
		ifFalse: [self error: 'arg should be a dictionary of sounds'].
	fileName _ FillInTheBlankMorph request: 'Sound library file name?'.
	fileName isEmptyOrNil ifTrue: [^ self].
	(fileName, '.sounds') asFileEntry writeStreamDo: [ :file |
		refStream _ SmartRefStream on: file.
		[ refStream nextPut: aDictionary ]]! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!
storeFiledInSound: snd named: sndName
	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."

	| menu choice i |
	(Sounds includesKey: sndName) ifFalse: [  "no name clash"
		Sounds at: sndName put: snd.
		^ self].

	(Sounds at: sndName) == UnloadedSnd ifTrue: [
		"re-loading a sound that was unloaded to save space"
		Sounds at: sndName put: snd.
		^ self].

	"the given sound name is already used"
	menu _ SelectionMenu selections:
		#('replace the existing sound' 'rename the new sound' 'skip it').
	choice _ menu startUpWithCaption:
		'"', sndName, '" has the same name as an existing sound'.
	(choice beginsWith: 'replace') ifTrue: [
		Sounds at: sndName put: snd.
		^ self].
	(choice beginsWith: 'rename') ifTrue: [
		i _ 2.
		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].
		Sounds at: (sndName, ' v', i printString) put: snd].
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jmv 1/16/2011 23:57'!
unloadSampledTimbres
	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."
	"AbstractSound unloadSampledTimbres"

	Sounds keys do: [:soundName |
		(((Sounds at: soundName) isKindOf: SampledInstrument) or:
		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [
			Sounds at: soundName put: self unloadedSound]].
	self updateScorePlayers.
	Smalltalk garbageCollect! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!
unloadSoundNamed: soundName

	(Sounds includesKey: soundName) ifTrue: [
		Sounds at: soundName put: self unloadedSound].
	self updateScorePlayers.
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!
unloadedSound
	"Answer a sound to be used as the place-holder for sounds that have been unloaded."

	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].
	^ UnloadedSnd
! !
!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jmv 4/1/2009 21:39'!
updateScorePlayers
	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."

	| soundsBeingEdited |
	ScorePlayer allSubInstancesDo: [:p | p pause].
	SoundPlayer shutDown.
"	soundsBeingEdited := EnvelopeEditorMorph allSubInstances 
				collect: [:ed | ed soundBeingEdited].
	ScorePlayerMorph 
		allSubInstancesDo: [:p | p updateInstrumentsFromLibraryExcept: soundsBeingEdited]"! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:27'!
initSounds
	"AbstractSound initSounds"

	Sounds _ Dictionary new.
	(FMSound class organization listAtCategoryNamed: #instruments)
		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].
! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!
soundNamed: soundName

	^ Sounds at: soundName
! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jm 3/4/98 10:29'!
soundNamed: soundName ifAbsent: aBlock

	^ Sounds at: soundName ifAbsent: aBlock
! !
!AbstractSound class methodsFor: 'sound library' stamp: 'di 11/7/2000 12:12'!
soundNamed: soundName put: aSound

	Sounds at: soundName put: aSound.
	AbstractSound updateScorePlayers.
! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jmv 1/16/2011 23:53'!
soundNames

	^ Sounds keys sort! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!
sounds

	^ Sounds
! !
!AbstractSound class methodsFor: 'sound library' stamp: 'jmv 3/2/2010 09:00'!
updateFMSounds
	"AbstractSound updateFMSounds"

	Sounds keys do: [:k |
		((Sounds at: k) isKindOf: FMSound) ifTrue: [
			Sounds removeKey: k ifAbsent: nil]].

	(FMSound class organization listAtCategoryNamed: #instruments) do:
		[:sel | Sounds at: sel asString put: (FMSound perform: sel)].
! !
!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13' overrides: 16904184!
initialize
	"AbstractSound initialize"
 
	| bottomC |
	ScaleFactor _ 2 raisedTo: 15.
	FloatScaleFactor _ ScaleFactor asFloat.
	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"

	"generate pitches for c-1 through c0"
	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).
	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].
	TopOfBottomOctave _ PitchesForBottomOctave last.
! !
!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 1/5/98 13:51'!
scaleFactor

	^ ScaleFactor
! !
!AbstractSound class methodsFor: 'primitive generation' stamp: 'ar 2/3/2001 15:30'!
translatedPrimitives
	^#(
		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)
		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)
		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)
		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)
		(ReverbSound applyReverbTo:startingAt:count:)
	).
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 3/26/98 10:45'!
duration

	^ initialCount asFloat / self samplingRate asFloat
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49' overrides: 50603497!
duration: seconds

	super duration: seconds.
	count _ initialCount _ (seconds * self samplingRate) rounded.
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:44' overrides: 50603371!
internalizeModulationAndRatio
	"Recompute the internal state for the modulation index and frequency ratio relative to the current pitch."

	modulation < 0.0 ifTrue: [modulation _ modulation negated].
	multiplier < 0.0 ifTrue: [multiplier _ multiplier negated].
	normalizedModulation _
		((modulation * scaledIndexIncr)  / ScaleFactor) asInteger.
	scaledOffsetIndexIncr _ (multiplier * scaledIndexIncr) asInteger.

	"clip to maximum values if necessary"
	normalizedModulation > MaxScaledValue ifTrue: [
		normalizedModulation _ MaxScaledValue.
		modulation _ (normalizedModulation * ScaleFactor) asFloat / scaledIndexIncr].
	scaledOffsetIndexIncr > (scaledWaveTableSize // 2) ifTrue: [
		scaledOffsetIndexIncr _ scaledWaveTableSize // 2.
		multiplier _ scaledOffsetIndexIncr asFloat / scaledIndexIncr].
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:15'!
modulation
	"Return the FM modulation index."

	^ modulation
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:22'!
modulation: mod
	"Set the FM modulation index. Typical values range from 0 (no modulation) to 5, although values up to about 10 are sometimes useful."
	"Warning: This method is intended primarily for use by envelopes. For efficiency during envelope processing, this change will not take effect until internalizeModulationAndRatio is called."

	modulation _ mod asFloat.
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:39'!
modulation: mod multiplier: freqRatio
	"For backward compatibility. Needed to read old .fmp files."

	self modulation: mod ratio: freqRatio.
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:41'!
modulation: mod ratio: freqRatio
	"Set the modulation index and carrier to modulation frequency ratio for this sound, and compute the internal state that depends on these parameters."

	modulation _ mod asFloat.
	multiplier _ freqRatio asFloat.
	self internalizeModulationAndRatio.
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:05'!
multiplier

	^ multiplier
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!
pitch

	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:38'!
pitch: p
	"Warning: Since the modulation and ratio are relative to the current pitch, some internal state must be recomputed when the pitch is changed. However, for efficiency during envelope processing, this compuation will not be done until internalizeModulationAndRatio is called."

	scaledIndexIncr _
		((p asFloat * waveTable size asFloat * ScaleFactor asFloat) / self samplingRate asFloat) asInteger
			min: (waveTable size // 2) * ScaleFactor.
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:08'!
ratio
	"Return the FM modulation to carrier frequency ratio."

	^ multiplier
! !
!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:22'!
ratio: freqRatio
	"Set the FM modulation to carrier frequency ratio."
	"Warning: This method is intended primarily for use by envelopes. For efficiency during envelope processing, this change will not take effect until internalizeModulationAndRatio is called."

	multiplier _ freqRatio asFloat.
! !
!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44' overrides: 50603506!
initialize

	super initialize.
	waveTable _ SineTable.
	scaledWaveTableSize _ waveTable size * ScaleFactor.
	self setPitch: 440.0 dur: 1.0 loudness: 0.2.
! !
!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08' overrides: 50603539!
setPitch: pitchNameOrNumber dur: d loudness: vol
	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"

	super setPitch: pitchNameOrNumber dur: d loudness: vol.
	modulation ifNil: [modulation _ 0.0].
	multiplier ifNil: [multiplier _ 0.0].
	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).
	self reset.
! !
!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!
setWavetable: anArray
	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"

	| samples p dur vol |
	"copy the array into a SoundBuffer if necessary"
	anArray class isPointers
		ifTrue: [samples _ SoundBuffer fromArray: anArray]
		ifFalse: [samples _ anArray].

	p _ self pitch.
	dur _ self duration.
	vol _ self loudness.
	waveTable _ samples.
	scaledWaveTableSize _ waveTable size * ScaleFactor.
	self setPitch: p dur: dur loudness: vol.
! !
!FMSound methodsFor: 'sound generation' stamp: 'ar 2/3/2001 15:22' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."
	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"

	| doingFM lastIndex sample offset i s |
	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #waveTable declareC: 'short int *waveTable'.

	doingFM _ (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].
	lastIndex _ (startIndex + n) - 1.
	startIndex to: lastIndex do: [:sliceIndex |
		sample _ (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.
		doingFM
			ifTrue: [
				offset _ normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).
				scaledOffsetIndex _ (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.
				scaledOffsetIndex < 0
					ifTrue: [scaledOffsetIndex _ scaledOffsetIndex + scaledWaveTableSize].
				scaledIndex _ (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.
				scaledIndex < 0
					ifTrue: [scaledIndex _ scaledIndex + scaledWaveTableSize]]
			ifFalse: [
				scaledIndex _ (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].

		leftVol > 0 ifTrue: [
			i _ (2 * sliceIndex) - 1.
			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		rightVol > 0 ifTrue: [
			i _ 2 * sliceIndex.
			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].

		scaledVolIncr ~= 0 ifTrue: [
			scaledVol _ scaledVol + scaledVolIncr.
			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:
			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])
				ifTrue: [  "reached the limit; stop incrementing"
					scaledVol _ scaledVolLimit.
					scaledVolIncr _ 0]]].

	count _ count - n.
! !
!FMSound methodsFor: 'sound generation' stamp: 'jm 2/4/98 20:12' overrides: 50603394!
reset

	self internalizeModulationAndRatio.
	super reset.
	count _ initialCount.
	scaledIndex _ 0.
	scaledOffsetIndex _ 0.
! !
!FMSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 19:34' overrides: 50603405!
samplesRemaining

	^ count
! !
!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55' overrides: 50603414!
stopAfterMSecs: mSecs
	"Terminate this sound this note after the given number of milliseconds."

	count _ (mSecs * self samplingRate) // 1000.
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
bass1
	"FMSound bass1 play"
	"(FMSound lowMajorScaleOn: FMSound bass1) play"

	| snd |
	snd _ FMSound new modulation: 0 ratio: 0.
	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).
	^ snd setPitch: 220 dur: 1.0 loudness: 0.3
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 20:37'!
bassoon1
	"FMSound bassoon1 play"
	"(FMSound lowMajorScaleOn: FMSound bassoon1) play"

	| snd p env |
	snd _ FMBassoonSound new ratio: 1.

	p _ OrderedCollection new.
	p add: 0@0.0; add: 40@0.45; add: 90@1.0; add: 180@0.9; add: 270@1.0; add: 320@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).

	p _ OrderedCollection new.
	p add: 0@0.2; add: 40@0.9; add: 90@0.6; add: 270@0.6; add: 320@0.5.
	env _ Envelope points: p loopStart: 3 loopEnd: 4.
	env updateSelector: #modulation:; scale: 5.05.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
brass1
	"FMSound brass1 play"
	"(FMSound lowMajorScaleOn: FMSound brass1) play"

	| snd p env |
	snd _ FMSound new modulation: 0 ratio: 1.
	p _ OrderedCollection new.
	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).

	p _ OrderedCollection new.
	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.
	env _ Envelope points: p loopStart: 3 loopEnd: 5.
	env target: snd; updateSelector: #modulation:; scale: 5.0.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
brass2
	"FMSound brass2 play"
	"(FMSound lowMajorScaleOn: FMSound brass2) play"

	| snd p env |
	snd _ FMSound new modulation: 1 ratio: 1.

	p _ OrderedCollection new.
	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).

	p _ OrderedCollection new.
	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.
	env _ Envelope points: p loopStart: 3 loopEnd: 5.
	env updateSelector: #modulation:; scale: 5.0.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:10'!
clarinet
	"FMSound clarinet play"
	"(FMSound lowMajorScaleOn: FMSound clarinet) play"

	| snd p env |
	snd _ FMSound new modulation: 0 ratio: 2.

	p _ OrderedCollection new.
	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).

	p _ OrderedCollection new.
	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.
	env _ Envelope points: p loopStart: 2 loopEnd: 3.
	env updateSelector: #modulation:; scale: 10.0.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 10:20'!
clarinet2
	"FMSound clarinet2 play"
	"(FMSound lowMajorScaleOn: FMSound clarinet2) play"

	| snd p env |
	snd _ FMClarinetSound new modulation: 0 ratio: 2.

	p _ OrderedCollection new.
	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).

	p _ OrderedCollection new.
	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.
	env _ Envelope points: p loopStart: 2 loopEnd: 3.
	env updateSelector: #modulation:; scale: 10.0.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5

! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/5/98 17:35' overrides: 50604657!
default

	^ self oboe1
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!
flute1
	"FMSound flute1 play"
	"(FMSound majorScaleOn: FMSound flute1) play"

	| snd p |
	snd _ FMSound new.
	p _ OrderedCollection new.
	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!
flute2
	"FMSound flute2 play"
	"(FMSound majorScaleOn: FMSound flute2) play"

	| snd p |
	snd _ FMSound new.
	p _ OrderedCollection new.
	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).
	snd addEnvelope: (RandomEnvelope for: #pitch:).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 9/2/1999 13:32'!
marimba
	"FMSound marimba play"
	"(FMSound majorScaleOn: FMSound marimba) play"

	| snd p env |
	snd _ FMSound new modulation: 1 ratio: 0.98.

	p _ OrderedCollection new.
	p add: 0@1.0; add: 10@0.3; add: 40@0.1; add: 80@0.02; add: 120@0.1; add: 160@0.02; add: 220@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).

	p _ OrderedCollection new.
	p add: 0@1.2; add: 80@0.85; add: 120@1.0; add: 160@0.85; add: 220@0.0.
	env _ Envelope points: p loopStart: 2 loopEnd: 4.
	env updateSelector: #modulation:.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
mellowBrass
	"FMSound mellowBrass play"
	"(FMSound lowMajorScaleOn: FMSound mellowBrass) play"

	| snd p env |
	snd _ FMSound new modulation: 0 ratio: 1.

	p _ OrderedCollection new.
	p add: 0@0.0; add: 70@0.325; add: 120@0.194; add: 200@0.194; add: 320@0.194; add: 380@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).

	p _ OrderedCollection new.
	p add: 0@0.1; add: 70@0.68; add: 120@0.528; add: 200@0.519; add: 320@0.528; add: 380@0.0.
	env _ Envelope points: p loopStart: 3 loopEnd: 5.
	env updateSelector: #modulation:; scale: 5.0.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
oboe1
	"FMSound oboe1 play"
	"(FMSound majorScaleOn: FMSound oboe1) play"

	| snd p |
	snd _ FMSound new modulation: 1 ratio: 1.
	p _ OrderedCollection new.
	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!
oboe2
	"FMSound oboe2 play"
	"(FMSound majorScaleOn: FMSound oboe2) play"

	| snd p |
	snd _ FMSound new modulation: 1 ratio: 1.
	p _ OrderedCollection new.
	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).
	snd addEnvelope: (RandomEnvelope for: #pitch:).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:56'!
organ1
	"FMSound organ1 play"
	"(FMSound majorScaleOn: FMSound organ1) play"

	| snd p |
	snd _ FMSound new.
	p _ OrderedCollection new.
	p add: 0@0; add: 60@1.0; add: 110@0.8; add: 200@1.0; add: 250@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 9/1/1999 17:33'!
pluckedElecBass
	"FMSound pluckedElecBass play"
	"(FMSound lowMajorScaleOn: FMSound pluckedElecBass) play"

	| snd p env |
	snd _ FMSound new modulation: 1 ratio: 3.0.

	p _ OrderedCollection new.
	p add: 0@0.4; add: 20@1.0; add: 30@0.6; add: 100@0.6; add: 130@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 4).

	p _ OrderedCollection new.
	p add: 0@1.0; add: 20@2.0; add: 30@4.5; add: 100@4.5; add: 130@0.0.
	env _ Envelope points: p loopStart: 3 loopEnd: 4.
	env updateSelector: #modulation:.
	snd addEnvelope: env.

	p _ OrderedCollection new.
	p add: 0@6.0; add: 20@4.0; add: 30@3.0; add: 100@3.0; add: 130@3.0.
	env _ Envelope points: p loopStart: 3 loopEnd: 4.
	env updateSelector: #ratio:.
	snd addEnvelope: env.

	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!
randomWeird1
	"FMSound randomWeird1 play"

	| snd p |
	snd _ FMSound new.
	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).
	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.
	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).
	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5
! !
!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!
randomWeird2
	"FMSound randomWeird2 play"

	| snd |
	snd _ FMSound new.
	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).
	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).
	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5
! !
!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26' overrides: 50604876!
initialize
	"Build a sine wave table."
	"FMSound initialize"

	| tableSize radiansPerStep peak |
	tableSize _ 4000.
	SineTable _ SoundBuffer newMonoSampleCount: tableSize.
	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.
	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"
	1 to: tableSize do: [:i |
		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].
! !
!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!
sineTable
	"Answer a SoundBuffer containing one complete cycle of a sine wave."

	^ SineTable
! !
!FMBassoonSound methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 21:17' overrides: 50605037!
setPitch: pitchNameOrNumber dur: d loudness: l
	"Select a modulation ratio and modulation envelope scale based on my pitch."

	| p modScale |
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	modScale _ 9.4.
	p > 100.0 ifTrue: [modScale _ 8.3].
	p > 150.0 ifTrue: [modScale _ 6.4].
	p > 200.0 ifTrue: [modScale _ 5.2].
	p > 300.0 ifTrue: [modScale _ 3.9].
	p > 400.0 ifTrue: [modScale _ 2.8].
	p > 600.0 ifTrue: [modScale _ 1.7].

	envelopes size > 0 ifTrue: [
		envelopes do: [:e |
			(e updateSelector = #modulation:)
				ifTrue: [e scale: modScale]]].

	super setPitch: p dur: d loudness: l.
! !
!FMClarinetSound methodsFor: 'initialization' stamp: 'jm 5/30/1999 10:10' overrides: 50605037!
setPitch: pitchNameOrNumber dur: d loudness: l
	"Select a modulation ratio and modulation envelope scale based on my pitch."

	| p modScale |
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	p < 262.0
		ifTrue: [modScale _ 25.0. self ratio: 4]
		ifFalse: [modScale _ 20.0. self ratio: 2].
	p > 524.0 ifTrue: [modScale _ 8.0].

	envelopes size > 0 ifTrue: [
		envelopes do: [:e |
			(e updateSelector = #modulation:)
				ifTrue: [e scale: modScale]]].

	super setPitch: p dur: d loudness: l.
! !
!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 1/14/1999 12:00' overrides: 50605273!
default
	"UnloadedSound default play"

	| snd p |
	snd _ super new modulation: 1 ratio: 1.
	p _ OrderedCollection new.
	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.
	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).
	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5
! !
!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 4/8/1999 12:45' overrides: 16902743!
comeFullyUpOnReload: smartRefStream
	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."

	leftSamples == rightSamples
		ifTrue: [
			leftSamples _ SoundBuffer fromByteArray: self leftSamples.
			rightSamples _ leftSamples]
		ifFalse: [
			leftSamples _ SoundBuffer fromByteArray: self leftSamples.
			rightSamples _ SoundBuffer fromByteArray: self rightSamples].

! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 10/14/1998 16:04'!
addReleaseEnvelope
	"Add a simple release envelope to this sound."

	| p env |
	p _ OrderedCollection new.
	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.
	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.
	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"
		envelopes copy do: [:e |
			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].
	self addEnvelope: env.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!
computeSampleCountForRelease
	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."
	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."

	(scaledLoopLength > 0 and: [lastSample > loopEnd])
		ifTrue: [
			sampleCountForRelease _ (lastSample - loopEnd) +
				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]
		ifFalse: [sampleCountForRelease _ 0].

	releaseCount _ sampleCountForRelease.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 5/5/1999 20:59'!
fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag
	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."

	| aiffFileReader |
	aiffFileReader _ AIFFFileReader new.
	aiffFileReader readFromFile: fileName
		mergeIfStereo: mergeFlag
		skipDataChunk: false.
	aiffFileReader isLooped
		ifTrue: [
			self samples: aiffFileReader leftSamples
				loopEnd: aiffFileReader loopEnd
				loopLength: aiffFileReader loopLength
				pitch: aiffFileReader pitch
				samplingRate: aiffFileReader samplingRate]
		ifFalse: [
			self unloopedSamples: aiffFileReader leftSamples
				pitch: aiffFileReader pitch
				samplingRate: aiffFileReader samplingRate].

	"the following must be done second, since the initialization above sets
	 leftSamples and rightSamples to the same sample data"
	aiffFileReader isStereo
		ifTrue: [rightSamples _ aiffFileReader rightSamples].

	initialCount _ (leftSamples size * self samplingRate) // originalSamplingRate.
	self loudness: 1.0.

	self addReleaseEnvelope.
! !
!LoopedSampledSound methodsFor: 'initialization'!
fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag
	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."

	aiffFileReader isLooped
		ifTrue: [
			self samples: aiffFileReader leftSamples
				loopEnd: aiffFileReader loopEnd
				loopLength: aiffFileReader loopLength
				pitch: aiffFileReader pitch
				samplingRate: aiffFileReader samplingRate]
		ifFalse: [
			self unloopedSamples: aiffFileReader leftSamples
				pitch: aiffFileReader pitch
				samplingRate: aiffFileReader samplingRate].

	"the following must be done second, since the initialization above sets
	 leftSamples and rightSamples to the same sample data"
	aiffFileReader isStereo
		ifTrue: [rightSamples _ aiffFileReader rightSamples].

	initialCount _ (leftSamples size * self samplingRate) // originalSamplingRate.
	self loudness: 1.0.

	self addReleaseEnvelope.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43' overrides: 50603506!
initialize
	"This default initialization creates a loop consisting of a single cycle of a sine wave."
	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"

	| samples |
	super initialize.
	samples _ FMSound sineTable.
	self samples: samples
		loopEnd: samples size
		loopLength: samples size
		pitch: 1.0
		samplingRate: samples size.
	self addReleaseEnvelope.
	self setPitch: 440.0 dur: 1.0 loudness: 0.5.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!
samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz
	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."

	| loopStartIndex |
	super initialize.
	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.
	((1 <= loopStartIndex) and:
	 [loopStartIndex < loopEndIndex and:
	 [loopEndIndex <= aSoundBuffer size]])
		ifFalse: [self error: 'bad loop parameters'].

	leftSamples _ rightSamples _ aSoundBuffer.
	originalSamplingRate _ samplingRateInHz asFloat.
	perceivedPitch _ perceivedPitchInHz asFloat.
	gain _ 1.0.
	firstSample _ 1.
	lastSample _ leftSamples size.
	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [
		self error: 'cannot handle more than ',
			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].
	loopEnd _ loopEndIndex.
	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.
	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.
	self computeSampleCountForRelease.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09' overrides: 50603539!
setPitch: pitchNameOrNumber dur: d loudness: vol
	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"

	super setPitch: pitchNameOrNumber dur: d loudness: vol.
	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).
	self reset.
! !
!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!
unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz
	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."

	super initialize.
	leftSamples _ rightSamples _ aSoundBuffer.
	originalSamplingRate _ samplingRateInHz asFloat.
	perceivedPitchInHz
		ifNil: [perceivedPitch _ 100.0]
		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].
	gain _ 1.0.
	firstSample _ 1.
	lastSample _ leftSamples size.
	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [
		self error: 'cannot handle more than ',
			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].
	loopEnd _ leftSamples size.
	scaledLoopLength _ 0.  "zero length means unlooped"
	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.
	self computeSampleCountForRelease.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 5/31/1999 14:09'!
beUnlooped

	scaledLoopLength _ 0.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!
duration
	"Answer the duration of this sound in seconds."

	^ initialCount asFloat / self samplingRate asFloat
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36' overrides: 50603497!
duration: seconds

	super duration: seconds.
	count _ initialCount _ (seconds * self samplingRate) rounded.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!
firstSample

	^ firstSample
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!
firstSample: aNumber

	firstSample _ (aNumber asInteger max: 1) min: lastSample.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!
gain

	^ gain
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!
gain: aNumber

	gain _ aNumber asFloat.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!
isLooped

	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14' overrides: 50603579!
isStereo

	^ leftSamples ~~ rightSamples
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!
leftSamples

	^ leftSamples
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!
leftSamples: aSampleBuffer

	leftSamples _ aSampleBuffer.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!
loopEnd

	^ loopEnd
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!
loopLength

	^ scaledLoopLength / FloatLoopIndexScaleFactor
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26' overrides: 50603337!
originalSamplingRate

	^ originalSamplingRate
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:54'!
perceivedPitch

	^ perceivedPitch
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!
pitch

	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /
	  (originalSamplingRate * FloatLoopIndexScaleFactor)
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!
pitch: p

	scaledIndexIncr _
		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /
		 (perceivedPitch * self samplingRate asFloat)) asInteger.

	sampleCountForRelease > 0
		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]
		ifFalse: [releaseCount _ 0].
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!
rightSamples

	^ rightSamples
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!
rightSamples: aSampleBuffer

	rightSamples _ aSampleBuffer.
! !
!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 3/15/1999 08:01' overrides: 50603318!
samples
	"For compatability with SampledSound. Just return my left channel (which is the only channel if I am mono)."

	^ leftSamples
! !
!LoopedSampledSound methodsFor: 'other' stamp: 'jm 5/29/1999 18:56'!
findStartPointAfter: index
	"Answer the index of the last zero crossing sample before the given index."

	| i |
	i _ index min: lastSample.

	"scan backwards to the last zero-crossing"
	(leftSamples at: i) > 0
		ifTrue: [
			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]
		ifFalse: [
			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].
	^ i
! !
!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!
findStartPointForThreshold: threshold
	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."

	| i |
	i _ self indexOfFirstPointOverThreshold: threshold.
	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].

	"scan backwards to the last zero-crossing"
	(leftSamples at: i) > 0
		ifTrue: [
			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]
		ifFalse: [
			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].
	^ i
! !
!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!
indexOfFirstPointOverThreshold: threshold
	"Answer the index of the first sample whose absolute value exceeds the given threshold."

	| s |
	leftSamples == rightSamples
		ifTrue: [
			1 to: lastSample do: [:i |
				s _ leftSamples at: i.
				s < 0 ifTrue: [s _ 0 - s].
				s > threshold ifTrue: [^ i]]]
		ifFalse: [
			1 to: lastSample do: [:i |
				s _ leftSamples at: i.
				s < 0 ifTrue: [s _ 0 - s].
				s > threshold ifTrue: [^ i].
				s _ rightSamples at: i.
				s < 0 ifTrue: [s _ 0 - s].
				s > threshold ifTrue: [^ i]]].
	^ lastSample + 1
! !
!LoopedSampledSound methodsFor: 'sound generation' stamp: 'ar 2/3/2001 15:23' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."
	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"

	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |
	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #leftSamples declareC: 'short int *leftSamples'.
	self var: #rightSamples declareC: 'short int *rightSamples'.

	isInStereo _ leftSamples ~~ rightSamples.
	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.
	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.

	i _ (2 * startIndex) - 1.
	lastIndex _ (startIndex + n) - 1.
	startIndex to: lastIndex do: [:sliceIndex |
		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.
		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [
			"loop back if not within releaseCount of the note end"
			"note: unlooped sounds will have loopEnd = lastSample"
			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].
		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [
			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"
			scaledLoopLength = 0
				ifTrue: [nextSampleIndex _ sampleIndex]
				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].

		m _ scaledIndex bitAnd: LoopIndexFractionMask.
		rightVal _ leftVal _
			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +
			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.
		isInStereo ifTrue: [
			rightVal _
				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +
				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].

		leftVol > 0 ifTrue: [
			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		i _ i + 1.
		rightVol > 0 ifTrue: [
			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		i _ i + 1.

		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"
			scaledVol _ scaledVol + scaledVolIncr.
			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:
			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])
				ifTrue: [  "reached the limit; stop incrementing"
					scaledVol _ scaledVolLimit.
					scaledVolIncr _ 0].
			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.
			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].

	count _ count - n.
! !
!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38' overrides: 50603394!
reset

	super reset.
	count _ initialCount.
	scaledIndex _ firstSample * LoopIndexScaleFactor.
! !
!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31' overrides: 50603405!
samplesRemaining
	"Answer the number of samples remaining until the end of this sound."

	^ count
! !
!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57' overrides: 50603414!
stopAfterMSecs: mSecs
	"Terminate this sound this note after the given number of milliseconds."

	count _ (mSecs * self samplingRate) // 1000.
! !
!LoopedSampledSound methodsFor: 'file i/o' stamp: 'jmv 2/26/2016 16:05' overrides: 50603674!
storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."

	(self isStereo or: [self samplingRate ~= originalSamplingRate]) ifTrue: [
		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].

	"optimization: if I'm not stereo and sampling rates match, just store my buffer"
	(aBinaryStream isKindOf: StandardFileStream)
		ifTrue: [  "optimization for files: write sound buffer directly to file"
			aBinaryStream next: (leftSamples size // 2) putAll: leftSamples startingAt: 1]  "size in words"
		ifFalse: [  "for non-file streams:"
			1 to: leftSamples monoSampleCount do: [:i | aBinaryStream nextSignedInt16Put: (leftSamples at: i) bigEndian: bigEndianFlag ]]! !
!LoopedSampledSound class methodsFor: 'instance creation'!
fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag
	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."

	| aiffFileReader |
	aiffFileReader _ AIFFFileReader new.
	aiffFileReader readFromFile: fileName
		mergeIfStereo: mergeFlag
		skipDataChunk: false.
	self new fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag! !
!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!
samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz
	"See the comment in the instance method of this name."

	^ self basicNew
		samples: aSoundBuffer
		loopEnd: loopEndIndex
		loopLength: loopSampleCount
		pitch: perceivedPitchInHz
		samplingRate: samplingRateInHz
! !
!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!
unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz
	"See the comment in the instance method of this name."

	^ self basicNew
		unloopedSamples: aSoundBuffer
		pitch: perceivedPitchInHz
		samplingRate: samplingRateInHz
! !
!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54' overrides: 50604876!
initialize
	"LoopedSampledSound initialize"

	LoopIndexScaleFactor _ 512.
	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.
	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.
! !
!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:33'!
copySounds
	"Private!! Support for copying. Copy my component sounds and settings array."

	sounds _ sounds collect: [:s | s copy].
	leftVols _ leftVols copy.
	rightVols _ rightVols copy.
! !
!MixedSound methodsFor: 'composition' overrides: 50603069!
+ aSound
	"Return the mix of the receiver and the argument sound."

	^ self add: aSound
! !
!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!
add: aSound
	"Add the given sound with a pan setting of centered and no attenuation."

	self add: aSound pan: 0.5 volume: 1.0.
! !
!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!
add: aSound pan: leftRightPan
	"Add the given sound with the given left-right panning and no attenuation."

	self add: aSound pan: leftRightPan volume: 1.0.
! !
!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 17:33'!
add: aSound pan: leftRightPan volume: volume
	"Add the given sound with the given left-right pan, where 0.0 is full left, 1.0 is full right, and 0.5 is centered. The loudness of the sound will be scaled by volume, which ranges from 0 to 1.0."

	| pan vol |
	pan _ ((leftRightPan * ScaleFactor) asInteger max: 0) min: ScaleFactor.
	vol _ ((volume * ScaleFactor) asInteger max: 0) min: ScaleFactor.
	sounds _ sounds copyWith: aSound.
	leftVols _ leftVols copyWith: ((ScaleFactor - pan) * vol) // ScaleFactor.
	rightVols _ rightVols copyWith: (pan * vol) // ScaleFactor.
! !
!MixedSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40' overrides: 50603352!
doControl

	super doControl.
	1 to: sounds size do: [:i | (sounds at: i) doControl].
! !
!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 13:42' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."

	| snd left right |
	1 to: sounds size do: [:i |
		(soundDone at: i) ifFalse: [
			snd _ sounds at: i.
			left _ (leftVol * (leftVols at: i)) // ScaleFactor.
			right _ (rightVol * (rightVols at: i)) // ScaleFactor.
			snd samplesRemaining > 0
				ifTrue: [
					snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]
				ifFalse: [soundDone at: i put: true]]].
! !
!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:07' overrides: 50603394!
reset

	super reset.
	sounds do: [:snd | snd reset].
	soundDone _ (Array new: sounds size) atAllPut: false.
! !
!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:08' overrides: 50603405!
samplesRemaining

	| remaining r |
	remaining _ 0.
	1 to: sounds size do: [:i |
		r _ (sounds at: i) samplesRemaining.
		r > remaining ifTrue: [remaining _ r]].

	^ remaining
! !
!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/10/1999 08:45' overrides: 50603421!
stopGracefully
	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."

	super stopGracefully.
	sounds do: [:s | s stopGracefully].
! !
!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!
duration
	"Answer the duration of this sound in seconds."

	| dur |
	dur _ 0.
	sounds do: [:snd | dur _ dur max: snd duration].
	^ dur
! !
!MixedSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 20:23' overrides: 50603579!
isStereo

	^ true
! !
!MixedSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:37' overrides: 50603064!
sounds

	^ sounds
! !
!MixedSound methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:48' overrides: 50603506!
initialize

	super initialize.
	sounds _ #().
	leftVols _ #().
	rightVols _ #()! !
!PluckedSound methodsFor: 'copying' stamp: 'jm 11/4/97 08:25'!
copyRing
	"Private!! Support for copying"

	ring _ ring copy.
! !
!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!
duration
	"Answer the duration of this sound in seconds."

	^ initialCount asFloat / self samplingRate
! !
!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40' overrides: 50603497!
duration: seconds

	super duration: seconds.
	count _ initialCount _ (seconds * self samplingRate) rounded.
! !
!PluckedSound methodsFor: 'sound generation' stamp: 'ar 2/3/2001 15:23' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."
	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"

	| lastIndex scaledThisIndex scaledNextIndex average sample i s |
	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #ring declareC: 'short int *ring'.

	lastIndex _ (startIndex + n) - 1.
	scaledThisIndex _ scaledNextIndex _ scaledIndex.
	startIndex to: lastIndex do: [:sliceIndex |
		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.
		scaledNextIndex >= scaledIndexLimit
			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].
		average _
			((ring at: scaledThisIndex // ScaleFactor) +
			 (ring at: scaledNextIndex // ScaleFactor)) // 2.
		ring at: scaledThisIndex // ScaleFactor put: average.
		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"
		scaledThisIndex _ scaledNextIndex.

		leftVol > 0 ifTrue: [
			i _ (2 * sliceIndex) - 1.
			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		rightVol > 0 ifTrue: [
			i _ 2 * sliceIndex.
			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].

		scaledVolIncr ~= 0 ifTrue: [
			scaledVol _ scaledVol + scaledVolIncr.
			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:
			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])
				ifTrue: [  "reached the limit; stop incrementing"
					scaledVol _ scaledVolLimit.
					scaledVolIncr _ 0]]].

	scaledIndex _ scaledNextIndex.
	count _ count - n.
! !
!PluckedSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 21:35' overrides: 50603394!
reset
	"Fill the ring with random noise."

	| seed n |
	super reset.
	seed _ 17.
	n _ ring monoSampleCount.
	1 to: n do: [:i |
		seed _ ((seed * 1309) + 13849) bitAnd: 65535.
		ring at: i put: seed - 32768].
	count _ initialCount.
	scaledIndex _ ScaleFactor.
! !
!PluckedSound methodsFor: 'sound generation' stamp: 'jm 11/26/97 10:51' overrides: 50603405!
samplesRemaining

	^ count
! !
!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58' overrides: 50603414!
stopAfterMSecs: mSecs
	"Terminate this sound this note after the given number of milliseconds."

	count _ (mSecs * self samplingRate) // 1000.
! !
!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09' overrides: 50603539!
setPitch: pitchNameOrNumber dur: d loudness: vol

	| p sz |
	super setPitch: pitchNameOrNumber dur: d loudness: vol.
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	initialCount _ (d * self samplingRate asFloat) asInteger.
	ring _ SoundBuffer newMonoSampleCount:
		(((2.0 * self samplingRate) / p) asInteger max: 2).
	sz _ ring monoSampleCount.
	scaledIndexLimit _ (sz + 1) * ScaleFactor.
	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).
	self reset.
! !
!PluckedSound class methodsFor: 'instruments' stamp: 'jm 1/31/98 16:32' overrides: 50604657!
default
	"PluckedSound default play"
	"(AbstractSound majorScaleOn: PluckedSound default) play"

	| snd p env |
	snd _ PluckedSound new.
	p _ OrderedCollection new.
	p add: 0@1.0; add: 10@1.0; add: 20@0.0.
	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 2.
	env target: snd; scale: 0.3.
	^ snd
		addEnvelope: env;
		setPitch: 220 dur: 3.0 loudness: 0.3
! !
!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:52'!
add: aSound
	self sounds nextPut: aSound.
	^ aSound! !
!QueueSound methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:24'!
currentSound
	currentSound ifNil: [currentSound _ self nextSound].
	^ currentSound! !
!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 22:07'!
currentSound: aSound
	currentSound _ aSound! !
!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 22:07'!
done: aBoolean
	done _ aBoolean! !
!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:46' overrides: 50603064!
sounds
	^ sounds! !
!QueueSound methodsFor: 'accessing' stamp: 'len 9/26/1999 17:19'!
startTime
	^ startTime! !
!QueueSound methodsFor: 'accessing' stamp: 'len 9/26/1999 17:19'!
startTime: anInteger
	startTime _ anInteger! !
!QueueSound methodsFor: 'sound generation' stamp: 'jmv 3/2/2010 17:13' overrides: 50603352!
doControl
	super doControl.
	self currentSound ifNotNil: [self currentSound doControl]! !
!QueueSound methodsFor: 'sound generation' stamp: 'jmv 4/17/2013 12:08' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play a collection of sounds in sequence."

	| finalIndex i remaining count rate |
	self currentSound ifNil: [^ self].  "already done"
	self startTime > Time localMillisecondClock ifTrue: [^ self].
	rate _ self samplingRate.
	finalIndex _ (startIndex + n) - 1.
	i _ startIndex.
	[i <= finalIndex] whileTrue: [
		[
			self currentSound ifNil: [^ self].
			(remaining _ self currentSound samplesRemaining) <= 0]
				whileTrue: [self currentSound: self nextSound].
		count _ (finalIndex - i) + 1.
		remaining < count ifTrue: [count _ remaining].
		self currentSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.
		i _ i + count]! !
!QueueSound methodsFor: 'sound generation' stamp: 'len 11/30/1999 04:13'!
nextSound
	| answer |
	sounds isEmpty ifTrue: [^ nil].
	answer _ sounds next.
	answer reset.
	^ answer! !
!QueueSound methodsFor: 'sound generation' stamp: 'jmv 3/2/2010 17:13' overrides: 50603394!
reset
	super reset.
	self currentSound
		ifNotNil: [ self currentSound reset]
		ifNil: [ self currentSound: self nextSound]! !
!QueueSound methodsFor: 'sound generation' stamp: 'len 8/29/1999 22:13' overrides: 50603405!
samplesRemaining
	(done and: [self sounds isEmpty])
		ifTrue: [^ 0]
		ifFalse: [^ 1000000].
! !
!QueueSound methodsFor: 'initialization' stamp: 'jmv 4/17/2013 12:08' overrides: 50603506!
initialize
	super initialize.
	sounds _ SharedQueue new.
	done _ false.
	startTime _ Time localMillisecondClock! !
!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:34'!
copySound
	"Private!! Support for copying. Copy my component sound."

	sound _ sound copy.
! !
!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40' overrides: 50603352!
doControl

	super doControl.
	sound doControl.
! !
!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:05' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play a collection of sounds in sequence."
	"(RepeatingSound new
		setSound: FMSound majorScale
		iterations: 2) play"

	| i count samplesNeeded |
	iteration <= 0 ifTrue: [^ self].
	i _ startIndex.
	samplesNeeded _ n.
	[samplesNeeded > 0] whileTrue: [
		count _ sound samplesRemaining min: samplesNeeded.
		count = 0 ifTrue: [
			iterationCount == #forever
				ifFalse: [
					iteration _ iteration - 1.
					iteration <= 0 ifTrue: [^ self]].  "done"
			sound reset.
			count _ sound samplesRemaining min: samplesNeeded.
			count = 0 ifTrue: [^ self]].  "zero length sound"
		sound mixSampleCount: count
			into: aSoundBuffer
			startingAt: i
			leftVol: leftVol
			rightVol: rightVol.
		i _ i + count.
		samplesNeeded _ samplesNeeded - count].
! !
!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28' overrides: 50603394!
reset

	super reset.
	sound reset.
	samplesPerIteration _ sound samplesRemaining.
	iterationCount == #forever
		ifTrue: [iteration _ 1]
		ifFalse: [iteration _ iterationCount].
! !
!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 1/18/1999 10:31' overrides: 50603405!
samplesRemaining

	iterationCount == #forever ifTrue: [^ 1000000].
	iteration > 0
		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]
		ifFalse: [^ 0].
! !
!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!
iterationCount

	^ iterationCount
! !
!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!
iterationCount: aNumber

	iterationCount _ aNumber.
! !
!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!
sound

	^ sound
! !
!RepeatingSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:39'!
sound: aSound

	sound _ aSound.
! !
!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 15:54' overrides: 50603539!
setPitch: p dur: d loudness: l

	self error: 'RepeatingSounds do not support playing notes'.
! !
!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 16:39'!
setSound: aSound iterations: anIntegerOrSymbol
	"Initialize the receiver to play the given sound the given number of times. If iteration count is the symbol #forever, then repeat indefinitely."
	"(RepeatingSound repeat: AbstractSound scaleTest count: 2) play"
	"(RepeatingSound repeatForever: PluckedSound lowMajorScale) play"

	super initialize.
	sound _ aSound.
	iterationCount _ anIntegerOrSymbol.
	self reset.
! !
!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:14'!
repeat: aSound count: anInteger
	"Return a RepeatingSound that will repeat the given sound for the given number of iterations."

	^ self new setSound: aSound iterations: anInteger
! !
!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:13'!
repeatForever: aSound
	"Return a RepeatingSound that will repeat the given sound forever."

	^ self new setSound: aSound iterations: #forever
! !
!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!
duration
	"Answer the duration of this sound in seconds."

	^ initialCount asFloat / self samplingRate
! !
!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42' overrides: 50603497!
duration: seconds

	super duration: seconds.
	count _ initialCount _ (seconds * self samplingRate) rounded.
! !
!RestSound methodsFor: 'accessing' stamp: 'di 2/17/1999 21:09' overrides: 50603318!
samples
	^ SoundBuffer newMonoSampleCount: initialCount! !
!RestSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:04' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play silence for a given duration."
	"(RestSound dur: 1.0) play"

	count _ count - n.
! !
!RestSound methodsFor: 'sound generation' overrides: 50603394!
reset

	super reset.
	count _ initialCount.
! !
!RestSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:37' overrides: 50603405!
samplesRemaining

	^ count
! !
!RestSound methodsFor: 'initialization' stamp: 'jm 1/28/98 13:08'!
setDur: d
	"Set rest duration in seconds."

	initialCount _ (d * self samplingRate asFloat) rounded.
	count _ initialCount.
	self reset.
! !
!RestSound class methodsFor: 'instance creation' stamp: 'jm 3/31/1999 21:05' overrides: 50604666!
dur: d
	"Return a rest of the given duration."

	^ self new setDur: d
! !
!RestSound class methodsFor: 'instance creation' stamp: 'jm 12/15/97 22:38' overrides: 50604695!
pitch: p dur: d loudness: l
	"Return a rest of the given duration."
	"Note: This message allows one to silence one or more voices of a multi-voice piece by using RestSound as their instrument."

	^ self new setDur: d
! !
!ReverbSound methodsFor: 'copying' stamp: 'jmv 5/14/2015 09:53'!
copySound
	"Private!! Support for copying. Copy my component sound."

	sound _ sound copy.
	leftBuffer _ leftBuffer copy.
	rightBuffer _ rightBuffer copy.
! !
!ReverbSound methodsFor: 'private' stamp: 'ar 2/3/2001 15:55'!
applyReverbTo: aSoundBuffer startingAt: startIndex count: n

	| delayedLeft delayedRight i tapGain j out |
	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #tapDelays declareC: 'int *tapDelays'.
	self var: #tapGains declareC: 'int *tapGains'.
	self var: #leftBuffer declareC: 'short int *leftBuffer'.
	self var: #rightBuffer declareC: 'short int *rightBuffer'.

	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |
		delayedLeft _ delayedRight _ 0.
		1 to: tapCount do: [:tapIndex |
			i _ bufferIndex - (tapDelays at: tapIndex).
			i < 1 ifTrue: [i _ i + bufferSize].  "wrap"
			tapGain _ tapGains at: tapIndex.
			delayedLeft _ delayedLeft + (tapGain * (leftBuffer at: i)).
			delayedRight _ delayedRight + (tapGain * (rightBuffer at: i))].

		"left channel"
		j _ (2 * sliceIndex) - 1.
		out _ (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).
		out >  32767 ifTrue: [out _  32767].  "clipping!!"
		out < -32767 ifTrue: [out _ -32767].  "clipping!!"
		aSoundBuffer at: j put: out.
		leftBuffer at: bufferIndex put: out.

		"right channel"
		j _ j + 1.
		out _ (aSoundBuffer at: j) + (delayedRight // ScaleFactor).
		out >  32767 ifTrue: [out _  32767].  "clipping!!"
		out < -32767 ifTrue: [out _ -32767].  "clipping!!"
		aSoundBuffer at: j put: out.
		rightBuffer at: bufferIndex put: out.

		bufferIndex _ (bufferIndex \\ bufferSize) + 1].
! !
!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 14:32' overrides: 50603352!
doControl

	super doControl.
	sound doControl.
! !
!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 15:00' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play my sound with reberberation."

	sound mixSampleCount: n
		into: aSoundBuffer
		startingAt: startIndex
		leftVol: leftVol
		rightVol: rightVol.
	self applyReverbTo: aSoundBuffer startingAt: startIndex count: n.
! !
!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 16:47' overrides: 50603394!
reset

	super reset.
	sound reset.
	1 to: bufferSize do: [:i |
		leftBuffer at: i put: 0.
		rightBuffer at: i put: 0].
! !
!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 17:02' overrides: 50603405!
samplesRemaining

	^ sound samplesRemaining
! !
!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/7/98 22:41'!
sound

	^ sound
! !
!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/7/98 22:42'!
sound: aSound

	sound _ aSound.
! !
!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/27/98 19:10'!
tapDelays: delayList gains: gainList
	"ReverbSound new tapDelays: #(537 691 1191) gains: #(0.07 0.07 0.07)"

	| maxDelay gain d |
	delayList size = gainList size
		ifFalse: [self error: 'tap delay and gains lists must be the same size'].
	tapCount _ delayList size.
	tapDelays _ Bitmap new: tapCount.
	tapGains _ Bitmap new: tapCount.

	maxDelay _ 0.
	1 to: tapGains size do: [:i |
		tapDelays at: i put: (delayList at: i) asInteger.
		gain _ gainList at: i.
		gain >= 1.0 ifTrue: [self error: 'reverb tap gains must be under 1.0'].
		tapGains at: i put: (gain * ScaleFactor) asInteger.
		d _ tapDelays at: i.
		d > maxDelay ifTrue: [maxDelay _ d]].
	bufferSize _ maxDelay.
	leftBuffer _ SoundBuffer newMonoSampleCount: maxDelay.
	rightBuffer _ SoundBuffer newMonoSampleCount: maxDelay.
	bufferIndex _ 1.
! !
!SampledSound methodsFor: 'accessing' stamp: 'di 12/7/2000 16:04'!
compressWith: codecClass
	^ codecClass new compressSound: self! !
!SampledSound methodsFor: 'accessing' stamp: 'RAA 12/24/2000 08:49'!
compressWith: codecClass atRate: aSamplingRate

	^ codecClass new compressSound: self atRate: aSamplingRate! !
!SampledSound methodsFor: 'accessing' stamp: 'jm 3/28/98 05:46'!
duration

	^ initialCount asFloat / self samplingRate asFloat
! !
!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39' overrides: 50603497!
duration: seconds

	super duration: seconds.
	count _ initialCount _ (seconds * self samplingRate) rounded.
! !
!SampledSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:51' overrides: 50603337!
originalSamplingRate

	^ originalSamplingRate
! !
!SampledSound methodsFor: 'accessing' stamp: 'jm 9/12/97 16:46' overrides: 50603318!
samples

	^ samples
! !
!SampledSound methodsFor: 'playing' stamp: 'di 10/28/2000 17:08'!
endGracefully
	"See stopGracefully, which affects initialCOunt, and I don't think it should (di)."

	| decayInMs env |
	envelopes isEmpty
		ifTrue: [
			self adjustVolumeTo: 0 overMSecs: 10.
			decayInMs _ 10]
		ifFalse: [
			env _ envelopes first.
			decayInMs _ env attackTime + env decayTime].
	count _ decayInMs * self samplingRate // 1000.
! !
!SampledSound methodsFor: 'playing' stamp: 'ar 2/3/2001 15:23' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."

	| lastIndex outIndex sampleIndex sample i s overflow |
	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>
	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.
	self var: #samples declareC: 'short int *samples'.

	lastIndex _ (startIndex + n) - 1.
	outIndex _ startIndex.    "index of next stereo output sample pair"
	sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).
	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [
		sample _ ((samples at: sampleIndex) * scaledVol) // ScaleFactor.
		leftVol > 0 ifTrue: [
			i _ (2 * outIndex) - 1.
			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].
		rightVol > 0 ifTrue: [
			i _ 2 * outIndex.
			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).
			s >  32767 ifTrue: [s _  32767].  "clipping!!"
			s < -32767 ifTrue: [s _ -32767].  "clipping!!"
			aSoundBuffer at: i put: s].

		scaledVolIncr ~= 0 ifTrue: [
			scaledVol _ scaledVol + scaledVolIncr.
			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:
			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])
				ifTrue: [  "reached the limit; stop incrementing"
					scaledVol _ scaledVolLimit.
					scaledVolIncr _ 0]].

		scaledIndex _ scaledIndex + scaledIncrement.
		scaledIndex >= ScaledIndexOverflow ifTrue: [
			overflow _ scaledIndex >> IncrementFractionBits.
			indexHighBits _ indexHighBits + overflow.
			scaledIndex _ scaledIndex - (overflow << IncrementFractionBits)].

		sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).
		outIndex _ outIndex + 1].
	count _ count - n.
! !
!SampledSound methodsFor: 'playing' stamp: 'di 10/28/2000 22:31' overrides: 50603287!
playSilentlyUntil: startTime
	"Used to fast foward to a particular starting time.
	Overridden to be instant for sampled sounds."

"true ifTrue: [^ super playSilentlyUntil: startTime]."
	indexHighBits _ (startTime * originalSamplingRate) asInteger.
	scaledIndex _ IncrementScaleFactor.
	count _ initialCount - (startTime * self samplingRate).
	mSecsSinceStart _ (startTime * 1000) asInteger.

! !
!SampledSound methodsFor: 'playing' stamp: 'jm 7/9/1999 18:29' overrides: 50603394!
reset
	"Details: The sample index and increment are scaled to allow fractional increments without having to do floating point arithmetic in the inner loop."

	super reset.
	scaledIncrement _
		((originalSamplingRate asFloat / self samplingRate) * IncrementScaleFactor) rounded.
	count _ initialCount.
	scaledIndex _ IncrementScaleFactor.  "index of the first sample, scaled"
	indexHighBits _ 0.
! !
!SampledSound methodsFor: 'playing' stamp: 'jm 9/13/97 19:07' overrides: 50603405!
samplesRemaining

	^ count
! !
!SampledSound methodsFor: 'playing' stamp: 'RAA 8/12/2000 15:11'!
setScaledIncrement: aNumber

	scaledIncrement _ (aNumber * IncrementScaleFactor) rounded.

! !
!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58' overrides: 50603414!
stopAfterMSecs: mSecs
	"Terminate this sound this note after the given number of milliseconds."

	count _ (mSecs * self samplingRate) // 1000.
! !
!SampledSound methodsFor: 'initialization' stamp: 'jm 1/18/1999 06:42'!
pitch: pitchNameOrNumber

	| p |
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	originalSamplingRate _
		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.
	self reset.
! !
!SampledSound methodsFor: 'initialization' stamp: 'jm 3/24/1999 12:01' overrides: 50603539!
setPitch: pitchNameOrNumber dur: d loudness: vol
	"Used to play scores using the default sample table."
	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"

	| p |
	super setPitch: pitchNameOrNumber dur: d loudness: vol.
	p _ self nameOrNumberToPitch: pitchNameOrNumber.
	samples _ DefaultSampleTable.
	samplesSize _ samples size.
	initialCount _ (d * self samplingRate asFloat) rounded.
	originalSamplingRate _
		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.
	self loudness: vol.
	self reset.
! !
!SampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 19:23'!
setSamples: anArray samplingRate: rate
	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."
	"Note: There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSampleTable:)."
	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."
	"(SampledSound
		samples: SampledSound coffeeCupClink
		samplingRate: 5000) play"

	"copy the array into a SoundBuffer if necessary"
	anArray class isWords
		ifTrue: [samples _ anArray]
		ifFalse: [samples _ SoundBuffer fromArray: anArray].

	samplesSize _ samples size.
	samplesSize >= SmallInteger maxVal ifTrue: [  "this is unlikely..."
		self error: 'sample count must be under ',  SmallInteger maxVal printString].
	originalSamplingRate _ rate.
	initialCount _ (samplesSize * self samplingRate) // originalSamplingRate.
	self loudness: 1.0.
	self reset.
! !
!SampledSound methodsFor: 'file i/o' stamp: 'jmv 2/26/2016 16:05' overrides: 50603674!
storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."

	self samplingRate ~= originalSamplingRate ifTrue: [
		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].

	"optimization: if sampling rates match, just store my buffer"
	(aBinaryStream isKindOf: StandardFileStream)
		ifTrue: [  "optimization for files: write sound buffer directly to file"
			aBinaryStream next: (samples size // 2) putAll: samples startingAt: 1]  "size in words"
		ifFalse: [  "for non-file streams:"
			1 to: samples monoSampleCount do: [:i | aBinaryStream nextSignedInt16Put: (samples at: i) bigEndian: bigEndianFlag ]]! !
!SampledSound methodsFor: 'sound tracks' stamp: 'jmv 12/4/2012 23:42'!
volumeForm: height from: start to: stop nSamplesPerPixel: nPerPixel
	"Note: nPerPixel can be Integer or Float for pixel-perfect alignment."
	"In an inspector of a samplesSound...
		self currentWorld addMorph: (ImageMorph new image:
			(self volumeForm: 32 from: 1 to: samples size nSamplesPerPixel: 225))
	"
	| volPlot width sample min max vol |
	width _ stop-start//nPerPixel.
	volPlot _ Form extent: width@height.
	(start max: 1) to: (stop min: samples size)-nPerPixel by: nPerPixel do:
		[:i | min _ max _ 0.
		i asInteger to: (i+nPerPixel-1) asInteger by: 4 do:  "by: 4 makes it faster yet looks the same"
			[:j | sample _ samples at: j.
			sample < min ifTrue: [min _ sample].
			sample > max ifTrue: [max _ sample]].
		vol _ (max - min) * height // 65536.
		volPlot fillBlack: ((i-start//nPerPixel) @ (height-vol//2) extent: 1@(vol+1))].
	^ volPlot
	
! !
!SampledSound class methodsFor: 'sound library' stamp: 'jmv 6/17/2015 11:26'!
addLibrarySoundNamed: aString fromAIFFfileNamed: fileName
	"Add a sound from the given AIFF file to the library."
	"SampledSound
		addLibrarySoundNamed: 'shutterClick'
		fromAIFFfileNamed: '7.aif'"
	"Add all .aif files in the current directory to the sound library:
	| fileNames |
	fileNames _ FileDirectory smalltalkImageDirectory fileNamesMatching: '*.aif'.
	fileNames do: [:fName |
		SampledSound
			addLibrarySoundNamed: (fName copyUpTo: $.)
			fromAIFFfileNamed: fName]"

	| snd |
	snd _ self fromAIFFfileNamed: fileName.
	self addLibrarySoundNamed: aString
		samples: snd samples
		samplingRate: snd originalSamplingRate.
! !
!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:41'!
addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond
	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples. If the latter, it is taken to be 16 bit signed samples."

	SoundLibrary
		at: aString
		put: (Array with: sampleData with: samplesPerSecond).
! !
!SampledSound class methodsFor: 'sound library' stamp: 'sw 4/14/2003 00:01'!
assimilateSoundsFrom: aDictionary
	"assimilate sounds with new keys from the given dictionary"

	aDictionary associationsDo:
		[:assoc | (SoundLibrary includesKey: assoc key) ifFalse:
			[SoundLibrary add: assoc]]! !
!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:04'!
playSoundNamed: aString
	"Play the sound with given name. Do nothing if there is no sound of that name in the library."
	"SampledSound playSoundNamed: 'croak'"

	| snd |
	snd _ self soundNamed: aString.
	snd ifNotNil: [snd play].
	^ snd
! !
!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:40'!
putCoffeeCupClinkInSoundLibrary
	"SampledSound putCoffeeCupClinkInSoundLibrary"

	self addLibrarySoundNamed: 'clink'
		samples: self coffeeCupClink
		samplingRate: 11025! !
!SampledSound class methodsFor: 'sound library' stamp: 'jmv 3/2/2010 10:06'!
removeSoundNamed: aString
	"Remove the sound with the given name from the sound library."

	SoundLibrary removeKey: aString ifAbsent: nil! !
!SampledSound class methodsFor: 'sound library' stamp: 'sw 9/27/2001 14:46' overrides: 50604839!
soundNamed: aString
	"Answer the sound of the given name, or, if there is no sound of that name, put up an informer so stating, and answer nil"

	"(SampledSound soundNamed: 'shutterClick') play"

	^ self soundNamed: aString ifAbsent:
		[self inform: aString, ' not found in the Sound Library'.
		nil]! !
!SampledSound class methodsFor: 'sound library' stamp: 'sw 9/27/2001 14:45' overrides: 50604843!
soundNamed: aString ifAbsent: aBlock
	"Answer the sound of the given name, or if there is no sound of that name, answer the result of evaluating aBlock"
	"(SampledSound soundNamed: 'shutterClick') play"

	| entry samples |
	entry _ SoundLibrary
		at: aString
		ifAbsent:
			[^ aBlock value].
	entry ifNil: [^ aBlock value].
	samples _ entry at: 1.
	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].
	^ self samples: samples samplingRate: (entry at: 2)
! !
!SampledSound class methodsFor: 'sound library' stamp: 'jmv 1/16/2011 23:55' overrides: 50604855!
soundNames
	"Answer a list of sound names for the sounds stored in the sound library."
	"| s |
	 SampledSound soundNames asSortedCollection do: [:n |
		n asParagraph display.
		s _ SampledSound soundNamed: n.
		s ifNotNil: [s playAndWaitUntilDone]]"

	^ SoundLibrary keys! !
!SampledSound class methodsFor: 'sound library' stamp: 'jhm 10/15/97 14:57'!
unusedSoundNameLike: desiredName
	"Pick an unused sound name based on the given string. If necessary, append digits to avoid name conflicts with existing sounds."
	"SampledSound unusedSoundNameLike: 'chirp'"

	| newName i |
	newName _ desiredName.
	i _ 2.
	[SoundLibrary includesKey: newName] whileTrue: [
		newName _ desiredName, i printString.
		i _ i + 1].
	^ newName
! !
!SampledSound class methodsFor: 'instance creation' stamp: 'gk 2/24/2004 08:50'!
beep
	"Beep in the presence of the sound system.
	Not to be used directly - use Beeper class>>beep
	or Beeper class>>beepPrimitive instead."

	(self new
			setSamples: self coffeeCupClink
			samplingRate: 12000) play
			! !
!SampledSound class methodsFor: 'instance creation' stamp: 'jmv 6/17/2015 11:26'!
fromAIFFfileNamed: fileName
	"Read a SampledSound from the AIFF file of the given name, merging stereo to mono if necessary."
	"(SampledSound fromAIFFfileNamed: '1.aif') play"
	"| snd |
	 FileDirectory smalltalkImageDirectory fileNames do: [:n |
		(n endsWith: '.aif')
			ifTrue: [
				snd _ SampledSound fromAIFFfileNamed: n.
				snd play.
				SoundPlayer waitUntilDonePlaying: snd]]."

	| aiffFileReader |
	aiffFileReader _ AIFFFileReader new.
	aiffFileReader readFromFile: fileName
		mergeIfStereo: true
		skipDataChunk: false.
	^ self
		samples: (aiffFileReader channelData at: 1)
		samplingRate: aiffFileReader samplingRate
! !
!SampledSound class methodsFor: 'instance creation' stamp: 'jmv 7/21/2017 16:19:57'!
fromFileEntry: aFileEntry
	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"
	"| snd fd |
	fd := FileDirectory on:'c:\windows\media\'.
	fd fileNames do: [:n |
		(n asLowercase endsWith: '.wav')
			ifTrue: [
				snd _ SampledSound fromWaveFileNamed: (fd pathName,n).
				snd play.
				SoundPlayer waitUntilDonePlaying: snd]]."

	^ aFileEntry readStreamDo: [ :strm |
		self fromWaveStream: strm ]
! !
!SampledSound class methodsFor: 'instance creation' stamp: 'pb 5/25/2016 01:33'!
fromWaveFileNamed: fileName
	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"
	"| snd fd |
	fd := FileDirectory on:'c:\windows\media\'.
	fd fileNames do: [:n |
		(n asLowercase endsWith: '.wav')
			ifTrue: [
				snd _ SampledSound fromWaveFileNamed: (fd pathName,n).
				snd play.
				SoundPlayer waitUntilDonePlaying: snd]]."

	^ fileName asFileEntry readStreamDo: [ :strm |
		self fromWaveStream: strm ]
! !
!SampledSound class methodsFor: 'instance creation'!
fromWaveStream: fileStream

	| stream header data type channels samplingRate blockAlign bitsPerSample leftAndRight |
	header _ self readWaveChunk: 'fmt ' inRIFF: fileStream.
	data _ self readWaveChunk: 'data' inRIFF: fileStream.
	fileStream close.
	stream _ ReadStream on: header.
	type _ self next16BitWord: false from: stream.
	type = 1 ifFalse: [^ self error:'Unexpected wave format'].
	channels _ self next16BitWord: false from: stream.
	(channels < 1 or: [channels > 2])
		ifTrue: [^ self error: 'Unexpected number of wave channels'].
	samplingRate _ self next32BitWord: false from: stream.
	stream skip: 4. "skip average bytes per second"
	blockAlign _ self next16BitWord: false from: stream.
	bitsPerSample _ self next16BitWord: false from: stream.
	(bitsPerSample = 8 or: [bitsPerSample = 16])
		ifFalse: [  "recompute bits per sample"
			bitsPerSample _ (blockAlign // channels) * 8].

	bitsPerSample = 8
		ifTrue: [data _ self convert8bitUnsignedTo16Bit: data]
		ifFalse: [data _ self convertBytesTo16BitSamples: data mostSignificantByteFirst: false].

	channels = 2 ifTrue: [
		leftAndRight _ data splitStereo.
		^ MixedSound new
			add: (self samples: leftAndRight first samplingRate: samplingRate) pan: 0.0;
			add: (self samples: leftAndRight last samplingRate: samplingRate) pan: 1.0;
			yourself].

	^ self samples: data samplingRate: samplingRate
! !
!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 19:20'!
samples: anArrayOf16BitSamples samplingRate: samplesPerSecond
	"Return a SampledSound with the given samples array and sampling rate."

	^ self new setSamples: anArrayOf16BitSamples samplingRate: samplesPerSecond
! !
!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 8/23/97 22:25'!
coffeeCupClink
	"Return the samples array for the sound of a spoon being tapped against a coffee cup."

	CoffeeCupClink ifNil: [self initializeCoffeeCupClink].
	^ CoffeeCupClink
! !
!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 9/17/97 12:50'!
initializeCoffeeCupClink
	"Initialize the samples array for the sound of a spoon being tapped against a coffee cup."
	"SampledSound initializeCoffeeCupClink"

	| samples |
	samples _ #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256).

	CoffeeCupClink _ SoundBuffer fromArray: samples.
! !
!SampledSound class methodsFor: 'utilities' stamp: 'ar 2/3/2001 16:14'!
convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer
	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."

	| n s |
	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>
	self var: #aByteArray declareC: 'unsigned char *aByteArray'.
	self var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'.
	n _ aByteArray size.
	1 to: n do: [:i |
		s _ aByteArray at: i.
		s > 127
			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]
			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 2/15/98 18:13'!
convert8bitSignedTo16Bit: aByteArray
	"Convert the given array of samples--assumed to be 8-bit signed, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed AIFF sound data."

	| result |
	result _ SoundBuffer newMonoSampleCount: aByteArray size.
	self convert8bitSignedFrom: aByteArray to16Bit: result.
	^ result
! !
!SampledSound class methodsFor: 'utilities' stamp: 'ar 1/27/98 23:11'!
convert8bitUnsignedTo16Bit: anArray
	"Convert the given array of samples--assumed to be 8-bit unsigned, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed WAVE sound data."

	| n samples s |
	n _ anArray size.
	samples _ SoundBuffer newMonoSampleCount: n.
	1 to: n do: [:i |
		s _ anArray at: i.
		samples at: i put: (s - 128 * 256)].
	^ samples
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 3/17/98 21:07'!
convertBytesTo16BitSamples: aByteArray mostSignificantByteFirst: msbFirst
	"Convert the given ByteArray (with the given byte ordering) into 16-bit sample buffer."

	| n data src b1 b2 w |
	n _ aByteArray size // 2.
	data _ SoundBuffer newMonoSampleCount: n.
	src _ 1.
	1 to: n do: [:i |
		b1 _ aByteArray at: src.
		b2 _ aByteArray at: src + 1.
		msbFirst
			ifTrue: [w _ (b1 bitShift: 8) + b2]
			ifFalse: [w _ (b2 bitShift: 8) + b1].
		w > 32767 ifTrue: [w _ w - 65536].
		data at: i put: w.
		src _ src + 2].
	^ data
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/17/97 13:11'!
uLawDecode: aByteArray
	"Convert the given array of uLaw-encoded 8-bit samples into a SoundBuffer of 16-bit signed samples."

	| n out decodingTable |
	n _ aByteArray size.
	out _ SoundBuffer newMonoSampleCount: n.
	decodingTable _ self uLawDecodeTable.
	1 to: n do: [:i | out at: i put: (decodingTable at: (aByteArray at: i) + 1)].
	^ out
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 16:41'!
uLawDecodeTable
	"Return a 256 entry table to be used to decode 8-bit uLaw-encoded samples."
	"Details: This table was computed as follows:
		| d encoded lastEncodedPos lastEncodedNeg |
		d _ Array new: 256.
		lastEncodedPos _ nil.
		lastEncodedNeg _ nil.
		4095 to: 0 by: -1 do: [:s |
			encoded _ SampledSound uLawEncodeSample: s.
			lastEncodedPos = encoded
				ifFalse: [
					d at: (encoded + 1) put: (s bitShift: 3).
					lastEncodedPos _ encoded].
			encoded _ encoded bitOr: 16r80.
			lastEncodedNeg = encoded
				ifFalse: [
					d at: (encoded + 1) put: (s bitShift: 3) negated.
					lastEncodedNeg _ encoded]].
		d "

	^ #(32760 31608 30584 29560 28536 27512 26488 25464 24440 23416 22392 21368 20344 19320 18296 17272 16248 15736 15224 14712 14200 13688 13176 12664 12152 11640 11128 10616 10104 9592 9080 8568 8056 7800 7544 7288 7032 6776 6520 6264 6008 5752 5496 5240 4984 4728 4472 4216 3960 3832 3704 3576 3448 3320 3192 3064 2936 2808 2680 2552 2424 2296 2168 2040 1912 1848 1784 1720 1656 1592 1528 1464 1400 1336 1272 1208 1144 1080 1016 952 888 856 824 792 760 728 696 664 632 600 568 536 504 472 440 408 376 360 344 328 312 296 280 264 248 232 216 200 184 168 152 136 120 112 104 96 88 80 72 64 56 48 40 32 24 16 8 0 -32760 -31608 -30584 -29560 -28536 -27512 -26488 -25464 -24440 -23416 -22392 -21368 -20344 -19320 -18296 -17272 -16248 -15736 -15224 -14712 -14200 -13688 -13176 -12664 -12152 -11640 -11128 -10616 -10104 -9592 -9080 -8568 -8056 -7800 -7544 -7288 -7032 -6776 -6520 -6264 -6008 -5752 -5496 -5240 -4984 -4728 -4472 -4216 -3960 -3832 -3704 -3576 -3448 -3320 -3192 -3064 -2936 -2808 -2680 -2552 -2424 -2296 -2168 -2040 -1912 -1848 -1784 -1720 -1656 -1592 -1528 -1464 -1400 -1336 -1272 -1208 -1144 -1080 -1016 -952 -888 -856 -824 -792 -760 -728 -696 -664 -632 -600 -568 -536 -504 -472 -440 -408 -376 -360 -344 -328 -312 -296 -280 -264 -248 -232 -216 -200 -184 -168 -152 -136 -120 -112 -104 -96 -88 -80 -72 -64 -56 -48 -40 -32 -24 -16 -8 0)
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:52'!
uLawEncode: anArray
	"Convert the given array of 16-bit signed samples into a ByteArray of uLaw-encoded 8-bit samples."

	| n out s |
	n _ anArray size.
	out _ ByteArray new: n.
	1 to: n do: [:i |
		s _ anArray at: i.
		s _ s bitShift: -3.  "drop 4 least significant bits"
		s < 0
			ifTrue: [s _ (self uLawEncodeSample: s negated) bitOr: 16r80]
			ifFalse: [s _ (self uLawEncodeSample: s)].
		out at: i put: s].
	^ out
! !
!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:40'!
uLawEncodeSample: s
	"Encode the given 16-bit signed sample using the uLaw 8-bit encoding."

	s < 496 ifTrue: [
		s < 112 ifTrue: [
			s < 48 ifTrue: [
				s < 16
					ifTrue: [^ 16r70 bitOr: (15 - s)]
					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].
			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].
		s < 240
			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]
			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].

	s < 2032 ifTrue: [
		s < 1008
			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]
			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].

	s < 4080
		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]
		ifFalse: [^ 0].
! !
!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 12:49'!
defaultSampleTable: anArray
	"Set the sample table to be used as the default waveform for playing a score such as the Bach fugue. Array is assumed to contain monaural signed 16-bit sample values."

	DefaultSampleTable _ SoundBuffer fromArray: anArray.
! !
!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 13:10'!
defaultSamples: anArray repeated: n

	| data |
	data _ WriteStream on: (SoundBuffer newMonoSampleCount: anArray size * n).
	n timesRepeat: [
		anArray do: [:sample | data nextPut: sample truncated]].
	DefaultSampleTable _ data contents.
! !
!SampledSound class methodsFor: 'default sound'!
nominalSamplePitch: aNumber
	"Record an estimate of the normal pitch of the sampled sound."

	NominalSamplePitch _ aNumber.
! !
!SampledSound class methodsFor: 'default sound' stamp: 'jm 5/8/1998 18:53'!
useCoffeeCupClink
	"Set the sample table to be used as the default waveform to the sound of a coffee cup being tapped with a spoon."
	"SampledSound useCoffeeCupClink bachFugue play"

	DefaultSampleTable _ self coffeeCupClink.
	NominalSamplePitch _ 400.
! !
!SampledSound class methodsFor: 'class initialization' stamp: 'jmv 6/16/2013 12:36' overrides: 50604876!
initialize
	"SampledSound initialize"

	SoundPlayer initialize.
	IncrementFractionBits _ 16.
	IncrementScaleFactor _ 2 raisedTo: IncrementFractionBits.
	ScaledIndexOverflow _ 2 raisedTo: 29.  "handle overflow before needing LargePositiveIntegers"
	self useCoffeeCupClink.
	SoundLibrary ifNil: [SoundLibrary _ Dictionary new].
	Beeper setDefault: (self new
						setSamples: self coffeeCupClink
						samplingRate: 12000).
! !
!SampledSound class methodsFor: 'WAV reading' stamp: 'ar 1/27/98 23:06'!
next16BitWord: msbFirst from: stream
	"Read a 16-bit positive integer from the input stream."
	"Assume: Stream has at least two bytes left."

	| n |
	n _ stream next: 2.
	^msbFirst
		ifTrue:[(n at: 1) * 256 + (n at: 2)]
		ifFalse:[(n at: 2) * 256 + (n at: 1)]
! !
!SampledSound class methodsFor: 'WAV reading' stamp: 'ar 1/27/98 23:06'!
next32BitWord: msbFirst from: stream
	"Read a 32-bit positive integer from the input stream."
	"Assume: Stream has at least four bytes left."

	| n |
	n _ stream next: 4.
	^msbFirst
		ifTrue:[(n at: 1) * 256 + (n at: 2) * 256 + (n at: 3) * 256 + (n at: 4)]
		ifFalse:[(n at: 4) * 256 + (n at: 3) * 256 + (n at: 2) * 256 + (n at: 1)]
! !
!SampledSound class methodsFor: 'WAV reading' stamp: 'jm 3/17/98 21:03'!
readWaveChunk: chunkType inRIFF: stream
	"Search the stream for a format chunk of the given type and return its contents."

	| id count |
	stream reset; binary.
	stream skip: 8.  "skip 'RIFF' and total length"
	id _ (stream next: 4) asString.  "contents type"
	id = 'WAVE' ifFalse: [^ ''].     "content type must be WAVE"

	"search for a chunk of the given type"
	[id _ (stream next: 4) asString.
	 count _ self next32BitWord: false from: stream.
	 id = chunkType] whileFalse: [
		"skip this chunk, rounding length up to a word boundary"
		stream skip: (count + 1 bitAnd: 16rFFFFFFFE).
		stream atEnd ifTrue: [^ '']].

	^ stream next: count  "return raw chunk data"
! !
!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:48'!
copySounds
	"Private!! Support for copying. Copy my component sounds."

	sounds _ sounds collect: [:s | s copy].
! !
!SequentialSound methodsFor: 'copying' stamp: 'jmv 8/5/2011 16:00'!
transformSounds: tfmBlock
	"Private!! Support for copying. Copy my component sounds."

	sounds _ sounds collect: tfmBlock! !
!SequentialSound methodsFor: 'composition' overrides: 50603074!
, aSound
	"Return the concatenation of the receiver and the argument sound."

	^ self add: aSound
! !
!SequentialSound methodsFor: 'composition' stamp: 'jm 12/15/97 22:48'!
add: aSound

	sounds _ sounds copyWith: aSound.
! !
!SequentialSound methodsFor: 'composition' stamp: 'di 12/7/2000 16:03'!
compressWith: codecClass
	^ self copy transformSounds: [:s | s compressWith: codecClass]! !
!SequentialSound methodsFor: 'composition' stamp: 'RAA 12/24/2000 08:42'!
compressWith: codecClass atRate: aSamplingRate
	^ self copy transformSounds: [:s | s compressWith: codecClass atRate: aSamplingRate]! !
!SequentialSound methodsFor: 'composition' stamp: 'jm 4/14/1999 10:05'!
pruneFinishedSounds
	"Remove any sounds that have been completely played."

	| newSnds |
	(currentIndex > 1 and: [currentIndex < sounds size]) ifFalse: [^ self].
	newSnds _ sounds copyFrom: currentIndex to: sounds size.
	currentIndex _ 1.
	sounds _ newSnds.
! !
!SequentialSound methodsFor: 'composition' stamp: 'RAA 8/9/2000 16:27'!
removeFirstCompleteSoundOrNil
	"Remove the first sound if it has been completely recorded."

	| firstSound |

	sounds size > 0 ifFalse: [^ nil].
	firstSound _ sounds first.
	sounds _ sounds copyFrom: 2 to: sounds size.
	^firstSound
! !
!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:41' overrides: 50603352!
doControl

	super doControl.
	currentIndex > 0
		ifTrue: [(sounds at: currentIndex) doControl].
! !
!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:16' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play a collection of sounds in sequence."
	"PluckedSound chromaticScale play"

	| finalIndex i snd remaining count |
	currentIndex = 0 ifTrue: [^ self].  "already done"
	finalIndex _ (startIndex + n) - 1.
	i _ startIndex.
	[i <= finalIndex] whileTrue: [
		snd _ (sounds at: currentIndex).
		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [
			"find next undone sound"
			currentIndex < sounds size
				ifTrue: [
					currentIndex _ currentIndex + 1.
					snd _ (sounds at: currentIndex)]
				ifFalse: [
					currentIndex _ 0.
					^ self]].  "no more sounds"
		count _ (finalIndex - i) + 1.
		remaining < count ifTrue: [count _ remaining].
		snd mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.
		i _ i + count].
! !
!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47' overrides: 50603394!
reset

	super reset.
	sounds do: [:snd | snd reset].
	sounds size > 0 ifTrue: [currentIndex _ 1].
! !
!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47' overrides: 50603405!
samplesRemaining

	currentIndex = 0
		ifTrue: [^ 0]
		ifFalse: [^ 1000000].
! !
!SequentialSound methodsFor: 'accessing' stamp: 'RAA 12/7/2000 17:24'!
duration
	"Answer the duration of this sound in seconds."

	"7 dec 2000 - handle compressed sounds. better way??"

	| dur |
	dur _ 0.
	sounds do: [:snd | dur _ dur + snd asSound duration].
	^ dur
! !
!SequentialSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:36' overrides: 50603064!
sounds

	^ sounds
! !
!SequentialSound methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:49' overrides: 50603506!
initialize

	super initialize.
	sounds _ #().
	currentIndex _ 0.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 10/18/2001 15:51'!
createMixer
	"Create a mixed sound consisting of sampled sounds with one sound buffer's worth of samples."

	| snd |
	mixer _ MixedSound new.
	snd _ SampledSound
		samples: (SoundBuffer newMonoSampleCount: 2)  "buffer size will be adjusted dynamically"
		samplingRate: streamSamplingRate.
	mixer add: snd pan: 0.5 volume: volume.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 09:05'!
currentSampleIndex
	"Answer the index of the current sample."

	| bytePosition frameIndex |
	bytePosition _ stream position - audioDataStart.
	codec
		ifNil: [^ bytePosition // 2]
		ifNotNil: [
			frameIndex _ bytePosition // codec bytesPerEncodedFrame.
			^ (frameIndex * codec samplesPerFrame) - leftoverSamples monoSampleCount].
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 11:37'!
loadBuffer: aSoundBuffer compressedSampleCount: sampleCount
	"Load the given sound buffer from the compressed sample stream."
	"Details: Most codecs decode in multi-sample units called 'frames'. Since the requested sampleCount is typically not an even multiple of the frame size, we need to deal with partial frames. The unused samples from a partial frame are retained until the next call to this method."

	| n samplesNeeded frameCount encodedBytes r decodedCount buf j |
	"first, use any leftover samples"
	n _ self loadFromLeftovers: aSoundBuffer sampleCount: sampleCount.
	samplesNeeded _ sampleCount - n.
	samplesNeeded <= 0 ifTrue: [^ self].

	"decode an integral number of full compression frames"
	frameCount _ samplesNeeded // codec samplesPerFrame.
	encodedBytes _ stream next: (frameCount * codec bytesPerEncodedFrame).
	r _ codec decodeFrames: frameCount from: encodedBytes at: 1 into: aSoundBuffer at: n + 1.
	decodedCount _ r last.
	decodedCount >= samplesNeeded ifTrue: [^ self].

	"decode one last compression frame to finish filling the buffer"
	buf _ SoundBuffer newMonoSampleCount: codec samplesPerFrame.
	encodedBytes _ stream next: codec bytesPerEncodedFrame.
	codec decodeFrames: 1 from: encodedBytes at: 1 into: buf at: 1.
	j _ 0.
	(n + decodedCount + 1) to: sampleCount do: [:i |
		aSoundBuffer at: i put: (buf at: (j _ j + 1))].

	"save the leftover samples"
	leftoverSamples _ buf copyFrom: (j + 1) to: buf monoSampleCount.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jmv 2/26/2016 16:03'!
loadBuffer: aSoundBuffer uncompressedSampleCount: sampleCount
	"Load the given sound buffer from the uncompressed sample stream."

	"read directly into the sample buffer; count is in 32-bit words"
	stream next: sampleCount // 2 into: aSoundBuffer startingAt: 1.
	aSoundBuffer restoreEndianness.

	"read the final sample if sampleCount is odd:"
	sampleCount odd ifTrue: [aSoundBuffer at: sampleCount put: (stream nextSignedInt16BigEndian: true)].
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 08:02'!
loadBuffersForSampleCount: count
	"Load the sound buffers from the stream."

	| snd buf sampleCount |
	snd _ mixer sounds first.
	buf _ snd samples.
	buf monoSampleCount = count ifFalse: [
		buf _ SoundBuffer newMonoSampleCount: count.
		snd setSamples: buf samplingRate: streamSamplingRate].
	sampleCount _ count min: (totalSamples - self currentSampleIndex).
	sampleCount < count ifTrue: [buf primFill: 0].

	codec
		ifNil: [self loadBuffer: buf uncompressedSampleCount: sampleCount]
		ifNotNil: [self loadBuffer: buf compressedSampleCount: sampleCount].

	mixer reset.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 09:09'!
loadFromLeftovers: aSoundBuffer sampleCount: sampleCount
	"Load the given sound buffer from the samples leftover from the last frame. Answer the number of samples loaded, which typically is less than sampleCount."

	| leftoverCount n |
	leftoverCount _ leftoverSamples monoSampleCount.
	leftoverCount = 0 ifTrue: [^ 0].

	n _ leftoverCount min: sampleCount.
	1 to: n do: [:i | aSoundBuffer at: i put: (leftoverSamples at: i)].
	n < sampleCount
		ifTrue: [leftoverSamples _ SoundBuffer new]
		ifFalse: [leftoverSamples _ leftoverSamples copyFrom: n + 1 to: leftoverSamples size].
	^ n
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'pb 5/25/2016 01:51'!
positionCodecTo: desiredSampleIndex
	"Position to the closest frame before the given sample index when using a codec. If using the ADPCM codec, try to ensure that it is in sync with the compressed sample stream."

	| desiredFrameIndex desiredPosition tmpStream tmpCodec byteBuf bufFrames sampleBuf frameCount n startOffset |
	(codec isKindOf: ADPCMCodec) ifFalse: [
		"stateless codecs (or relatively stateless ones, like GSM: just jump to frame boundary"
		desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.
		stream position: audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).
		codec reset.
		^ self].

	"compute the desired stream position"
	desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.
	desiredPosition _ audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).

	"copy stream and codec"
	(stream isKindOf: FileStream)
		ifTrue: [tmpStream _ (stream name asFileEntry readStream ) binary]
		ifFalse: [tmpStream _ "stream deepCopy" stream contents readStream].	"To kill #deepCopy. Not sure if right, though (jmv)"
	tmpCodec _ codec copy reset.

	"reset the codec and start back about 30 seconds to try to get codec in sync"
	startOffset _ ((desiredFrameIndex - 80000) max: 0) * codec bytesPerEncodedFrame.
	tmpStream position: audioDataStart + startOffset.

	"decode forward to the desired position"
	byteBuf _ ByteArray new: (32000 roundTo: codec bytesPerEncodedFrame).
	bufFrames _ byteBuf size // codec bytesPerEncodedFrame.
	sampleBuf _ SoundBuffer newMonoSampleCount: bufFrames * codec samplesPerFrame.
	frameCount _ (desiredPosition - tmpStream position) // codec bytesPerEncodedFrame.
	[frameCount > 0] whileTrue: [
		n _ bufFrames min: frameCount.
		tmpStream next: n * codec bytesPerEncodedFrame into: byteBuf startingAt: 1.
		tmpCodec decodeFrames: n from: byteBuf at: 1 into: sampleBuf at: 1.
		frameCount _ frameCount - n].

	codec _ tmpCodec.
	stream position: tmpStream position.
	(tmpStream isKindOf: FileStream) ifTrue: [tmpStream close].! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/16/2001 10:23'!
readAIFFHeader
	"Read an AIFF file header from stream."

	| aiffReader |
	aiffReader _ AIFFFileReader new.
	aiffReader readFromStream: stream mergeIfStereo: false skipDataChunk: true.
	aiffReader channelCount = 1 ifFalse: [self error: 'not monophonic'].
	aiffReader bitsPerSample = 16 ifFalse: [self error: 'not 16-bit'].

	audioDataStart _ headerStart + aiffReader channelDataOffset.
	streamSamplingRate _ aiffReader samplingRate.
	totalSamples _ aiffReader frameCount min: (stream size - audioDataStart) // 2.
	codec _ nil.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jmv 10/5/2015 12:12'!
readHeader
	"Read the sound file header from my stream."

	| id |
	stream position: headerStart.
	id _ (stream next: 4) asString.
	stream position: headerStart.
	id = 'FORM' ifTrue: [^ self readAIFFHeader].
	self error: 'unrecognized sound file format'.
! !
!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/27/2001 07:36'!
startOver
	"Jump back to the first sample."

	stream reopen; binary.
	self readHeader.
	stream position: audioDataStart.
	leftoverSamples _ SoundBuffer new.
	lastBufferMSecs _ 0.
	mutex _ Semaphore forMutualExclusion.
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:12'!
duration
	"Answer the duration of this sound in seconds."

	^ totalSamples asFloat / streamSamplingRate
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 10/18/2001 15:46'!
repeat
	"Answer the repeat flag."

	^ repeat
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 6/3/2001 18:39'!
repeat: aBoolean
	"Set the repeat flag. If true, this sound will loop back to the beginning when it gets to the end."

	repeat _ aBoolean.
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:05'!
soundPosition
	"Answer the relative position of sound playback as a number between 0.0 and 1.0."

	(stream isNil or: [stream closed]) ifTrue: [^ 0.0].
	^ self currentSampleIndex asFloat / totalSamples
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 12/14/2001 11:29'!
soundPosition: fraction
	"Jump to the position the given fraction through the sound file. The argument is a number between 0.0 and 1.0."

	| desiredSampleIndex |
	(stream isNil or: [stream closed]) ifTrue: [^ self].
	desiredSampleIndex _ ((totalSamples * fraction) truncated max: 0) min: totalSamples.
	codec
		ifNil: [stream position: audioDataStart + (desiredSampleIndex * 2)]
		ifNotNil: [self positionCodecTo: desiredSampleIndex].
	leftoverSamples _ SoundBuffer new.
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/20/2001 16:59'!
streamSamplingRate
	"Answer the sampling rate of the MP3 stream."

	^ streamSamplingRate
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 9/26/2000 07:49'!
volume
	"Answer my volume."

	^ volume
! !
!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 5/30/2001 16:53'!
volume: aNumber
	"Set my volume to the given number between 0.0 and 1.0."

	volume _ aNumber.
	self createMixer.
! !
!StreamingMonoSound methodsFor: 'other' stamp: 'jmv 2/26/2016 16:02'!
extractFrom: startSecs to: endSecs
	"Extract a portion of this sound between the given start and end times. The current implementation only works if the sound is uncompressed."

	| emptySound first last sampleCount byteStream sndBuf |
	codec ifNotNil: [^ self error: 'only works on uncompressed sounds'].
	emptySound _ SampledSound samples: SoundBuffer new samplingRate: streamSamplingRate.
	first _ (startSecs * streamSamplingRate) truncated max: 0.
	last _ ((endSecs * streamSamplingRate) truncated min: totalSamples) - 1.
	first >= last ifTrue: [^ emptySound].
	codec ifNotNil: [self error: 'extracting from compressed sounds is not supported'].
	sampleCount _ last + 1 - first.
	stream position: audioDataStart + (2 * first).
	byteStream _ ReadStream on: (stream next: 2 * sampleCount).
	sndBuf _ SoundBuffer newMonoSampleCount: sampleCount.
	1 to: sampleCount do: [:i | sndBuf at: i put: (byteStream nextSignedInt16BigEndian: true)].
	^ SampledSound samples: sndBuf samplingRate: streamSamplingRate
! !
!StreamingMonoSound methodsFor: 'initialization' stamp: 'jm 11/16/2001 10:23'!
initStream: aStream headerStart: anInteger
	"Initialize for streaming from the given stream. The audio file header starts at the given stream position."

	stream _ aStream.
	volume _ 1.0.
	repeat _ false.
	headerStart _ anInteger.
	self reset.
! !
!StreamingMonoSound methodsFor: 'playing' stamp: 'jmv 4/17/2013 12:11' overrides: 50603201!
millisecondsSinceStart
	"Answer the number of milliseconds of this sound started playing."

	| mSecs |
	(stream isNil or: [stream closed]) ifTrue: [^ 0].
	mSecs _ self currentSampleIndex * 1000 // streamSamplingRate.
	(self isPlaying and: [lastBufferMSecs > 0]) ifTrue: [
		"adjust mSecs by the milliseconds since the last buffer"
		mutex critical: [
			mSecs _ self currentSampleIndex * 1000 // streamSamplingRate.
			mSecs _ mSecs + (Time localMillisecondClock - lastBufferMSecs)]].
	^ mSecs + 350 - (2 * SoundPlayer bufferMSecs)
! !
!StreamingMonoSound methodsFor: 'playing' stamp: 'jmv 4/17/2013 12:11' overrides: 50603239!
playSampleCount: n into: aSoundBuffer startingAt: startIndex
	"Mix the next n samples of this sound into the given buffer starting at the given index"

	self repeat ifTrue: [  "loop if necessary"
		(totalSamples - self currentSampleIndex) < n ifTrue: [self startOver]].

	mutex critical: [
		lastBufferMSecs _ Time localMillisecondClock.
		self loadBuffersForSampleCount: (n * streamSamplingRate) // SoundPlayer samplingRate.
		mixer playSampleCount: n into: aSoundBuffer startingAt: startIndex].
! !
!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 10/21/2001 09:45' overrides: 50603394!
reset

	super reset.
	self startOver.
	self createMixer.
! !
!StreamingMonoSound methodsFor: 'playing' stamp: 'jmv 5/15/2013 08:09' overrides: 50603405!
samplesRemaining
	"Answer the number of samples remaining to be played."

	| result |
	(stream isNil or: [stream closed]) ifTrue: [^ 0].
	self repeat ifTrue: [^ 1000000].
	result _ (totalSamples - self currentSampleIndex) max: 0.
	result <= 0 ifTrue: [
		stream close.
		mixer _ nil.
		codec _ nil ].
	^ result! !
!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'jmv 10/14/2015 17:26'!
onFileNamed: fileName
	"Answer an instance of me for playing the file with the given name."

	^self onFileNamed: fileName headerStart: 0! !
!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'pb 5/25/2016 01:34'!
onFileNamed: fileName headerStart: anInteger
	"Answer an instance of me for playing audio data starting at the given position in the file with the given name."

	| answer |
	fileName asFileEntry readStreamDo: [ :f |
		answer _ self new initStream: f headerStart: anInteger ].
	^answer
! !
!ScorePlayer methodsFor: 'copying' stamp: 'jm 1/29/98 18:32'!
copySounds
	"Private!! Support for copying."

	instruments _ instruments copy.
	leftVols _ leftVols copy.
	rightVols _ rightVols copy.
	muted _ muted copy.
	self reset.
! !
!ScorePlayer methodsFor: 'volume' stamp: 'jmv 12/30/2009 11:33' overrides: 50603116!
adjustVolumeTo: vol overMSecs: mSecs
	| normalizedVolume incr block |
	normalizedVolume _ (vol asFloat min: 1.0) max: 0.0.
	incr _ (self overallVolume - normalizedVolume) / mSecs * 50.0.
	block _ normalizedVolume > 0.0
		ifTrue: [
			[[(normalizedVolume - self overallVolume) abs > 0.01] whileTrue: [self overallVolume: self overallVolume - incr. (Delay forMilliseconds: 50) wait]]]
		ifFalse: [
			[[self overallVolume > 0.0] whileTrue: [self overallVolume: self overallVolume - incr. (Delay forMilliseconds: 50) wait]. self pause]].
	block fork
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 17:13'!
closeMIDIPort
	"Stop using MIDI for output. Music will be played using the built-in sound synthesis."

	self pause.
	midiPort _ nil.
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jmv 4/17/2013 12:09'!
midiPlayLoop

	| mSecsPerStep tStart mSecs |
	mSecsPerStep _ 5.
	[done] whileFalse: [
		tStart _ Time localMillisecondClock.
		self processAllAtTick: ticksSinceStart asInteger.
		(Delay forMilliseconds: mSecsPerStep) wait.
		mSecs _ Time localMillisecondClock - tStart.
		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))]! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 15:56'!
openMIDIPort: portNum
	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."

	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jmv 3/1/2010 14:06'!
processMIDIEventsAtTick: scoreTick
	"Process note events through the given score tick using MIDI."

	| j evt |
	1 to: score tracks size do: [:i |
		j _ trackEventIndex at: i.
		[
			evt _ score eventForTrack: i after: j ticks: scoreTick.
			 evt notNil
		] whileTrue: [
			evt isNoteEvent
				ifTrue: [
					(muted at: i) ifFalse: [
						evt startNoteOnMidiPort: midiPort.
						activeMIDINotes add: (Array with: evt with: i)]]
				ifFalse: [evt outputOnMidiPort: midiPort].
			j _ j + 1.
			trackEventIndex at: i put: j]].
	self turnOffActiveMIDINotesAt: scoreTick.
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jmv 10/8/2012 22:14'!
startMIDIPlaying
	"Start up a process to play this score via MIDI."

	midiPort ensureOpen.
	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].
	midiPlayerProcess _ [self midiPlayLoop] newProcess.
	midiPlayerProcess
		priority: Processor userInterruptPriority;
		name: 'ScorePlayer';
		resume.
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!
stopMIDIPlaying
	"Terminate the MIDI player process and turn off any active notes."

	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].
	midiPlayerProcess _ nil.
	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].
	activeMIDINotes _ activeMIDINotes species new.
! !
!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!
turnOffActiveMIDINotesAt: scoreTick
	"Turn off any active MIDI notes that should be turned off at the given score tick."

	| evt someNoteEnded |
	midiPort ifNil: [^ self].
	someNoteEnded _ false. 
	activeMIDINotes do: [:pair |
		evt _ pair first.
		evt endTime <= scoreTick ifTrue: [
			evt endNoteOnMidiPort: midiPort.
			someNoteEnded _ true]].

	someNoteEnded ifTrue: [
		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].
! !
!ScorePlayer methodsFor: 'operating' stamp: 'jm 1/30/98 14:03'!
disableReverb: aBoolean

	aBoolean
		ifTrue: [SoundPlayer stopReverb]
		ifFalse: [SoundPlayer startReverb].
! !
!ScorePlayer methodsFor: 'operating' stamp: 'jmv 4/6/2009 17:16' overrides: 50603205!
pause
	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."

	super pause.
	activeSounds _ activeSounds species new.
	midiPort ifNotNil: [self stopMIDIPlaying].
! !
!ScorePlayer methodsFor: 'operating' stamp: 'jmv 4/6/2009 17:16' overrides: 50603312!
resumePlaying
	"Resume playing. Start over if done."

	done ifTrue: [self reset].
	self jumpToTick: ticksSinceStart.  "Play up to here in case we got scrolled to new position."
	midiPort
		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 
		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"
! !
!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!
tempoOrRateChanged
	"This method should be called after changing the tempo or rate."

	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).
	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07' overrides: 50603352!
doControl

	super doControl.
	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].
	ticksSinceStart _ ticksSinceStart + ticksClockIncr.
	self processAllAtTick: ticksSinceStart asInteger.
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 4/6/2009 17:14'!
isDone

	| track |
	activeSounds size > 0 ifTrue: [^ false].
	activeMIDINotes size > 0 ifTrue: [^ false].
	1 to: score tracks size do: [:i |
		track _ score tracks at: i.
		(trackEventIndex at: i) <= track size ifTrue: [^ false]].
	^ true
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 4/6/2009 17:14'!
jumpToTick: startTick

	| |
	self reset.
	self processTempoMapAtTick: startTick.
	self skipNoteEventsThruTick: startTick.
	ticksSinceStart _ startTick.
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21' overrides: 50603377!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."

	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |
	myLeftVol _ (leftVol * overallVolume) asInteger.
	myRightVol _ (rightVol * overallVolume) asInteger.
	someSoundIsDone _ false.
	1 to: activeSounds size do: [:i |
		pair _ activeSounds at: i.
		snd _ pair at: 1.
		trk _ pair at: 2.
		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.
		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.
		snd samplesRemaining > 0
			ifTrue: [
				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]
			ifFalse: [someSoundIsDone _ true]].

	someSoundIsDone ifTrue: [
		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 4/6/2009 17:10'!
processAllAtTick: scoreTick

	self processTempoMapAtTick: scoreTick.
	midiPort
		ifNil: [self processNoteEventsAtTick: scoreTick]
		ifNotNil: [self processMIDIEventsAtTick: scoreTick].
	self isDone ifTrue: [
		repeat
			ifTrue: [self reset]
			ifFalse: [done _ true]].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 3/1/2010 14:06'!
processNoteEventsAtTick: scoreTick
	"Process note events through the given score tick using internal Squeak sound synthesis."

	| instr j evt snd |
	1 to: score tracks size do: [:i |
		instr _ instruments at: i.
		j _ trackEventIndex at: i.
		[
			evt _ score eventForTrack: i after: j ticks: scoreTick.
			evt notNil
		] whileTrue: [
			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [
				snd _ instr
					soundForMidiKey: evt midiKey
					dur: secsPerTick * evt duration
					loudness: evt velocity asFloat / 127.0.
				activeSounds add: (Array with: snd with: i)].
			j _ j + 1.
			trackEventIndex at: i put: j]].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 21:04'!
processTempoMapAtTick: scoreTick
	"Process tempo changes through the given score tick."

	| map tempoChanged |
	map _ score tempoMap.
	map ifNil: [^ self].
	tempoChanged _ false.
	[(tempoMapIndex <= map size) and:
	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [
		tempoChanged _ true.
		tempoMapIndex _ tempoMapIndex + 1].

	tempoChanged ifTrue: [
		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex - 1) tempo)) roundTo: 0.01.
		self tempoOrRateChanged].

! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 4/6/2009 17:16' overrides: 50603394!
reset

	super reset.
	tempo _ 120.0.
	self tempoOrRateChanged.
	done _ false.
	ticksSinceStart _ 0.
	"one index for each sound track, plus one for the ambient track..."
	trackEventIndex _ Array new: score tracks size+1 withAll: 1.
	tempoMapIndex _ 1.
	activeSounds _ OrderedCollection new.
	activeMIDINotes _ OrderedCollection new.
	overallVolume ifNil: [overallVolume _ 0.5].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 12/30/97 17:38' overrides: 50603405!
samplesRemaining

	done
		ifTrue: [^ 0]
		ifFalse: [^ 1000000].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jmv 3/1/2010 13:18'!
skipNoteEventsThruTick: startTick
	"Skip note events through the given score tick using internal Squeak sound synthesis."

	| j evt |
	1 to: score tracks size do: [:i |
		j _ trackEventIndex at: i.
		[evt _ score eventForTrack: i after: j ticks: startTick.
		 evt == nil] whileFalse: [
			evt isNoteEvent
				ifTrue: [
					(((evt time + evt duration) > startTick) and: [(muted at: i) not]) ifTrue: [
						self startNote: evt forStartTick: startTick trackIndex: i]]
				ifFalse: [
					midiPort ifNotNil: [evt outputOnMidiPort: midiPort]].
			j _ j + 1].
		trackEventIndex at: i put: j].
! !
!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:30'!
startNote: noteEvent forStartTick: startTick trackIndex: trackIndex
	"Prepare a note to begin playing at the given tick. Used to start playing at an arbitrary point in the score. Handle both MIDI and built-in synthesis cases."

	| snd |
	midiPort
		ifNil: [
			snd _ (instruments at: trackIndex)
				soundForMidiKey: noteEvent midiKey
				dur: secsPerTick * (noteEvent endTime - startTick)
				loudness: noteEvent velocity asFloat / 127.0.
			activeSounds add: (Array with: snd with: trackIndex)]
		ifNotNil: [
			noteEvent startNoteOnMidiPort: midiPort.
			activeMIDINotes add: (Array with: noteEvent with: trackIndex)].
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 12/16/2001 11:59'!
duration
	"Answer the duration in seconds of my MIDI score when played at the current rate. Take tempo changes into account."

	| totalSecs currentTempo lastTempoChangeTick |
	totalSecs _ 0.0.
	currentTempo _ 120.0.  "quarter notes per minute"
	lastTempoChangeTick _ 0.
	score tempoMap ifNotNil: [
		score tempoMap do: [:tempoEvt |
			"accumulate time up to this tempo change event"
			secsPerTick _ 60.0 / (currentTempo * rate * score ticksPerQuarterNote).
			totalSecs _ totalSecs + (secsPerTick * (tempoEvt time - lastTempoChangeTick)).

			"set the new tempo"
			currentTempo _ (120.0 * (500000.0 / tempoEvt tempo)) roundTo: 0.01.
			lastTempoChangeTick _ tempoEvt time]].

	"add remaining time through end of score"
	secsPerTick _ 60.0 / (currentTempo * rate * score ticksPerQuarterNote).
	totalSecs _ totalSecs + (secsPerTick * (score durationInTicks - lastTempoChangeTick)).
	^ totalSecs
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jmv 3/1/2010 13:17'!
durationInTicks

	durationInTicks ifNil: [^ 1000].
	^ durationInTicks! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/3/98 12:14'!
infoForTrack: i
	"Return the info string for the given track."
	"Note: MIDI files follow varying conventions on their use of comment strings. Often, the first string in the track suggests the role of that track in the score, such as 'flute 1' or 'soprano'."

	^ score trackInfo at: i
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:37'!
instrumentForTrack: trackIndex

	^ instruments at: trackIndex
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/1/1999 20:33'!
instrumentForTrack: trackIndex put: aSoundProto

	trackIndex > instruments size ifTrue: [^ self].
	instruments at: trackIndex put: aSoundProto.
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 12/16/2001 20:20' overrides: 50603579!
isStereo

	^ true
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:58'!
midiPort

	^ midiPort
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'di 5/30/1999 12:46' overrides: 50603201!
millisecondsSinceStart
	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."

	^ (secsPerTick * ticksSinceStart * 1000) asInteger
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/29/98 18:33'!
mutedForTrack: trackIndex

	^ muted at: trackIndex
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jmv 3/2/2010 10:06'!
mutedForTrack: trackIndex put: aBoolean

	trackIndex > muted size ifTrue: [^ self].
	muted at: trackIndex put: aBoolean.
	aBoolean ifFalse: [^ self].

	"silence any currently sounding notes for this track"
	activeSounds do: [:pair |
		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: nil]].
	midiPort ifNotNil: [
		activeMIDINotes do: [:pair |
			pair last = trackIndex ifTrue: [
				pair first endNoteOnMidiPort: midiPort.
				activeMIDINotes remove: pair ifAbsent: nil]]].
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 5/30/1999 17:16'!
mutedState

	^ muted
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!
overallVolume

	^ overallVolume
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!
overallVolume: aNumber
	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."

	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.

! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!
panForTrack: i

	| left right fullVol pan |
	left _ leftVols at: i.
	right _ rightVols at: i.
	left = right ifTrue: [^ 0.5].  "centered"
	fullVol _ left max: right.
	left < fullVol
		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]
		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].
	^ pan roundTo: 0.001

! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/2/1999 13:33'!
panForTrack: trackIndex put: aNumber
	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."

	| fullVol pan left right |
	trackIndex > leftVols size ifTrue: [^ self].
	fullVol _ (leftVols at: trackIndex) max: (rightVols at: trackIndex).
	pan _ (aNumber asFloat min: 1.0) max: 0.0.
	pan <= 0.5
		ifTrue: [  "attenuate right channel"
			left _ fullVol.
			right _ 2.0 * pan * fullVol]
		ifFalse: [  "attenuate left channel"
			left _ 2.0 * (1.0 - pan) * fullVol.
			right _ fullVol].
	rightVols at: trackIndex put: right asInteger.
	leftVols at: trackIndex put: left asInteger.
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/20/1999 00:42'!
positionInScore

	^ self ticksSinceStart asFloat / (self durationInTicks max: 1)! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/16/1999 22:50'!
positionInScore: pos

	self isPlaying ifTrue: [^ self "ignore rude intrusion"].
	ticksSinceStart _ pos * durationInTicks.
	done _ false.

! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!
rate

	^ rate
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:07'!
rate: aNumber
	"Set the playback rate. For example, a rate of 2.0 will playback at twice normal speed."

	rate _ aNumber asFloat.
	self tempoOrRateChanged.
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/4/98 09:30'!
repeat
	"Return true if this player will repeat when it gets to the end of the score, false otherwise."

	^ repeat
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/4/98 09:31'!
repeat: aBoolean
	"Turn repeat mode on or off."

	repeat _ aBoolean.
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!
score

	^ score
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'di 10/19/2000 21:12'!
secsPerTick

	^ secsPerTick! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jmv 3/13/2012 12:45'!
settingsString

	| s |
	s _ WriteStream on: (String new: 1000).
	s nextPutAll: 'player'; newLine.
	s tab; nextPutAll: 'rate: ', self rate printString, ';'; newLine.
	s tab; nextPutAll: 'overallVolume: ', self overallVolume printString, ';'; newLine.
	1 to: self trackCount do: [:t |
		s tab; nextPutAll: 'instrumentForTrack: ', t printString,
			' put: (AbstractSound soundNamed: #default);'; newLine.
		s tab; nextPutAll: 'mutedForTrack: ', t printString,
			' put: ', (self mutedForTrack: t) printString, ';'; newLine.
		s tab; nextPutAll: 'volumeForTrack: ', t printString,
			' put: ', (self volumeForTrack: t) printString, ';'; newLine.
		s tab; nextPutAll: 'panForTrack: ', t printString,
			' put: ', (self panForTrack: t) printString, ';'; newLine].
	s tab; nextPutAll: 'repeat: ', self repeat printString, '.'; newLine.
	^ s contents
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:10'!
tempo
	"Return the current tempo in beats (quarter notes) per minute. The tempo at any given moment is defined by the score and cannot be changed by the client. To change the playback speed, the client may change the rate parameter."

	^ tempo
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!
ticksForMSecs: mSecs

	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!
ticksSinceStart
	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."

	^ ticksSinceStart
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/19/1999 10:45'!
ticksSinceStart: newTicks
	"Adjust ticks to folow, eg, piano roll autoscrolling"

	self isPlaying ifFalse: [ticksSinceStart _ newTicks]
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:35'!
trackCount

	^ score tracks size
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!
volumeForTrack: i

	| vol |
	vol _ (leftVols at: i) max: (rightVols at: i).
	^ (vol asFloat / ScaleFactor) roundTo: 0.0001
! !
!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/2/1999 13:34'!
volumeForTrack: trackIndex put: aNumber

	| newVol oldLeft oldRight oldFullVol left right |
	trackIndex > leftVols size ifTrue: [^ self].
	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.
	oldLeft _ leftVols at: trackIndex.
	oldRight _ rightVols at: trackIndex.
	oldFullVol _ oldLeft max: oldRight.
	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].
	oldLeft < oldFullVol
		ifTrue: [
			left _ newVol * oldLeft / oldFullVol.
			right _ newVol]
		ifFalse: [
			left _ newVol.
			right _ newVol * oldRight / oldFullVol].
	leftVols at: trackIndex put: left asInteger.
	rightVols at: trackIndex put: right asInteger.
! !
!ScorePlayer methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:49' overrides: 50603506!
initialize

	super initialize.
	score _ MIDIScore new.
	instruments _ #().
	overallVolume _ 0.5.
	leftVols _ #().
	rightVols _ #().
	muted _ #().
	rate _ 1.0.
	repeat _ false.
	durationInTicks _ 100! !
!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/15/1999 11:18'!
onScore: aMIDIScore

	| trackCount totalVol incr curr pan |
	score _ aMIDIScore.
	trackCount _ score tracks size.
	durationInTicks _ score durationInTicks.
	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].
	leftVols _ Array new: trackCount.
	rightVols _ Array new: trackCount.
	muted  _ Array new: trackCount withAll: false.
	rate _ 1.0.
	repeat _ false.
	tempo _ 120.0.

	trackCount = 0 ifTrue: [^ self].
	1 to: trackCount do: [:i |
		leftVols at: i put: ScaleFactor // 4.
		rightVols at: i put: ScaleFactor // 4].

	"distribute inital panning of tracks left-to-right"
	totalVol _ 1.0.
	incr _ totalVol / (((trackCount // 2) + 1) * 2).
	curr _ 0.
	1 to: trackCount do: [:t |
		t even
			ifTrue: [pan _ curr]
			ifFalse: [
				curr _ curr + incr.
				pan _ totalVol - curr].
		self panForTrack: t put: pan].

! !
!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/20/1999 00:46'!
updateDuration

	durationInTicks _ score durationInTicks.
! !
!ScorePlayer class methodsFor: 'instance creation' stamp: 'jm 1/29/98 18:18'!
onScore: aMIDIScore

	^ self new onScore: aMIDIScore
! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:15'!
asSound
	"Answer the result of decompressing the receiver."

	| codecClass |
	codecClass _ Smalltalk at: codecName
		ifAbsent: [^ self error: 'The codec for decompressing this sound is not available'].
	^ (codecClass new decompressSound: self) reset
! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!
doControl

	cachedSound doControl
! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!
mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol

	cachedSound mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol
! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'jmv 3/1/2010 09:47'!
reset
	"This message is the cue to start behaving like a real sound in order to be played.
	We do this by caching a decompressed version of this sound.
	See also samplesRemaining."

	cachedSound
		ifNil: [cachedSound _ self asSound].
	cachedSound reset
! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:44'!
samples

	^ self asSound samples! !
!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:49'!
samplesRemaining
	"This message is the cue that the cached sound may no longer be needed.
	We know it is done playing when samplesRemaining=0."

	| samplesRemaining |
	samplesRemaining _ cachedSound samplesRemaining.
	samplesRemaining <= 0 ifTrue: [cachedSound _ nil].
	^ samplesRemaining! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:10'!
channels
	"Answer an array of ByteArrays containing the compressed sound data for each channel."

	^ channels
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!
channels: anArray

	channels _ anArray.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!
codecName
	"Answer the name of the sound codec used to compress this sound. Typically, this is the name of a class that can be used to decode the sound, but it is possible that the codec has not yet been implemented or is not filed into this image."

	^ codecName
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:45'!
codecName: aStringOrSymbol

	codecName _ aStringOrSymbol asSymbol.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!
firstSample
	"Answer the firstSample of the original sound."

	^ firstSample
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!
firstSample: anInteger

	firstSample _ anInteger.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:55'!
gain
	"Answer the gain of the original sound."

	^ gain
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!
gain: aNumber

	gain _ aNumber.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!
loopEnd
	"Answer index of the last sample of the loop, or nil if the original sound was not looped."

	^ loopEnd
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!
loopEnd: anInteger

	loopEnd _ anInteger.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!
loopLength
	"Answer length of the loop, or nil if the original sound was not looped."

	^ loopLength
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!
loopLength: anInteger

	loopLength _ anInteger.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!
perceivedPitch
	"Answer the perceived pitch of the original sound. By convention, unpitched sounds (like drum hits) are given an arbitrary pitch of 100.0."

	^ perceivedPitch
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!
perceivedPitch: aNumber

	perceivedPitch _ aNumber.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:13'!
samplingRate
	"Answer the samplingRate of the original sound."

	^ samplingRate
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:36'!
samplingRate: aNumber

	samplingRate _ aNumber.
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!
soundClassName
	"Answer the class name of the uncompressed sound."

	^ soundClassName
! !
!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!
soundClassName: aStringOrSymbol

	soundClassName _ aStringOrSymbol asSymbol.
! !
!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 09:50'!
compressWith: codecClass

	codecName == codecClass name asSymbol ifTrue: [^self].
	^self asSound compressWith: codecClass! !
!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 12/24/2000 08:53'!
compressWith: codecClass atRate: aSamplingRate

	(codecName == codecClass name asSymbol and: [samplingRate = aSamplingRate]) ifTrue: [^self].
	^self asSound compressWith: codecClass atRate: aSamplingRate! !
!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!
attackTime
	"Return the time taken by the attack phase."

	^ (points at: loopStartIndex) x
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!
centerPitch: aNumber
	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 10:21'!
decayEndIndex

	^ points size
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 08:53'!
decayTime
	"Return the time taken by the decay phase."

	^ points last x - (points at: loopEndIndex) x
! !
!Envelope methodsFor: 'accessing' stamp: 'jmv 3/1/2010 10:00'!
duration
	"Return the time of the final point."

	loopEndMSecs
		ifNil: [^ points last x].
	^ loopEndMSecs + self decayTime
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!
duration: seconds
	"Set the note duration to the given number of seconds."
	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."
	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 

	| attack decay endTime |
	endMSecs _ (seconds * 1000.0) asInteger - 19.
	attack _ self attackTime.
	decay _ self decayTime.
	endMSecs > (attack + decay)
		ifTrue: [endTime _ endMSecs - decay]
		ifFalse: [
			endMSecs >= attack
				ifTrue: [endTime _ attack]
				ifFalse: [endTime _ endMSecs]].

	self sustainEnd: (endTime max: 0).
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!
loopEndIndex

	^ loopEndIndex
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!
loopStartIndex

	^ loopStartIndex
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!
points

	^ points
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:36'!
scale: aNumber

	scale _ aNumber asFloat.
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 09:25'!
target

	^ target
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 09:25'!
target: anObject

	target _ anObject.
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:34'!
updateSelector

	^ updateSelector
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 08:52'!
updateSelector: aSymbol

	updateSelector _ aSymbol.
! !
!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!
volume: aNumber
	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."
! !
!Envelope methodsFor: 'private' stamp: 'jm 11/26/97 09:03'!
checkParameters
	"Verify that the point array, loopStartIndex, and loopStopIndex obey the rules."

	| lastT t |
	points size > 1
		ifFalse: [^ self error: 'the point list must contain at least two points'].
	points first x = 0
		ifFalse: [^ self error: 'the time of the first point must be zero'].
	lastT _ points first x.
	2 to: points size do: [:i |
		t _ (points at: i) x.
		t >= lastT
			ifFalse: [^ self error: 'the points must be in ascending time order']].

	(loopStartIndex isInteger and:
	 [(loopStartIndex > 0) and: [loopStartIndex <= points size]])
		ifFalse: [^ self error: 'loopStartIndex is not a valid point index'].
	(loopEndIndex isInteger and:
	 [(loopEndIndex > 0) and: [loopEndIndex <= points size]])
		ifFalse: [^ self error: 'loopEndIndex is not a valid point index'].
	 loopStartIndex <= loopEndIndex
		ifFalse: [^ self error: 'loopEndIndex must not precede loopStartIndex'].
! !
!Envelope methodsFor: 'private' stamp: 'jm 2/4/98 20:20'!
computeIncrementAt: mSecs between: p1 and: p2 scale: combinedScale
	"Compute the current and increment values for the given time between the given inflection points."
	"Assume: p1 x <= mSecs <= p2 x"

	| valueRange timeRange |
	valueRange _ (p2 y - p1 y) asFloat.
	timeRange _ (p2 x - p1 x) asFloat.
	currValue _ (p1 y + (((mSecs - p1 x) asFloat / timeRange) * valueRange)) * combinedScale.
	valueIncr _ (((p2 y * combinedScale) - currValue) / (p2 x - mSecs)) * 10.0.
	^ currValue
! !
!Envelope methodsFor: 'private' stamp: 'jmv 3/1/2010 14:05'!
incrementalComputeValueAtMSecs: mSecs
	"Compute the current value, per-step increment, and the time of the next inflection point."
	"Note: This method is part of faster, but less general, way of computing envelope values. It depends on a known, fixed control updating rate."

	| t i |
	(loopEndMSecs notNil and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"
		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).
		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.
		i ifNil: [  "past end"
			currValue _ points last y * scale * decayScale.
			valueIncr _ 0.0.
			nextRecomputeTime _ mSecs + 1000000.
			^ currValue].
		nextRecomputeTime _ mSecs + ((points at: i) x - t).
		^ self computeIncrementAt: t
			between: (points at: i - 1)
			and: (points at: i)
			scale: scale * decayScale].

	mSecs < loopStartMSecs
		ifTrue: [  "attack phase"
			t _ mSecs.
			i _ self indexOfPointAfterMSecs: t startingAt: 1.
			nextRecomputeTime _ mSecs + ((points at: i) x - t)]
		ifFalse: [  "sustain (looping) phase"
			noChangesDuringLoop ifTrue: [
				currValue _ (points at: loopEndIndex) y * scale.
				valueIncr _ 0.0.
					loopEndMSecs
						ifNil: [nextRecomputeTime _ mSecs + 10]	 "unknown end time"
						ifNotNil: [nextRecomputeTime _ loopEndMSecs].
				^ currValue].
			t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).
			i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.
			nextRecomputeTime _ (mSecs + ((points at: i) x - t)) min: loopEndMSecs].

	^ self computeIncrementAt: t
		between: (points at: i - 1)
		and: (points at: i)
		scale: scale.
! !
!Envelope methodsFor: 'private' stamp: 'jm 12/16/97 16:51'!
indexOfPointAfterMSecs: mSecs startingAt: startIndex
	"Return the index of the first point whose time is greater that mSecs, starting with the given index. Return nil if mSecs is after the last point's time."

	startIndex to: points size do:
		[:i | (points at: i) x > mSecs ifTrue: [^ i]].
	^ nil
! !
!Envelope methodsFor: 'private' stamp: 'jm 2/4/98 21:05'!
interpolate: mSecs between: p1 and: p2
	"Return the scaled, interpolated value for the given time between the given time points."
	"Assume: p1 x <= mSecs <= p2 x"

	| valueRange timeRange |
	valueRange _ (p2 y - p1 y) asFloat.
	valueRange = 0.0 ifTrue: [^ p1 y * scale].
	timeRange _ (p2 x - p1 x) asFloat.
	^ (p1 y + (((mSecs - p1 x) asFloat / timeRange) * valueRange)) * scale.
! !
!Envelope methodsFor: 'private' stamp: 'jm 2/4/98 17:52'!
setPoints: pointList loopStart: startIndex loopEnd: endIndex

	| lastVal |
	points _ pointList asArray collect: [:p | p x asInteger @ p y asFloat].
	loopStartIndex _ startIndex.
	loopEndIndex _ endIndex.
	self checkParameters.
	loopStartMSecs _ (points at: loopStartIndex) x.
	loopMSecs _ (points at: loopEndIndex) x - (points at: loopStartIndex) x.
	loopEndMSecs _ nil.  "unknown end time; sustain until end time is known"
	scale ifNil: [scale _ 1.0].
	decayScale ifNil: [decayScale _ 1.0].

	"note if there are no changes during the loop phase"
	noChangesDuringLoop _ true.
	lastVal _ (points at: loopStartIndex) y.
	loopStartIndex to: loopEndIndex do: [:i | 
		(points at: i) y ~= lastVal ifTrue: [
			noChangesDuringLoop _ false.
			^ self]].
! !
!Envelope methodsFor: 'applying' stamp: 'jmv 3/1/2010 14:04'!
computeValueAtMSecs: mSecs
	"Return the value of this envelope at the given number of milliseconds from its onset. Return zero for times outside the time range of this envelope."
	"Note: Unlike the private method incrementalComputeValueAtMSecs:, this method does is not increment. Thus it is slower, but it doesn't depend on being called sequentially at fixed time intervals."

	| t i |
	mSecs < 0 ifTrue: [^ 0.0].

	(loopEndMSecs notNil and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"
		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).
		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.
		i ifNil: [^ 0.0].  "past end"
		^ (self interpolate: t between: (points at: i - 1) and: (points at: i)) * decayScale].

	mSecs < loopStartMSecs ifTrue: [  "attack phase"
		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.
		i = 1 ifTrue: [^ (points at: 1) y * scale].
		^ self interpolate: mSecs between: (points at: i - 1) and: (points at: i)].

	"sustain phase"
	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y * scale].  "looping on a single point"
	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).
	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.

	^ self interpolate: t between: (points at: i - 1) and: (points at: i)
! !
!Envelope methodsFor: 'applying' stamp: 'jm 2/4/98 21:15'!
reset
	"Reset the state for this envelope."

	lastValue _ -100000.0.  "impossible value"
	nextRecomputeTime _ 0.
	self updateTargetAt: 0.
! !
!Envelope methodsFor: 'applying' stamp: 'jm 2/4/98 17:39'!
showOnDisplay
	"Envelope example showOnDisplay"

	| xOrigin yOrigin minVal maxVal yScale step x v y |
	xOrigin _ 30.
	yOrigin _ 130.
	minVal _ 1e100.
	maxVal _ -1e100.
	points do: [:p |
		p y < minVal ifTrue: [minVal _ p y].
		p y > maxVal ifTrue: [maxVal _ p y]].

	yScale _ 100.0 / ((maxVal - minVal) * scale).
	step _ (self duration // 150) max: 1.

	Display fillBlack: ((xOrigin + ((points at: loopStartIndex) x // step))@(yOrigin - 100) extent: 1@100).
	Display fillBlack: ((xOrigin + ((points at: loopEndIndex) x // step))@(yOrigin - 100) extent: 1@100).
	Display fillBlack: (xOrigin@(yOrigin - 100) extent: 1@100).
	x _ xOrigin.
	step negated to: self duration + step by: step do: [:mSecs |
		v _ self computeValueAtMSecs: mSecs.
		y _ yOrigin - ((v - minVal) * yScale) asInteger.
		Display fillBlack: ((x - 1)@(y - 1) extent: 2@2).
		Display fillBlack: (x@yOrigin extent: 1@1).
		x _ x + 1].
! !
!Envelope methodsFor: 'applying' stamp: 'jm 2/4/98 18:27'!
sustainEnd: mSecs
	"Set the ending time of the sustain phase of this envelope; the decay phase will start this point. Typically derived from a note's duration."
	"Details: to avoid a sharp transient, the decay phase is scaled so that the beginning of the decay matches the envelope's instantaneous value when the decay phase starts."

	| vIfSustaining firstVOfDecay |
	loopEndMSecs _ nil. "pretend to be sustaining"
	decayScale _ 1.0.
	nextRecomputeTime _ 0.
	vIfSustaining _ self computeValueAtMSecs: mSecs.  "get value at end of sustain phase"
	loopEndMSecs _ mSecs.
	firstVOfDecay _ (points at: loopEndIndex) y * scale.
	firstVOfDecay = 0.0
		ifTrue: [decayScale _ 1.0]
		ifFalse: [decayScale _ vIfSustaining / firstVOfDecay].
! !
!Envelope methodsFor: 'applying' stamp: 'jm 2/4/98 19:46'!
updateTargetAt: mSecs
	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."

	| newValue |
	newValue _ self valueAtMSecs: mSecs.
	newValue = lastValue ifTrue: [^ false].
	target
		perform: updateSelector
		with: newValue.
	lastValue _ newValue.
	^ true
! !
!Envelope methodsFor: 'applying' stamp: 'jm 2/4/98 20:24'!
valueAtMSecs: mSecs
	"Return the value of this envelope at the given number of milliseconds from its onset. Return zero for times outside the time range of this envelope."

	mSecs < 0 ifTrue: [^ 0.0].
	mSecs < nextRecomputeTime
		ifTrue: [currValue _ currValue + valueIncr]
		ifFalse: [currValue _ self incrementalComputeValueAtMSecs: mSecs].
	^ currValue
! !
!Envelope class methodsFor: 'instance creation' stamp: 'jm 11/26/97 09:14'!
example
	"Envelope example showOnDisplay"

	| p |
	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.
	^ (self points: p loopStart: 2 loopEnd: 4) sustainEnd: 1200.
! !
!Envelope class methodsFor: 'instance creation' stamp: 'jm 2/4/98 06:52'!
exponentialDecay: multiplier
	"(Envelope exponentialDecay: 0.95) showOnDisplay"

	| mSecsPerStep pList t v last |
	mSecsPerStep _ 10.
	((multiplier > 0.0) and: [multiplier < 1.0])
		ifFalse: [self error: 'multiplier must be greater than 0.0 and less than 1.0'].
	pList _ OrderedCollection new.
	pList add: 0@0.0.
	last _ 0.0.
	v _ 1.0.
	t _ 10.
	[v > 0.01] whileTrue: [
		(v - last) abs > 0.02 ifTrue: [
			"only record substatial changes"
			pList add: t@v.
			last _ v].
		t _ t + mSecsPerStep.
		v _ v * multiplier].
	pList add: (t + mSecsPerStep)@0.0.

	^ self points: pList asArray
		loopStart: pList size 
		loopEnd: pList size
! !
!Envelope class methodsFor: 'instance creation' stamp: 'jm 11/26/97 08:49'!
points: pList loopStart: loopStart loopEnd: loopEnd

	^ self new setPoints: pList asArray
		loopStart: loopStart
		loopEnd: loopEnd
! !
!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 1/31/98 14:46'!
centerPitch

	^ centerPitch
! !
!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 1/31/98 14:49' overrides: 50609208!
centerPitch: aNumber

	centerPitch _ aNumber.
! !
!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 07:30' overrides: 50609286!
updateSelector
	"Needed by the envelope editor."

	^ #pitch:
! !
!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 21:11' overrides: 50609558!
updateTargetAt: mSecs
	"Update the pitch for my target. Answer true if the value changed."
	"Details: Assume envelope range is 0.0..2.0, with 1 being the center pitch. Subtracting one yields the range -1.0..1.0. Raising two to this power yields pitches between half and double the center pitch; i.e. from an octave below to an octave about the center pitch."

	| newValue |
	newValue _ self valueAtMSecs: mSecs.
	newValue ~= lastValue ifTrue: [
		target pitch: (2.0 raisedTo: newValue - (scale / 2.0)) * centerPitch.
		lastValue _ newValue.
		^ true].

	^ false
! !
!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29' overrides: 50609223!
duration

	^ 1.0
! !
!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25' overrides: 50609229!
duration: seconds
	"Do nothing."
! !
!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30' overrides: 50609533!
sustainEnd: seconds
	"Do nothing."
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18' overrides: 50609208!
centerPitch: aNumber
	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."

	updateSelector = #pitch: ifTrue: [self scale: aNumber].
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!
delta

	^ delta
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!
delta: aNumber

	delta _ aNumber.
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!
highLimit

	^ highLimit
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!
highLimit: aNumber

	highLimit _ aNumber.
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!
lowLimit

	^ lowLimit
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!
lowLimit: aNumber

	lowLimit _ aNumber.
! !
!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17' overrides: 50609294!
volume: aNumber
	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."

	updateSelector = #volume: ifTrue: [self scale: aNumber].
! !
!RandomEnvelope methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:15' overrides: 16920235!
initialize

	rand _ Random new.
	lowLimit _ 0.994.
	highLimit _ 1.006.
	delta _ 0.0002.
	currValue _ 1.0.
	scale _ 1.0.
! !
!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'jmv 3/2/2010 16:25' overrides: 50609272!
points

	| env |
	points ifNil: [
		env _ self target envelopes first.
		points _ OrderedCollection new.
		points
			add: 0@(self delta * 5 + 0.5);
			add: (env points at: env loopStartIndex)x@(self highLimit -1 * 5 + 0.5);
			add: (env points at: env loopEndIndex)x@(self highLimit -1 * 5 + 0.5);
			add: (env points last)x@(self lowLimit -1 * 5 + 0.5).
		loopStartIndex _ 2.
		loopEndIndex _ 3.
	].
	^points! !
!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'JMV 1/9/2001 13:08' overrides: 50609427!
setPoints: pointList loopStart: startIndex loopEnd: endIndex

	self delta: pointList first y - 0.5 / 5.
	self highLimit: (pointList at: startIndex) y - 0.5 / 5 + 1.
	self lowLimit: pointList last y - 0.5 / 5 + 1.
	^super setPoints: pointList loopStart: startIndex loopEnd: endIndex! !
!RandomEnvelope methodsFor: 'applying' stamp: 'jm 8/13/1998 18:25' overrides: 50609558!
updateTargetAt: mSecs
	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."

	| r |
	r _ rand next.
	r > 0.5
		ifTrue: [
			currValue _ currValue + delta.
			currValue > highLimit ifTrue: [currValue _ highLimit]]
		ifFalse: [
			currValue _ currValue - delta.
			currValue < lowLimit ifTrue: [currValue _ lowLimit]].
	currValue = lastValue ifTrue: [^ false].
	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].
	target
		perform: updateSelector
		with: scale * currValue.
	lastValue _ currValue.
	^ true
! !
!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!
for: aSelector
	"Answer a random envelope for the given selector."

	^ self new updateSelector: aSelector
! !
!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jmv 3/1/2010 14:17'!
computeSlopeAtMSecs: mSecs
	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."

	| t i |
	((loopEndMSecs notNil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"
		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).
		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.
		i ifNil: [  "past end"
			targetVol _ points last y * decayScale.
			mSecsForChange _ 0.
			nextRecomputeTime _ mSecs + 1000000.
			^ self].
		targetVol _ (points at: i) y * decayScale.
		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.
		nextRecomputeTime _ mSecs + mSecsForChange.
		^ self].

	mSecs < loopStartMSecs ifTrue: [  "attack phase"
		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.
		targetVol _ (points at: i) y.
		mSecsForChange _ ((points at: i) x - mSecs) max: 4.
		nextRecomputeTime _ mSecs + mSecsForChange.
		((loopEndMSecs notNil) and: [nextRecomputeTime > loopEndMSecs])
			ifTrue: [nextRecomputeTime _ loopEndMSecs].
		^ self].

	"sustain and loop phase"
	noChangesDuringLoop ifTrue: [
		targetVol _ (points at: loopEndIndex) y.
		mSecsForChange _ 10.
		loopEndMSecs
			ifNil: [nextRecomputeTime _ mSecs + 10]  "unknown end time"
			ifNotNil: [nextRecomputeTime _ loopEndMSecs].
		^ self].

	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"
	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).
	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.
	targetVol _ (points at: i) y.
	mSecsForChange _ ((points at: i) x - t) max: 4.
	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.
! !
!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 18:51' overrides: 50609495!
reset
	"Reset the state for this envelope."

	super reset.
	target initialVolume: points first y * scale.
	nextRecomputeTime _ 0.
! !
!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 07:27' overrides: 50609286!
updateSelector
	"Needed by the envelope editor."

	^ #volume:
! !
!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 9/10/1998 07:04' overrides: 50609558!
updateTargetAt: mSecs
	"Update the volume envelope slope and limit for my target. Answer false."

	mSecs < nextRecomputeTime ifTrue: [^ false].
	self computeSlopeAtMSecs: mSecs.
	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"
	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.
	^ false
! !
!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 8/17/1998 08:00' overrides: 50609294!
volume: aNumber
	"Set the maximum volume of a volume-controlling envelope."

	scale _ aNumber asFloat.
! !
!SampledInstrument methodsFor: 'other' stamp: 'jmv 8/23/2010 10:10'!
allNotes
	"Answer a collection containing of all the unique sampled sounds used by this instrument."

	| r |
	r _ IdentitySet new.
	r addAll: sustainedLoud.
	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].
	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].
	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].
	^ r asArray sort: [:n1 :n2 | n1 pitch < n2 pitch]! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!
chooseSamplesForPitch: pitchInHz from: sortedNotes
	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."
	"Assume: the given collection is sorted in ascending pitch order."

	| i lower higher |
	i _ 1.
	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]
		whileTrue: [i _ i + 1].
	i = 1 ifTrue: [^ sortedNotes at: 1].
	lower _ sortedNotes at: i - 1.
	higher _ sortedNotes at: i.
	"note: give slight preference for down-shifting a higher-pitched sample set"
	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)
		ifTrue: [^ lower]
		ifFalse: [^ higher].
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!
memorySpace
	"Answer the number of bytes required to store the samples for this instrument."

	| total |
	total _ 0.
	self allNotes do: [:n |
		total _ total + (n leftSamples monoSampleCount * 2).
		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].
	^ total
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!
midiKeyMapFor: sortedNotes
	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."

	^ (0 to: 127) collect: [:k |
		self
			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)
			from: sortedNotes].
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!
playChromaticRunFrom: startPitch to: endPitch

	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!
pruneNoteList: aNoteList notesPerOctave: notesPerOctave
	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."

	| r interval lastPitch |
	r _ OrderedCollection new: aNoteList size.
	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.
	lastPitch _ 0.0.
	aNoteList do: [:n |
		n pitch > (lastPitch * interval) ifTrue: [
			r addLast: n.
			lastPitch _ n pitch]].
	^ r
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!
pruneToNotesPerOctave: notesPerOctave
	"Prune all my keymaps to the given number of notes per octave."

	sustainedLoud _ self midiKeyMapFor:
		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).
	sustainedSoft _ self midiKeyMapFor:
		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).
	staccatoLoud _ self midiKeyMapFor:
		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).
	staccatoSoft _ self midiKeyMapFor:
		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!
pruneToSingleNote: aNote
	"Fill all my keymaps with the given note."

	| oneNoteMap |
	oneNoteMap _ Array new: 128 withAll: aNote.
	sustainedLoud _ oneNoteMap.
	sustainedSoft _ oneNoteMap.
	staccatoLoud _ oneNoteMap.
	staccatoSoft _ oneNoteMap.
! !
!SampledInstrument methodsFor: 'other' stamp: 'jmv 10/14/2015 17:46'!
readSampleSetFrom: dirName
	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."

	| all dir fullName snd |
	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].
	dir _ dirName asDirectoryEntry.
	dir fileNames do: [ :n |
		fullName _ (dir / n) pathName.
		Utilities
			informUser: 'Reading AIFF file ', n
			during: [
				snd _ LoopedSampledSound new
					fromAIFFFileNamed: fullName
					mergeIfStereo: true].
		all add: snd].
	^ all asArray! !
!SampledInstrument methodsFor: 'other' stamp: 'jmv 10/14/2015 17:47'!
readSampleSetInfoFrom: dirName
	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"

	| all dir fullName info |
	all _ OrderedCollection new.
	dir _ dirName asDirectoryEntry.
	dir fileNames do: [ :n |
		fullName _ (dir / n) pathName.
		info _ AIFFFileReader new readFromFile: fullName
			mergeIfStereo: false
			skipDataChunk: true.
		all add: n -> info].
	^ all
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!
testAtPitch: aPitch
	"SampledInstrument testAtPitch: 'c4'"

	| pattern |
	pattern _ (#(
		(c4 0.64 100) 
		(c4 0.64 200) 
		(c4 0.64 400) 
		(c4 0.64 600) 
		(c4 0.64 800) 
		(c4 1.28 1000) 
		(c4 1.28 400) 
		(c4 0.32 500) 
		(c4 0.32 500) 
		(c4 0.32 500) 
		(c4 0.32 500) 
		(c4 0.16 500) 
		(c4 0.16 500) 
		(c4 0.16 500) 
		(c4 0.16 500) 
		(c4 0.16 500) 
		(c4 0.08 500) 
		(c4 0.08 500) 
		(c4 0.16 500) 
		(c4 0.08 500) 
		(c4 0.08 500) 
		(c4 0.64 500))
			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).
	(AbstractSound noteSequenceOn: self from: pattern) play.
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!
trimAttackOf: sampleBuffer threshold: threshold
	"Trim 'silence' off the initial attacks of the given sound buffer."

	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |
		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).
		snd isStereo ifTrue: [
			snd rightSamples:
				(self trimAttackOf: snd rightSamples threshold: threshold)]].
! !
!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!
trimAttacks: threshold
	"Trim 'silence' off the initial attacks all my samples."

	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |
		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).
		snd isStereo ifTrue: [
			snd rightSamples:
				(self trimAttackOf: snd rightSamples threshold: threshold)]].
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!
allSampleSets: sortedNotes

	| keyMap |
	keyMap _ self midiKeyMapFor: sortedNotes.
	sustainedSoft _ keyMap.
	sustainedLoud _ keyMap.
	staccatoSoft _ keyMap.
	staccatoLoud _ keyMap.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04' overrides: 16920235!
initialize

	sustainedThreshold _ 0.15.
	loudThreshold _ 0.5.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!
loudThreshold

	^ loudThreshold
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!
loudThreshold: aNumber

	loudThreshold _ aNumber asFloat.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!
staccatoLoudAndSoftSampleSet: sortedNotes

	staccatoLoud _ self midiKeyMapFor: sortedNotes.
	staccatoSoft _ staccatoLoud.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!
staccatoLoudSampleSet: sortedNotes

	staccatoLoud _ self midiKeyMapFor: sortedNotes.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!
staccatoSoftSampleSet: sortedNotes

	staccatoSoft _ self midiKeyMapFor: sortedNotes.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!
sustainedLoudSampleSet: sortedNotes

	sustainedLoud _ self midiKeyMapFor: sortedNotes.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!
sustainedSoftSampleSet: sortedNotes

	sustainedSoft _ self midiKeyMapFor: sortedNotes.
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!
sustainedThreshold

	^ sustainedThreshold
! !
!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!
sustainedThreshold: aNumber

	sustainedThreshold _ aNumber asFloat.
! !
!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!
soundForMidiKey: midiKey dur: d loudness: l
	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."

	| keymap note |
	l >= loudThreshold
		ifTrue: [
			d >= sustainedThreshold
				ifTrue: [keymap _ sustainedLoud]
				ifFalse: [keymap _ staccatoLoud]]
		ifFalse: [
			d >= sustainedThreshold
				ifTrue: [keymap _ sustainedSoft]
				ifFalse: [keymap _ staccatoSoft]].
	keymap ifNil: [keymap _ sustainedLoud].
	note _ (keymap at: midiKey) copy.
	^ note
		setPitch: (AbstractSound pitchForMIDIKey: midiKey)
		dur: d
		loudness: (l * note gain)
! !
!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!
soundForPitch: pitchNameOrNumber dur: d loudness: l
	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."
	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."

	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)
		dur: d
		loudness: l
! !
!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 6/7/1999 11:26'!
buildSmallOrchestra
	"Example of how to build a skeleton orchestra that uses less memory (about 14 MBytes)."
	"SampledInstrument buildSmallOrchestra"

	| dir |
	AbstractSound unloadSampledTimbres.
	dir _ 'Tosh:Not Backed Up:Sample Library:Orchestra'.
	#(clarinet oboe bassoon trombone tympani) do: [:instName |
		SampledInstrument
			readSimpleInstrument: instName
			fromDirectory: dir.
		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].
	#(flute bass) do: [:instName |
		SampledInstrument
			readSimpleInstrument: instName
			fromDirectory: dir.
		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].

	(AbstractSound soundNamed: 'bass-f') allNotes do: [:n |
		n firstSample: (n findStartPointForThreshold: 2500)].

	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n |
		n beUnlooped.
		n firstSample: (n findStartPointForThreshold: 0)].

	(AbstractSound soundNamed: 'trombone-f') allNotes do: [:n |
		n firstSample: (n findStartPointForThreshold: 1800)].

	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').
	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').
	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').
	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').
	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').

	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n | n beUnlooped].

! !
!SampledInstrument class methodsFor: 'instance creation' stamp: 'jmv 3/13/2012 12:44'!
readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir
	"SampledInstrument
		readLoudAndStaccatoInstrument: 'oboe'
		fromDirectory: 'Tosh:Sample Library:Orchestra'"

	| sampleSetDir memBefore memAfter loud short snd |
	sampleSetDir _ orchestraDir, ':', instName.
	memBefore _ Smalltalk garbageCollect.
	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.
	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.
	memAfter _ Smalltalk garbageCollect.
	Transcript show:
		instName, ': ', (memBefore - memAfter) printString,
		' bytes; ', memAfter printString, ' bytes left'; newLine.
	AbstractSound soundNamed: instName, '-f&stacc' put:
		(snd _ SampledInstrument new
			allSampleSets: loud;
			staccatoLoudAndSoftSampleSet: short).
	"fix slow attacks"
	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].

	AbstractSound soundNamed: instName, '-f' put:
		(snd _ SampledInstrument new
			allSampleSets: loud).
	"fix slow attacks"
	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].
! !
!SampledInstrument class methodsFor: 'instance creation' stamp: 'jmv 3/13/2012 12:44'!
readPizzInstrument: instName fromDirectory: orchestraDir
	"SampledInstrument
		readPizzInstrument: 'violin'
		fromDirectory: 'Tosh:Sample Library:Orchestra'"

	| sampleSetDir memBefore memAfter sampleSet snd |
	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.
	memBefore _ Smalltalk garbageCollect.
	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.
	memAfter _ Smalltalk garbageCollect.
	Transcript show:
		instName, ': ', (memBefore - memAfter) printString,
		' bytes; ', memAfter printString, ' bytes left'; newLine.
	AbstractSound soundNamed: instName, '-pizz' put:
		(snd _ SampledInstrument new allSampleSets: sampleSet).

	"fix slow attacks"
	snd allNotes do: [:n |
		n firstSample: (n findStartPointForThreshold: 1000)].

	^ snd
! !
!SampledInstrument class methodsFor: 'instance creation' stamp: 'jmv 3/13/2012 12:45'!
readSimpleInstrument: instName fromDirectory: orchestraDir
	"SampledInstrument
		readSimpleInstrument: 'oboe'
		fromDirectory: 'Tosh:Sample Library:Orchestra'"

	| sampleSetDir memBefore memAfter sampleSet snd |
	sampleSetDir _ orchestraDir, ':', instName, ' f'.
	memBefore _ Smalltalk garbageCollect.
	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.
	memAfter _ Smalltalk garbageCollect.
	Transcript show:
		instName, ': ', (memBefore - memAfter) printString,
		' bytes; ', memAfter printString, ' bytes left'; newLine.
	AbstractSound soundNamed: instName, '-f' put:
		(snd _ SampledInstrument new allSampleSets: sampleSet).

	"fix slow attacks"
	snd allNotes do: [:n |
		n firstSample: (n findStartPointForThreshold: 1000)].

	^ snd
! !
!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 14:23'!
bytesPerEncodedFrame
	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."

	self subclassResponsibility.
! !
!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:38'!
decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex
	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	self subclassResponsibility.
! !
!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:39'!
encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex
	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	self subclassResponsibility.
! !
!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:30'!
reset
	"Reset my encoding and decoding state. Optional. This default implementation does nothing."
! !
!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:45'!
samplesPerFrame
	"Answer the number of sound samples per compression frame."

	self subclassResponsibility.
! !
!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!
compressAndDecompress: aSound
	"Compress and decompress the given sound. Useful for testing."
	"(MuLawCodec new compressAndDecompress: (SampledSound soundNamed: 'camera')) play"

	^ (self compressSound: aSound) asSound
! !
!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!
compressSound: aSound
	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."

	| compressed channels |
	compressed _ CompressedSoundData new
		codecName: self class name;
		soundClassName: aSound class name.
	(aSound isKindOf: SampledSound) ifTrue: [
		channels _ Array new: 1.
		channels at: 1 put: (self encodeSoundBuffer: aSound samples).
		compressed
			channels: channels;
			samplingRate: aSound originalSamplingRate;
			firstSample: 1;
			loopEnd: aSound samples size;
			loopLength: 0.0;
			perceivedPitch: 100.0;
			gain: aSound loudness.
		^ compressed].
	(aSound isKindOf: LoopedSampledSound) ifTrue: [
		aSound isStereo
			ifTrue: [
				channels _ Array new: 2.
				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).
				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]
			ifFalse: [
				channels _ Array new: 1.
				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].
		compressed
			channels: channels;
			samplingRate: aSound originalSamplingRate;
			firstSample: aSound firstSample;
			loopEnd: aSound loopEnd;
			loopLength: aSound loopLength;
			perceivedPitch: aSound perceivedPitch;
			gain: aSound gain.
		^ compressed].
	self error: 'you can only compress sampled sounds'.
! !
!SoundCodec methodsFor: 'compress/decompress' stamp: 'RAA 1/2/2001 10:17'!
compressSound: aSound atRate: desiredSampleRate
	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."

	| compressed channels samples newRate ratio buffer |

	compressed _ CompressedSoundData new
		codecName: self class name;
		soundClassName: aSound class name.
	(aSound isKindOf: SampledSound) ifTrue: [
		(desiredSampleRate isNil or: 
				[(ratio _ aSound originalSamplingRate // desiredSampleRate) <= 1]) ifTrue: [
			samples _ aSound samples.
			newRate _ aSound originalSamplingRate.
		] ifFalse: [
			buffer _ aSound samples.
			samples _ SoundBuffer 
				averageEvery: ratio 
				from: buffer 
				upTo: buffer monoSampleCount.
			newRate _ aSound originalSamplingRate / ratio.
		].

		channels _ Array new: 1.
		channels at: 1 put: (self encodeSoundBuffer: samples).
		compressed
			channels: channels;
			samplingRate: newRate;
			firstSample: 1;
			loopEnd: samples size;
			loopLength: 0.0;
			perceivedPitch: 100.0;
			gain: aSound loudness.
		^ compressed].
	(aSound isKindOf: LoopedSampledSound) ifTrue: [
		aSound isStereo
			ifTrue: [
				channels _ Array new: 2.
				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).
				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]
			ifFalse: [
				channels _ Array new: 1.
				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].
		compressed
			channels: channels;
			samplingRate: aSound originalSamplingRate;
			firstSample: aSound firstSample;
			loopEnd: aSound loopEnd;
			loopLength: aSound loopLength;
			perceivedPitch: aSound perceivedPitch;
			gain: aSound gain.
		^ compressed].
	self error: 'you can only compress sampled sounds'.
! !
!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 3/30/1999 08:03'!
decompressSound: aCompressedSound
	"Decompress the entirety of the given compressed sound with this codec and answer the resulting sound."

	| channels sound |
	channels _ aCompressedSound channels
		collect: [:compressed | self decodeCompressedData: compressed].
	'SampledSound' = aCompressedSound soundClassName ifTrue: [
		sound _ SampledSound
			samples: channels first
			samplingRate: (aCompressedSound samplingRate).
		sound loudness: aCompressedSound gain.
		^ sound].
	'LoopedSampledSound' = aCompressedSound soundClassName ifTrue: [
		aCompressedSound loopLength = 0
			ifTrue: [
				sound _ LoopedSampledSound
					unloopedSamples: channels first
					pitch: aCompressedSound perceivedPitch
					samplingRate: aCompressedSound samplingRate]
			ifFalse: [
				sound _ LoopedSampledSound
					samples: channels first
					loopEnd: aCompressedSound loopEnd
					loopLength: aCompressedSound loopLength
					pitch: aCompressedSound perceivedPitch
					samplingRate: aCompressedSound samplingRate].
		channels size > 1 ifTrue: [sound rightSamples: channels last].
		sound
			firstSample: aCompressedSound firstSample;
			gain: aCompressedSound gain.
		sound
			setPitch: 100.0
			dur: (channels first size / aCompressedSound samplingRate)
			loudness: 1.0.
		^ sound].
	self error: 'unknown sound class'.
! !
!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 19:53'!
decodeCompressedData: aByteArray
	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."

	| frameCount result increments |
	frameCount _ self frameCount: aByteArray.
	result _ SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.
	self reset.
	increments _ self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.
	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [
		self error: 'implementation problem; increment sizes should match buffer sizes'].
	^ result
! !
!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 14:20'!
encodeSoundBuffer: aSoundBuffer
	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."

	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i lastIncs |
	frameSize _ self samplesPerFrame.
	fullFrameCount _ aSoundBuffer monoSampleCount // frameSize.
	lastFrameSamples _ aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).
	codeFrameSize _ self bytesPerEncodedFrame.
	codeFrameSize = 0 ifTrue:
		["Allow room for 1 byte per sample for variable-length compression"
		codeFrameSize _ frameSize].
	lastFrameSamples > 0
		ifTrue: [result _ ByteArray new: (fullFrameCount + 1) * codeFrameSize]
		ifFalse: [result _ ByteArray new: fullFrameCount * codeFrameSize].
	self reset.
	increments _ self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.
	lastFrameSamples > 0 ifTrue: [
		finalFrame _ SoundBuffer newMonoSampleCount: frameSize.
		i _ fullFrameCount * frameSize.
		1 to: lastFrameSamples do: [:j |
			finalFrame at: j put: (aSoundBuffer at: (i _ i + 1))].
		lastIncs _ self encodeFrames: 1 from: finalFrame at: 1 into: result at: 1 + increments second.
		increments _ Array with: increments first + lastIncs first
							with: increments second + lastIncs second].
	increments second < result size
		ifTrue: [^ result copyFrom: 1 to: increments second]
		ifFalse: [^ result]
! !
!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 19:54'!
frameCount: aByteArray
	"Compute the frame count for this byteArray.  This default computation will have to be overridden by codecs with variable frame sizes."

	| codeFrameSize |
	codeFrameSize _ self bytesPerEncodedFrame.
	(aByteArray size \\ codeFrameSize) = 0 ifFalse:
		[self error: 'encoded buffer is not an even multiple of the encoded frame size'].
	^ aByteArray size // codeFrameSize! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 12/12/2001 17:57' overrides: 50610321!
bytesPerEncodedFrame
	"Answer the number of bytes required to hold one frame of compressed sound data."
	"Note: When used as a normal codec, the frame size is always 8 samples which results in (8 * bitsPerSample) / 8 = bitsPerSample bytes."

	| bitCount |
	frameSizeMask = 0 ifTrue: [^ bitsPerSample].
	"Following assumes mono:"
	bitCount _ 16 + 6 + ((self samplesPerFrame - 1) * bitsPerSample).
	^ (bitCount + 7) // 8
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 7/2/1999 13:29' overrides: 50610387!
compressAndDecompress: aSound
	"Compress and decompress the given sound. Overridden to use same bits per sample for both compressing and decompressing."

	| compressed decoder |
	compressed _ self compressSound: aSound.
	decoder _ self class new
		initializeForBitsPerSample: bitsPerSample
		samplesPerFrame: 0.
	^ decoder decompressSound: compressed

! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 15:37' overrides: 50610330!
decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex
	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	encodedBytes _ srcByteArray.
	byteIndex _ srcIndex - 1.
	bitPosition _ 0.
	currentByte _ 0.
	samples _ dstSoundBuffer.
	sampleIndex _ dstIndex - 1.
	self privateDecodeMono: (frameCount * self samplesPerFrame).
	^ Array with: (byteIndex - (srcIndex - 1)) with: (sampleIndex - (dstIndex - 1))
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 15:28' overrides: 50610352!
encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex
	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	samples _ srcSoundBuffer.
	sampleIndex _ srcIndex - 1.
	encodedBytes _ dstByteArray.
	byteIndex _ dstIndex - 1.
	bitPosition _ 0.
	currentByte _ 0.
	self privateEncodeMono: (frameCount * self samplesPerFrame).
	^ Array with: frameCount with: (byteIndex - (dstIndex - 1))
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 12/14/2001 11:21' overrides: 50610375!
reset

	self resetForMono.
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 20:12'!
resetForMono
	"Reset my encoding and decoding state for mono."

	predicted _ 0.
	index _ 0.
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 20:12'!
resetForStereo
	"Reset my encoding and decoding state for stereo."

	"keep state as SoundBuffers to allow fast access from primitive"
	predicted _ SoundBuffer new: 2.
	index _ SoundBuffer new: 2.
! !
!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/27/1999 08:34' overrides: 50610381!
samplesPerFrame
	"Answer the number of sound samples per compression frame."

	frameSizeMask > 0 ifTrue: [^ frameSizeMask + 1].
	^ 8  "frame size when there are no running headers"
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 06:26'!
decode: aByteArray bitsPerSample: bits

	^ self
		decode: aByteArray
		sampleCount: (aByteArray size * 8) // bits
		bitsPerSample: bits
		frameSize: 0
		stereo: false
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 15:57'!
decode: aByteArray sampleCount: count bitsPerSample: bits frameSize: frameSize stereo: stereoFlag

	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.
	encodedBytes _ aByteArray.
	byteIndex _ 0.
	bitPosition _ 0.
	currentByte _ 0.
	stereoFlag
		ifTrue: [
			self resetForStereo.
			samples _ SoundBuffer newMonoSampleCount: count.
			rightSamples _ SoundBuffer newMonoSampleCount: count.
			sampleIndex _ 0.
			self privateDecodeStereo: count.
			^ Array with: samples with: rightSamples]
		ifFalse: [
			samples _ SoundBuffer newMonoSampleCount: count.
			sampleIndex _ 0.
			self privateDecodeMono: count.
			^ samples]
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/30/1999 08:56'!
decodeFlash: aByteArray sampleCount: sampleCount stereo: stereoFlag

	| bits |
	encodedBytes _ aByteArray.
	byteIndex _ 0.
	bitPosition _ 0.
	currentByte _ 0.
	bits _ 2 + (self nextBits: 2).  "bits per sample"
	self initializeForBitsPerSample: bits samplesPerFrame: 4096.
	stereoFlag
		ifTrue: [
			self resetForStereo.
			samples _ SoundBuffer newMonoSampleCount: sampleCount.
			rightSamples _ SoundBuffer newMonoSampleCount: sampleCount.
			sampleIndex _ 0.
			self privateDecodeStereo: sampleCount.
			^ Array with: samples with: rightSamples]
		ifFalse: [
			samples _ SoundBuffer newMonoSampleCount: sampleCount.
			sampleIndex _ 0.
			self privateDecodeMono: sampleCount.
			^ Array with: samples].
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 08:59'!
encode: aSoundBuffer bitsPerSample: bits

	^ self
		encodeLeft: aSoundBuffer
		right: nil
		bitsPerSample: bits
		frameSize: 0
		forFlash: false
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 08:58'!
encodeFlashLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits

	^ self
		encodeLeft: leftSoundBuffer
		right: rightSoundBuffer
		bitsPerSample: bits
		frameSize: 4096
		forFlash: true
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 11/21/2001 11:35'!
encodeLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits frameSize: frameSize forFlash: flashFlag

	| stereoFlag sampleCount sampleBitCount bitCount |
	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.
	stereoFlag _ rightSoundBuffer notNil.
	sampleCount _ leftSoundBuffer monoSampleCount.
	stereoFlag
		ifTrue: [sampleBitCount _ 2 * (sampleCount * bitsPerSample)]
		ifFalse: [sampleBitCount _ sampleCount * bitsPerSample].
	bitCount _ sampleBitCount +
		(self headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag).

	encodedBytes _ ByteArray new: ((bitCount / 8) ceiling roundUpTo: self bytesPerEncodedFrame).
	byteIndex _ 0.
	bitPosition _ 0.
	currentByte _ 0.
	flashFlag ifTrue: [self nextBits: 2 put: bits - 2].
	stereoFlag
		ifTrue: [
			samples _ Array with: leftSoundBuffer with: rightSoundBuffer.
			sampleIndex _ Array with: 0 with: 0.
			self privateEncodeStereo: sampleCount]
		ifFalse: [
			samples _ leftSoundBuffer.
			sampleIndex _ 0.
			self privateEncodeMono: sampleCount].

	^ encodedBytes
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/27/1999 12:14'!
headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag
	"Answer the number of extra header bits required for the given number of samples. This will be zero if I am not using frame headers."

	| frameCount bitsPerHeader |
	frameSizeMask = 0 ifTrue: [^ 0].
	frameCount _ (sampleCount / self samplesPerFrame) ceiling.
	bitsPerHeader _ 16 + 6.
	stereoFlag ifTrue: [bitsPerHeader _ 2 * bitsPerHeader].
	^ frameCount * bitsPerHeader
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 16:08'!
indexForDeltaFrom: thisSample to: nextSample
	"Answer the best index to use for the difference between the given samples."
	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."
	"Note: Since there does not appear to be any documentation of how Flash acutally computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."

	| diff bestIndex |
	self inline: true.

	diff _ nextSample - thisSample.
	diff < 0 ifTrue: [diff _ 0 - diff].
	bestIndex _ 63.
	1 to: 62 do: [:j |
		bestIndex = 63 ifTrue: [
			(stepSizeTable at: j) >= diff ifTrue: [bestIndex _ j]]].
	^ bestIndex
! !
!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 20:48'!
initializeForBitsPerSample: sampleBits samplesPerFrame: frameSize

	self resetForMono.
	stepSizeTable _ #(7 8 9 10 11 12 13 14 16 17 19 21 23 25 28 31 34 37 41 45 50 55 60 66 73 80 88 97 107 118 130 143 157 173 190 209 230 253 279 307 337 371 408 449 494 544 598 658 724 796 876 963 1060 1166 1282 1411 1552 1707 1878 2066 2272 2499 2749 3024 3327 3660 4026 4428 4871 5358 5894 6484 7132 7845 8630 9493 10442 11487 12635 13899 15289 16818 18500 20350 22385 24623 27086 29794 32767).

	indexTable _ nil.
	sampleBits = 2 ifTrue: [
		indexTable _ #(-1 2)].
	sampleBits = 3 ifTrue: [
		indexTable _ #(-1 -1 2 4)].
	sampleBits = 4 ifTrue: [
		indexTable _ #(-1 -1 -1 -1 2 4 6 8)].
	sampleBits = 5 ifTrue: [
		indexTable _ #(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16)].
	indexTable ifNil: [self error: 'unimplemented bits/sample'].

	bitsPerSample _ sampleBits.
	deltaSignMask _ 1 bitShift: bitsPerSample - 1.
	deltaValueMask _ deltaSignMask - 1.
	deltaValueHighBit _ deltaSignMask / 2.

	frameSize <= 1
		ifTrue: [frameSizeMask _ 0]
		ifFalse: [
			(frameSize = (1 bitShift: frameSize highBit - 1))
				ifFalse: [self error: 'frameSize must be a power of two'].
			frameSizeMask _ frameSize - 1].

	"keep as SoundBuffer to allow fast access from primitive"
	indexTable _ SoundBuffer fromArray: indexTable.
	stepSizeTable _ SoundBuffer fromArray: stepSizeTable.
! !
!ADPCMCodec methodsFor: 'private' stamp: 'ar 4/23/2001 15:11'!
privateDecodeMono: count

	| delta step predictedDelta bit |
	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>
	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.
	self var: #indexTable declareC: 'short int *indexTable'.
	self var: #samples declareC: 'short int *samples'.
	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.

	1 to: count do: [:i |
		(i bitAnd: frameSizeMask) = 1
			ifTrue: [  "start of frame; read frame header"
				predicted _ self nextBits: 16.
				predicted > 32767 ifTrue: [predicted _ predicted - 65536].
				index _ self nextBits: 6.
				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]
			ifFalse: [
				delta _ self nextBits: bitsPerSample.
				step _ stepSizeTable at: index + 1.
				predictedDelta _ 0.
				bit _ deltaValueHighBit.
				[bit > 0] whileTrue: [
					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta _ predictedDelta + step].
					step _ step bitShift: -1.
					bit _ bit bitShift: -1].
				predictedDelta _ predictedDelta + step.

				(delta bitAnd: deltaSignMask) > 0
					ifTrue: [predicted _ predicted - predictedDelta]
					ifFalse: [predicted _ predicted + predictedDelta].
				predicted > 32767
					ifTrue: [predicted _ 32767]
					ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].

				index _ index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).
				index < 0
					ifTrue: [index _ 0]
					ifFalse: [index > 88 ifTrue: [index _ 88]].

				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]].
! !
!ADPCMCodec methodsFor: 'private' stamp: 'ar 4/23/2001 15:11'!
privateDecodeStereo: count

	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight
	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |

	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>
	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.
	self var: #indexTable declareC: 'short int *indexTable'.
	self var: #samples declareC: 'short int *samples'.
	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.
	self var: #rightSamples declareC: 'short int *rightSamples'.
	self var: #predicted declareC: 'short int *predicted'.
	self var: #index declareC: 'short int *index'.

	"make local copies of decoder state variables"
	predictedLeft _ predicted at: 1.
	predictedRight _ predicted at: 2.
	indexLeft _ index at: 1.
	indexRight _ index at: 2.

	1 to: count do: [:i |
		(i bitAnd: frameSizeMask) = 1
			ifTrue: [  "start of frame; read frame header"
				predictedLeft _ self nextBits: 16.
				indexLeft _ self nextBits: 6.
				predictedRight _ self nextBits: 16.
				indexRight _ self nextBits: 6.
				predictedLeft > 32767 ifTrue: [predictedLeft _ predictedLeft - 65536].
				predictedRight > 32767 ifTrue: [predictedRight _ predictedRight - 65536].
				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.
				rightSamples at: sampleIndex put: predictedRight]
			ifFalse: [
				deltaLeft _ self nextBits: bitsPerSample.
				deltaRight _ self nextBits: bitsPerSample.
				stepLeft _ stepSizeTable at: indexLeft + 1.
				stepRight _ stepSizeTable at: indexRight + 1.
				predictedDeltaLeft _ predictedDeltaRight _ 0.
				bit _ deltaValueHighBit.
				[bit > 0] whileTrue: [
					(deltaLeft bitAnd: bit) > 0 ifTrue: [
						predictedDeltaLeft _ predictedDeltaLeft + stepLeft].
					(deltaRight bitAnd: bit) > 0 ifTrue: [
						predictedDeltaRight _ predictedDeltaRight + stepRight].
					stepLeft _ stepLeft bitShift: -1.
					stepRight _ stepRight bitShift: -1.
					bit _ bit bitShift: -1].
				predictedDeltaLeft _ predictedDeltaLeft + stepLeft.
				predictedDeltaRight _ predictedDeltaRight + stepRight.

				(deltaLeft bitAnd: deltaSignMask) > 0
					ifTrue: [predictedLeft _ predictedLeft - predictedDeltaLeft]
					ifFalse: [predictedLeft _ predictedLeft + predictedDeltaLeft].
				(deltaRight bitAnd: deltaSignMask) > 0
					ifTrue: [predictedRight _ predictedRight - predictedDeltaRight]
					ifFalse: [predictedRight _ predictedRight + predictedDeltaRight].
				predictedLeft > 32767
					ifTrue: [predictedLeft _ 32767]
					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft _ -32768]].
				predictedRight > 32767
					ifTrue: [predictedRight _ 32767]
					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight _ -32768]].

				indexLeft _ indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).
				indexLeft < 0
					ifTrue: [indexLeft _ 0]
					ifFalse: [indexLeft > 88 ifTrue: [indexLeft _ 88]].
				indexRight _ indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).
				indexRight < 0
					ifTrue: [indexRight _ 0]
					ifFalse: [indexRight > 88 ifTrue: [indexRight _ 88]].

				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.
				rightSamples at: sampleIndex put: predictedRight]].

	"save local copies of decoder state variables"
	predicted at: 1 put: predictedLeft.
	predicted at: 2 put: predictedRight.
	index at: 1 put: indexLeft.
	index at: 2 put: indexRight.
! !
!ADPCMCodec methodsFor: 'private' stamp: 'ar 4/23/2001 15:11'!
privateEncodeMono: count

	| step sign diff delta predictedDelta bit p |
	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>
	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.
	self var: #indexTable declareC: 'short int *indexTable'.
	self var: #samples declareC: 'short int *samples'.
	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.

	step _ stepSizeTable at: 1.
	1 to: count do: [:i |
		(i bitAnd: frameSizeMask) = 1 ifTrue: [
			predicted _ samples at: (sampleIndex _ sampleIndex + 1).
			(p _ predicted) < 0 ifTrue: [p _ p + 65536].
			self nextBits: 16 put: p.
			i < count ifTrue: [
				index _ self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].
			self nextBits: 6 put: index.
		] ifFalse: [
			"compute sign and magnitude of difference from the predicted sample"
			sign _ 0.
			diff _ (samples at: (sampleIndex _ sampleIndex + 1)) - predicted.
			diff < 0 ifTrue: [
				sign _ deltaSignMask.
				diff _ 0 - diff].

			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:
				delta _ (4 * diff) / step.
				predictedDelta _ ((delta + 0.5) * step) / 4;
			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."
			delta _ 0.
			predictedDelta _ 0.
			bit _ deltaValueHighBit.
			[bit > 0] whileTrue: [
				diff >= step ifTrue: [
					delta _ delta + bit.
					predictedDelta _ predictedDelta + step.
					diff _ diff - step].
				step _ step bitShift: -1.
				bit _ bit bitShift: -1].
			predictedDelta _ predictedDelta + step.

			"compute and clamp new prediction"
			sign > 0
				ifTrue: [predicted _ predicted - predictedDelta]
				ifFalse: [predicted _ predicted + predictedDelta].
			predicted > 32767
				ifTrue: [predicted _ 32767]
				ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].

			"compute new index and step values"
			index _ index + (indexTable at: delta + 1).
			index < 0
				ifTrue: [index _ 0]
				ifFalse: [index > 88 ifTrue: [index _ 88]].
			step _ stepSizeTable at: index + 1.

			"output encoded, signed delta"
			self nextBits: bitsPerSample put: (sign bitOr: delta)]].

	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"
		encodedBytes at: (byteIndex _ byteIndex + 1) put: currentByte].
! !
!ADPCMCodec methodsFor: 'private' stamp: 'ar 4/23/2001 15:12'!
privateEncodeStereo: count

	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>
	"not yet implemented"
	self inline: false.
	self success: false.! !
!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm 3/28/1999 16:24'!
nextBits: n
	"Answer the next n bits of my bit stream as an unsigned integer."

	| result remaining shift |
	self inline: true.

	result _ 0.
	remaining _ n.
	[true] whileTrue: [
		shift _ remaining - bitPosition.
		result _ result + (currentByte bitShift: shift).
		shift > 0
			ifTrue: [  "consumed currentByte buffer; fetch next byte"
				remaining _ remaining - bitPosition.			
				currentByte _ (encodedBytes at: (byteIndex _ byteIndex + 1)).
				bitPosition _ 8]
			ifFalse: [  "still some bits left in currentByte buffer"
				bitPosition _ bitPosition - remaining.
				"mask out the consumed bits:"
				currentByte _ currentByte bitAnd: (255 bitShift: (bitPosition - 8)).
				^ result]].
! !
!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm 3/28/1999 20:21'!
nextBits: n put: anInteger
	"Write the next n bits to my bit stream."

	| buf bufBits bitsAvailable shift |
	self inline: true.

	buf _ anInteger.
	bufBits _ n.
	[true] whileTrue: [
		bitsAvailable _ 8 - bitPosition.
		shift _ bitsAvailable - bufBits.  "either left or right shift"
		"append high bits of buf to end of currentByte:"
		currentByte _ currentByte + (buf bitShift: shift).
		shift < 0
			ifTrue: [  "currentByte buffer filled; output it"
				encodedBytes at: (byteIndex _ byteIndex + 1) put: currentByte.
				bitPosition _ 0.
				currentByte _ 0.
				"clear saved high bits of buf:"
				buf _ buf bitAnd: (1 bitShift: 0 - shift) - 1.
				bufBits _ bufBits - bitsAvailable]
			ifFalse: [  "still some bits available in currentByte buffer"
				bitPosition _ bitPosition + bufBits.
				^ self]].
! !
!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 3/27/1999 11:15' overrides: 16785646!
new

	^ super new
		initializeForBitsPerSample: 4
		samplesPerFrame: 0.
! !
!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 11/15/2001 16:02'!
newBitsPerSample: bitsPerSample

	^ super new
		initializeForBitsPerSample: bitsPerSample
		samplesPerFrame: 0.
! !
!ADPCMCodec class methodsFor: 'primitive generation' stamp: 'ar 2/3/2001 15:50'!
translatedPrimitives
	"Answer a string containing the translated C code for my primitives."
	"Note: This code currently must be hand-edited to remove several methods that are inlined (thus not needed) but not pruned out by the ST-to-C translator."

	^#(
		(ADPCMCodec privateDecodeMono:)
		(ADPCMCodec privateDecodeStereo:)
		(ADPCMCodec privateEncodeMono:)
		(ADPCMCodec privateEncodeStereo:)
		(ADPCMCodec indexForDeltaFrom:to:)
		(ADPCMCodec nextBits:)
		(ADPCMCodec nextBits:put:))
! !
!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36' overrides: 50610321!
bytesPerEncodedFrame

	^ 33
! !
!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44' overrides: 50610330!
decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex

	| p |
	p _ self	primDecode: decodeState frames: frameCount
			from: srcByteArray at: srcIndex
			into: dstSoundBuffer at: dstIndex.
	^ Array with: p x with: p y
! !
!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44' overrides: 50610352!
encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex

	| p |
	p _ self	primEncode: encodeState frames: frameCount
			from: srcSoundBuffer at: srcIndex
			into: dstByteArray at: dstIndex.
	^ Array with: p x with: p y
! !
!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:32' overrides: 50610375!
reset
	"Reset my encoding/decoding state to prepare to encode or decode a new sound stream."

	encodeState _ self primNewState.
	decodeState _ self primNewState.
! !
!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36' overrides: 50610381!
samplesPerFrame

	^ 160
! !
!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!
primDecode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex

	<primitive: 'primitiveGSMDecode' module: 'SoundCodecPrims'>
	self primitiveFailed.
! !
!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!
primEncode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex

	<primitive: 'primitiveGSMEncode' module: 'SoundCodecPrims'>
	self primitiveFailed.
! !
!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:35'!
primNewState

	<primitive: 'primitiveGSMNewState' module: 'SoundCodecPrims'>
	self error: 'The SoundCodecPrims plugin is not available'.
! !
!GSMCodec class methodsFor: 'instance creation' stamp: 'jm 10/21/2001 10:10' overrides: 16785646!
new

	^ super new reset
! !
!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:15' overrides: 50610321!
bytesPerEncodedFrame
	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."

	^ 1
! !
!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 14:10' overrides: 50610330!
decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex
	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	| dst |
	dst _ dstIndex.
	srcIndex to: srcIndex + frameCount - 1 do: [:src |
		dstSoundBuffer at: dst put: (DecodingTable at: (srcByteArray at: src) + 1).
		dst _ dst + 1].
	^ Array with: frameCount with: frameCount
! !
!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'di 2/8/1999 22:25' overrides: 50610352!
encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex
	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."
	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."

	srcIndex to: srcIndex + frameCount - 1 do: [:i |
		dstByteArray at: i put: (self uLawEncodeSample: (srcSoundBuffer at: i))].
	^ Array with: frameCount with: frameCount
! !
!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:11' overrides: 50610381!
samplesPerFrame
	"Answer the number of sound samples per compression frame."

	^ 1
! !
!MuLawCodec methodsFor: 'external access' stamp: 'di 2/8/1999 22:28'!
uLawDecodeSample: byte
	"Decode a 16-bit signed sample from 8 bits using uLaw decoding"

	^ DecodingTable at: byte + 1! !
!MuLawCodec methodsFor: 'external access' stamp: 'di 2/8/1999 22:30'!
uLawEncodeSample: sample
	"Encode a 16-bit signed sample into 8 bits using uLaw encoding"

	| s |
	s _ sample // 8.  "drop 3 least significant bits"
	s < 0 ifTrue: [^ (self uLawEncode12Bits: 0-s) + 16r80]
		ifFalse: [^ (self uLawEncode12Bits: s)].
! !
!MuLawCodec methodsFor: 'private' stamp: 'di 2/9/1999 13:25'!
uLawEncode12Bits: s
	"Encode a 12-bit unsigned sample (0-4095) into 7 bits using uLaw encoding.
	This gets called by a method that scales 16-bit signed integers down to a
		12-bit magnitude, and then ORs in 16r80 if they were negative.
	Detail: May get called with s >= 4096, and this works fine."

	s < 496 ifTrue: [
		s < 112 ifTrue: [
			s < 48 ifTrue: [
				s < 16
					ifTrue: [^ 16r70 bitOr: (15 - s)]
					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].
			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].
		s < 240
			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]
			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].

	s < 2032 ifTrue: [
		s < 1008
			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]
			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].

	s < 4080
		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]
		ifFalse: [^ 0].
! !
!MuLawCodec class methodsFor: 'class initialization' stamp: 'di 2/9/1999 14:57' overrides: 16904184!
initialize
	"Build the 256 entry table to be used to decode 8-bit uLaw-encoded samples."
	"MuLawCodec initialize"

	| encoded codec lastEncodedPos lastEncodedNeg |
	DecodingTable _ Array new: 256.
	codec _ self new.
	lastEncodedPos _ nil.
	lastEncodedNeg _ nil.
	4095 to: 0 by: -1 do: [:s |
		encoded _ codec uLawEncode12Bits: s.
		lastEncodedPos = encoded
			ifFalse: [
				DecodingTable at: (encoded + 1) put: (s bitShift: 3).
				lastEncodedPos _ encoded].
		encoded _ encoded bitOr: 16r80.
		lastEncodedNeg = encoded
			ifFalse: [
				DecodingTable at: (encoded + 1) put: (s bitShift: 3) negated.
				lastEncodedNeg _ encoded]].
! !
!SoundPlayer class methodsFor: 'snapshotting' stamp: 'ar 2/4/2001 17:59'!
startUpWithSound: aSound
	"Start up the player process."

	SoundPlayer initialize.
	SoundPlayer
		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000
		rate: SamplingRate
		stereo: Stereo
		sound: aSound.
! !
!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/13/97 20:01'!
boinkPitch: p dur: d loudness: l waveTable: waveTable pan: pan
	"Play a decaying note on the given stream using the given wave table. Used for testing only."

	| decay tableSize amplitude increment cycles i |
	decay _ 0.96.
	tableSize _ waveTable size.
	amplitude _ l asInteger min: 1000.
	increment _ ((p asFloat * tableSize asFloat) / SamplingRate asFloat) asInteger.
	increment _ (increment max: 1) min: (tableSize // 2).
	cycles _ (d * SamplingRate asFloat) asInteger.

	i _ 1.
	1 to: cycles do: [:cycle |
		(cycle \\ 100) = 0
			ifTrue: [amplitude _ (decay * amplitude asFloat) asInteger].
		i _ (((i - 1) + increment) \\ tableSize) + 1.
		self playTestSample: (amplitude * (waveTable at: i)) // 1000 pan: pan].
! !
!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 1/5/98 17:56'!
boinkScale
	"Tests the sound output primitives by playing a scale."
	"SoundPlayer boinkScale"

	| sineTable pan |
	self shutDown.
	SamplingRate _ 11025.
	Stereo _ true.
	sineTable _ self sineTable: 1000.
	Buffer _ SoundBuffer newStereoSampleCount: 1000.
	BufferIndex _ 1.
	self primSoundStartBufferSize: Buffer stereoSampleCount
		rate: SamplingRate
		stereo: Stereo.
	pan _ 0.
	#(261.626 293.665 329.628 349.229 391.996 440.001 493.884 523.252) do: [:p |
		self boinkPitch: p dur: 0.3 loudness: 300 waveTable: sineTable pan: pan.
		pan _ pan + 125].

	self boinkPitch: 261.626 dur: 1.0 loudness: 300 waveTable: sineTable pan: 500.
	self primSoundStop.
	self shutDown.
	SoundPlayer initialize.  "reset sampling rate, buffer size, and stereo flag"
! !
!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 12:55'!
playTestSample: s pan: pan
	"Append the given sample in the range [-32767..32767] to the output buffer, playing the output buffer when it is full. Used for testing only."

	| sample leftSample |
	BufferIndex >= Buffer size
		ifTrue: [
			"current buffer is full; play it"
			[self primSoundAvailableBytes > 0]
				whileFalse. "wait for space to be available"
			self primSoundPlaySamples: Buffer stereoSampleCount from: Buffer startingAt: 1.
			Buffer primFill: 0.
			BufferIndex _ 1].

	sample _ s.
	sample >  32767 ifTrue: [ sample _  32767 ]. 
	sample < -32767 ifTrue: [ sample _ -32767 ].

	Stereo
		ifTrue: [
			leftSample _ (sample * pan) // 1000.
			Buffer at: BufferIndex		put: sample - leftSample.
			Buffer at: BufferIndex + 1	put: leftSample]
		ifFalse: [
			Buffer at: BufferIndex + 1 put: sample].
	BufferIndex _ BufferIndex + 2.
! !
!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 20:06'!
sineTable: size
	"Compute a sine table of the given size. Used for testing only."

	| radiansPerStep table |
	table _ Array new: size.
	radiansPerStep _ (2.0 * Float pi) / table size asFloat.
	1 to: table size do: [:i |
		table at: i put:
			(32767.0 * (radiansPerStep * i) sin) asInteger].

	^ table
! !
!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!
bufferMSecs

	^ BufferMSecs
! !
!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 1/27/98 09:28'!
reverbState

	^ ReverbState! !
!SoundPlayer class methodsFor: 'accessing'!
samplingRate

	^ SamplingRate! !
!SoundPlayer class methodsFor: 'accessing' stamp: 'JMM 11/6/2000 10:16'!
setVolumeLeft: aLeftVolume volumeRight: aRightVolume
	"Set sound pass in float 0.0-1.0 for left and right channel, with possible 2.0 or  higher to overdrive sound channel "
	self primSoundSetVolumeLeft: aLeftVolume volumeRight: aRightVolume! !
!SoundPlayer class methodsFor: 'accessing' stamp: 'JMM 11/6/2000 10:17'!
soundVolume
	"Return sound as array of doubles left then right channel, range is 0.0 to 1.0 but may be overdriven"
	^self primSoundGetVolume! !
!SoundPlayer class methodsFor: 'accessing'!
stereo

	^ Stereo
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'ar 2/1/2001 15:20'!
canStartPlayer
	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."

	Preferences canRecordWhilePlaying ifTrue: [^ true].
	SoundRecorder anyActive ifTrue:[^false].
	^ true
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!
isPlaying: aSound
	^ ActiveSounds includes: aSound! !
!SoundPlayer class methodsFor: 'playing' stamp: 'jmv 3/2/2010 10:09'!
pauseSound: aSound
	"Stop playing the given sound. Playing can be resumed from this point later."

	PlayerSemaphore critical: [
		ActiveSounds remove: aSound ifAbsent: nil].
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'ar 2/19/2001 01:28'!
playSound: aSound
	"Reset and start playing the given sound from its beginning."

	aSound reset.
	aSound samplesRemaining = 0 ifTrue:[^self].
	self resumePlaying: aSound.
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!
resumePlaying: aSound
	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."
	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."

	self resumePlaying: aSound quickStart: true.
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'jmv 3/1/2010 13:34'!
resumePlaying: aSound quickStart: quickStart
	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."

	| doQuickStart |
	Preferences soundsEnabled ifFalse: [^ self].
	doQuickStart _ quickStart.
	Preferences soundQuickStart ifFalse: [doQuickStart _ false].
	PlayerProcess ifNil: [
		self canStartPlayer ifFalse: [^ self].
		^self startUpWithSound: aSound].

	PlayerSemaphore critical: [
		(ActiveSounds includes: aSound)
			ifTrue: [doQuickStart _ false]
			ifFalse: [
				doQuickStart ifFalse: [ActiveSounds add: aSound]]].

	"quick-start the given sound, unless the sound player has just started"
	doQuickStart ifTrue: [self startPlayingImmediately: aSound].
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'jm 1/27/98 09:47'!
stopPlayingAll
	"Stop playing all sounds."

	PlayerSemaphore critical: [
		ActiveSounds _ ActiveSounds species new].
! !
!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:49'!
waitUntilDonePlaying: aSound
	"Wait until the given sound is no longer playing."

	[PlayerSemaphore critical: [ActiveSounds includes: aSound]]
		whileTrue: [(Delay forMilliseconds: 100) wait].
! !
!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:13' overrides: 16904184!
initialize
	"SoundPlayer initialize; shutDown; startUp"
	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."

	SamplingRate _ 22050.
	BufferMSecs _ 120.
	Stereo _ true.
	UseReverb ifNil: [UseReverb _ true].
! !
!SoundPlayer class methodsFor: 'initialization' stamp: 'ar 1/24/2002 18:40'!
useLastBuffer
	^LastBuffer notNil! !
!SoundPlayer class methodsFor: 'initialization' stamp: 'ar 1/24/2002 18:47'!
useLastBuffer: aBool
	Buffer ifNil:[^self].
	aBool 
		ifTrue:[LastBuffer _ SoundBuffer basicNew: Buffer basicSize]
		ifFalse:[LastBuffer _ nil]	! !
!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:14'!
useShortBuffer
	"Experimental support for real-time MIDI input. This only works on platforms whose hardware allows very short buffer sizes. It has been tested on a Macintosh Powerbook G3."
	"SoundPlayer useShortBuffer"

	self shutDown.
	BufferMSecs _ 15.
	SoundPlayer
		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000
		rate: SamplingRate
		stereo: Stereo.
! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 1/31/2001 01:32'!
isAllSilence: buffer size: count
	"return true if the buffer is all silence after reverb has ended"
	| value |
	value _ buffer at: 1.
	2 to: count do:[:i| (buffer at: i) = value ifFalse:[^false]].
	^true! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
primSoundAvailableBytes
	"Return the number of bytes of available space in the sound output buffer."
	"Note: Squeak always uses buffers containing 4-bytes per sample (2 channels at 2 bytes per channel) regardless of the state of the Stereo flag."

	<primitive: 'primitiveSoundAvailableSpace' module: 'SoundPlugin'>
	^ self primitiveFailed
! !
!SoundPlayer class methodsFor: 'private' stamp: 'JMM 11/6/2000 10:17'!
primSoundGetVolume
	"Return sound as array of doubles left then right channel, range is 0.0 to 1.0 but may be overdriven"
	<primitive: 'primitiveSoundGetVolume' module: 'SoundPlugin'>
	^Array with: 1.0 with: 1.0! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
primSoundInsertSamples: count from: aSoundBuffer samplesOfLeadTime: anInteger
	"Mix the given number of sample frames from the given sound buffer into the queue of samples that has already been submitted to the sound driver. This primitive is used to start a sound playing with minimum latency, even if large sound output buffers are being used to ensure smooth sound output. Returns the number of samples consumed, or zero if the primitive is not implemented or fails."

	<primitive: 'primitiveSoundInsertSamples' module: 'SoundPlugin'>
	^ 0
! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
primSoundPlaySamples: count from: aSampleBuffer startingAt: index
	"Copy count bytes into the current sound output buffer from the given sample buffer starting at the given index."

	<primitive: 'primitiveSoundPlaySamples' module: 'SoundPlugin'>
	^ self primitiveFailed
! !
!SoundPlayer class methodsFor: 'private' stamp: 'JMM 11/6/2000 10:14'!
primSoundSetVolumeLeft: aLeftVolume volumeRight: aRightVolume
	"Set sound pass in float 0.0-1.0 for left and right channel, with possible 2.0 or  higher to overdrive sound channel "
	<primitive: 'primitiveSoundSetLeftVolume' module: 'SoundPlugin'>
! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag
	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."
	"ar 12/5/1998 Turn off the sound if not supported"
	<primitive: 'primitiveSoundStart' module: 'SoundPlugin'>
	SoundSupported _ false.! !
!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!
primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag semaIndex: anInteger
	"Start double-buffered sound output with the given buffer size and sampling rate. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled when the sound driver is ready to accept another buffer of samples."
	"Details: If this primitive fails, this method tries to use the older version instead."

	<primitive: 'primitiveSoundStartWithSemaphore' module: 'SoundPlugin'>
	UseReadySemaphore _ false.
	self primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag.
! !
!SoundPlayer class methodsFor: 'private' stamp: 'tpr 2/2/2001 19:46'!
primSoundStop
	"Stop double-buffered sound output. Must not raise an error because it is used inside error handling and at system shutdown"

	<primitive: 'primitiveSoundStop' module: 'SoundPlugin'>! !
!SoundPlayer class methodsFor: 'private' stamp: 'jmv 3/1/2010 13:34'!
startPlayingImmediately: aSound
	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."

	| totalSamples buf n leftover src rest |
	"first, fill a double-size buffer with samples"
	"Note: The code below assumes that totalSamples contains two
	 buffers worth of samples, and the insertSamples primitive is
	 expected to consume at least one buffer's worth of these
	 samples. The remaining samples are guaranteed to fit into
	 a single buffer."
	totalSamples _ Buffer stereoSampleCount * 2.  "two buffer's worth"
	buf _ SoundBuffer newStereoSampleCount: totalSamples.
	aSound playSampleCount: totalSamples into: buf startingAt: 1.
	ReverbState ifNotNil: [
		ReverbState applyReverbTo: buf startingAt: 1 count: totalSamples].

	PlayerSemaphore critical: [
		"insert as many samples as possible into the sound driver's buffers"
		n _ self primSoundInsertSamples: totalSamples
			from: buf
			samplesOfLeadTime: 1024.
		n > 0 ifTrue:[
			leftover _ totalSamples - n.

			"copy the remainder of buf into Buffer"
			"Note: the following loop iterates over 16-bit words, not two-word stereo slices"
			"assert: 0 < leftover <= Buffer stereoSampleCount"
			src _ 2 * n.
			1 to: 2 * leftover do:
				[:dst | Buffer at: dst put: (buf at: (src _ src + 1))].

			"generate enough additional samples to finish filling Buffer"
			rest _ Buffer stereoSampleCount - leftover.
			aSound playSampleCount: rest into: Buffer startingAt: leftover + 1.
			ReverbState == nil ifFalse: [
				ReverbState applyReverbTo: Buffer startingAt: leftover + 1 count: rest].

			"record the fact that this sound has already been played into Buffer so that we don't process it again this time around"
			SoundJustStarted _ aSound.
		] ifFalse:[
			"quick start failed; reset the sound so we start over"
			aSound reset.
		].
		ActiveSounds add: aSound].
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jmv 3/1/2010 14:07'!
isReverbOn

	^ ReverbState notNil
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'ar 1/24/2002 18:41'!
lastPlayBuffer
	^LastBuffer! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jmv 3/1/2010 13:33'!
oldStylePlayLoop
	"This version of the play loop is used if the VM does not yet support sound primitives that signal a semaphore when a sound buffer becomes available."

	| bytesPerSlice count |
	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].
	[true] whileTrue: [
		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]
			whileFalse: [(Delay forMilliseconds: 1) wait].

		count _ count min: Buffer stereoSampleCount.
		PlayerSemaphore critical: [
			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].
			ActiveSounds do: [:snd |
				snd ~~ SoundJustStarted ifTrue: [
					snd playSampleCount: count into: Buffer startingAt: 1]].
			ReverbState ifNotNil: [
				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].
			self primSoundPlaySamples: count from: Buffer startingAt: 1.
			Buffer primFill: 0.
			SoundJustStarted _ nil]].
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jmv 3/1/2010 13:34'!
playLoop
	"The sound player process loop."

	| bytesPerSlice count willStop mayStop |
	mayStop _ Preferences soundStopWhenDone.
	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].
	[true] whileTrue: [
		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]
			whileFalse: [ReadyForBuffer wait].

		count _ count min: Buffer stereoSampleCount.
		PlayerSemaphore critical: [
			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].
			ActiveSounds do: [:snd |
				snd ~~ SoundJustStarted ifTrue: [
					snd playSampleCount: count into: Buffer startingAt: 1]].
			ReverbState ifNotNil: [
				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].
			self primSoundPlaySamples: count from: Buffer startingAt: 1.
			willStop _ mayStop and:[
						(ActiveSounds size = 0) and:[
							self isAllSilence: Buffer size: count]].
			LastBuffer ifNotNil:[
				LastBuffer replaceFrom: 1 to: LastBuffer size with: Buffer startingAt: 1.
			].
			willStop
				ifTrue:[self shutDown. PlayerProcess _ nil]
				ifFalse:[Buffer primFill: 0].
			SoundJustStarted _ nil].
		willStop ifTrue:[^self].
	].
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'nk 2/16/2001 13:26'!
playerProcess
	^PlayerProcess! !
!SoundPlayer class methodsFor: 'player process' stamp: 'ar 2/4/2001 18:01'!
startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag
	"Start the sound player process. Terminate the old process, if any."
	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"
	^self startPlayerProcessBufferSize: bufferSize 
			rate: samplesPerSecond 
			stereo: stereoFlag 
			sound: nil! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jmv 10/8/2012 22:14'!
startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound
	"Start the sound player process. Terminate the old process, if any."
	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"

	self stopPlayerProcess.
	aSound
		ifNil:[ActiveSounds _ OrderedCollection new]
		ifNotNil:[ActiveSounds _ OrderedCollection with: aSound].
	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.
	LastBuffer ifNotNil:[LastBuffer _ SoundBuffer basicNew: Buffer basicSize].
	PlayerSemaphore _ Semaphore forMutualExclusion.
	SamplingRate _ samplesPerSecond.
	Stereo _ stereoFlag.
	ReadyForBuffer _ Semaphore new.
	SoundSupported _ true. "Assume so"
	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"
	self primSoundStartBufferSize: Buffer stereoSampleCount
		rate: samplesPerSecond
		stereo: Stereo
		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).
	"Check if sound start prim was successful"
	SoundSupported ifFalse:[^self].
	UseReadySemaphore
		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]
		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].
	UseReverb ifTrue: [self startReverb].

	PlayerProcess
		priority: Processor userInterruptPriority;
		name: 'Sound Player';
		resume! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jm 6/7/1999 10:40'!
startReverb
	"Start a delay-line style reverb with the given tap delays and gains. Tap delays are given in samples and should be prime integers; the following comment gives an expression that generates primes."
	"Integer primesUpTo: 22050"

	UseReverb _ true.
	ReverbState _ ReverbSound new
		tapDelays: #(1601 7919) gains: #(0.12 0.07).
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'ar 1/31/2001 01:13'!
stopPlayerProcess
	"Stop the sound player process."
	"SoundPlayer stopPlayerProcess"

	(PlayerProcess == nil or:[PlayerProcess == Processor activeProcess]) 
		ifFalse:[PlayerProcess terminate].
	PlayerProcess _ nil.
	self primSoundStop.
	ActiveSounds _ OrderedCollection new.
	Buffer _ nil.
	PlayerSemaphore _ Semaphore forMutualExclusion.
	ReadyForBuffer ifNotNil:
		[Smalltalk unregisterExternalObject: ReadyForBuffer].
	ReadyForBuffer _ nil.
! !
!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/27/98 09:43'!
stopReverb

	UseReverb _ false.
	ReverbState _ nil.
! !
!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!
allocateBuffer
	"Allocate a new buffer and reset nextIndex."

	| bufferTime |
	bufferTime _ stereo  "Buffer time = 1/2 second"
		ifTrue: [self samplingRate asInteger]
		ifFalse: [self samplingRate asInteger // 2].
	currentBuffer _ SoundBuffer newMonoSampleCount:
		"Multiple of samplesPerFrame that is approx. bufferTime long"
		(bufferTime truncateTo: self samplesPerFrame).
	nextIndex _ 1.
! !
!SoundRecorder methodsFor: 'private' stamp: 'RAA 1/2/2001 10:17'!
emitBuffer: buffer

	| sound ratio resultBuf |

	"since some sound recording devices cannot (or will not) record below a certain sample rate,
	trim the samples down if the user really wanted fewer samples"

	(desiredSampleRate isNil or: [(ratio _ samplingRate // desiredSampleRate) <= 1]) ifTrue: [
		sound _ SampledSound new setSamples: buffer samplingRate: samplingRate.
	] ifFalse: [
		resultBuf _ SoundBuffer 
			averageEvery: ratio 
			from: buffer 
			upTo: buffer monoSampleCount.
		sound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate / ratio.
	].

	recordedSound add: (codec ifNil: [sound] ifNotNil: [codec compressSound: sound])! !
!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!
emitPartialBuffer
	| s |
	s _ self samplesPerFrame.
	self emitBuffer: (currentBuffer copyFrom: 1 to: ((nextIndex-1) +( s-1) truncateTo: s))! !
!SoundRecorder methodsFor: 'private' stamp: 'jm 9/2/97 16:16'!
meterFrom: start count: count in: buffer
	"Update the meter level with the maximum signal level in the given range of the given buffer."

	| last max sample |
	count = 0 ifTrue: [^ self].  "no new samples"
	last _ start + count - 1.
	max _ 0.
	start to: last do: [:i |
		sample _ buffer at: i.
		sample < 0 ifTrue: [sample _ sample negated].
		sample > max ifTrue: [max _ sample]].
	meterLevel _ max.
! !
!SoundRecorder methodsFor: 'private' stamp: 'di 2/16/1999 08:55'!
recordLoop
	"Record process loop that records samples."

	| n sampleCount |
	n _ 0.
	[true] whileTrue: [
		n = 0 ifTrue: [bufferAvailableSema wait].
		paused
			ifTrue: [
				n _ self primRecordSamplesInto: meteringBuffer startingAt: 1.
				self meterFrom: 1 count: n in: meteringBuffer]
			ifFalse: [
				n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.
				self meterFrom: nextIndex count: n in: currentBuffer.
				nextIndex _ nextIndex + n.
				stereo
					ifTrue: [sampleCount _ currentBuffer stereoSampleCount]
					ifFalse: [sampleCount _ currentBuffer monoSampleCount].
				nextIndex > sampleCount
					ifTrue: [
						self emitBuffer: currentBuffer.
						self allocateBuffer]]].
! !
!SoundRecorder methodsFor: 'private' stamp: 'jmv 3/1/2010 13:35'!
samplesPerFrame
	"Can be overridden to quantize buffer size for, eg, fixed-frame codecs"

	^codec
		ifNil: [1]
		ifNotNil: [codec samplesPerFrame]! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/17/1999 10:54'!
clearRecordedSound
	"Clear the sound recorded thus far. Go into pause mode if currently recording."

	paused _ true.
	recordedSound _ SequentialSound new.
	self allocateBuffer.
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'sw 6/10/2003 12:34'!
hasRecordedSound
	"Answer whether the receiver currently has any recorded sound"

	^ self recordedSound notNil! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 3/1/2010 14:07'!
pause
	"Go into pause mode. The record level continues to be updated, but no sound is recorded."

	paused _ true.
	(currentBuffer notNil and: [nextIndex > 1])
		ifTrue: [
			self emitPartialBuffer.
			self allocateBuffer].

	soundPlaying ifNotNil: [
		soundPlaying pause.
		soundPlaying _ nil].
	"Note: there can be problems if canRecordWhilePlaying is true. Recorders which only pause will inhibit other recorders from recording. I chose to make #stopPlaying unconditional in a subclass. The same might be appropriate here at the expense of making recorders resumable"

	Preferences canRecordWhilePlaying ifFalse: [self stopRecording].
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 10/17/97 14:53'!
playback
	"Playback the sound that has been recorded."

	self pause.
	soundPlaying _ self recordedSound.
	soundPlaying play.
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'RAA 8/13/2000 11:41'!
resumeRecording
	"Continue recording from the point at which it was last paused."

	self flag: #bob.
	"Note: If canRecordWhilePlaying is true, then recordings may never get started (at least by this method). One possibility, used in a subclass, is to make the #startPlaying unconditional. Another would be to use #startPlaying instead of #resumePlaying in appropriate cases"

	Preferences canRecordWhilePlaying ifFalse: [self startRecording].
	paused _ false.
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 10/8/2012 22:13'!
startRecording
	"Turn of the sound input driver and start the recording process. Initially, recording is paused."

	| semaIndex |
	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"
	Preferences canRecordWhilePlaying ifFalse: [SoundPlayer shutDown].
	recordProcess ifNotNil: [self stopRecording].
	paused _ true.
	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.
	meterLevel _ 0.
	self allocateBuffer.
	bufferAvailableSema _ Semaphore new.
	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.
	self primStartRecordingDesiredSampleRate: samplingRate asInteger
		stereo: stereo
		semaIndex: semaIndex.
	RecorderActive _ true.
	samplingRate _ self primGetActualRecordingSampleRate.
	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.
	recordProcess _ [self recordLoop] newProcess.
	recordProcess
		priority: Processor userInterruptPriority;
		name: 'Sound Recorder';
		resume.
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 3/1/2010 14:08'!
stopRecording
	"Stop the recording process and turn of the sound input driver."

	recordProcess ifNotNil: [recordProcess terminate].
	recordProcess _ nil.
	self primStopRecording.
	RecorderActive _ false.
	Smalltalk unregisterExternalObject: bufferAvailableSema.
	(currentBuffer notNil and: [nextIndex > 1])
		ifTrue: [self emitPartialBuffer].
	self initializeRecordingState.
! !
!SoundRecorder methodsFor: 'recording controls' stamp: 'jmv 2/22/2011 22:51'!
verifyExistenceOfRecordedSound
	"If the receiver has a recorded sound, answer true; if not, put up an informer and answer false"

	^ self recordedSound
		ifNotNil:
			[true]
		ifNil: [
			self inform: 'please record a sound first'.
			false]! !
!SoundRecorder methodsFor: 'accessing' stamp: 'di 2/17/1999 11:08'!
codec: aSoundCodec

	codec _ aSoundCodec! !
!SoundRecorder methodsFor: 'accessing' stamp: 'RAA 12/30/2000 10:28'!
desiredSampleRate: newRate

	"use of this method indicates a strong desire for the specified rate, even if
	the OS/hardware are not cooperative"

	desiredSampleRate _ samplingRate _ newRate  "Best are 44100 22050 11025"
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/2/97 16:16'!
isPaused
	"Return true if recording is paused."

	^ paused
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/18/97 19:19'!
meterLevel
	"Return the meter level, an integer in the range [0..100] where zero is silence and 100 represents the maximum signal level possible without clipping."

	^ (100 * meterLevel) // 32768
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!
recordLevel

	^ recordLevel
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!
recordLevel: level
	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."
	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 

	recordLevel _ (level asFloat min: 1.0) max: 0.0.
	recordProcess ifNotNil: [
		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'jm 12/15/97 14:28'!
samplingRate

	^ samplingRate
! !
!SoundRecorder methodsFor: 'accessing' stamp: 'di 2/16/1999 09:58'!
samplingRate: newRate

	samplingRate _ newRate  "Best are 44100 22050 11025"
! !
!SoundRecorder methodsFor: 'results' stamp: 'di 3/4/1999 21:40'!
condensedSamples
	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."

	| sz newBuf i |
	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].
	recordedBuffers isEmpty ifTrue: [^ SoundBuffer new: 0].
	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].
	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].
	newBuf _ SoundBuffer newMonoSampleCount: sz.
	i _ 1.
	recordedBuffers do: [:b |
		1 to: b size do: [:j |
			newBuf at: i put: (b at: j).
			i _ i + 1]].
	recordedBuffers _ nil.
	^ newBuf
! !
!SoundRecorder methodsFor: 'results' stamp: 'di 2/16/1999 20:49'!
condensedStereoSound
	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."

	| sz leftBuf rightBuf leftI rightI left |
	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].
	leftBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.
	rightBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.
	leftI _ rightI _ 1.
	left _ true.
	recordedBuffers do: [:b |
		1 to: b size do: [:j |
			left
				ifTrue: [leftBuf at: leftI put: (b at: j). leftI _ leftI + 1. left _ false]
				ifFalse: [rightBuf at: rightI put: (b at: j). rightI _ rightI + 1. left _ true]]].
	^ MixedSound new
		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;
		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0
! !
!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 11:07'!
recordedSound
	"Return the sound that was recorded."

	^ recordedSound
! !
!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 21:24'!
soundSegments

	^ self segmentsAbove: 1000 normalizedVolume: 80.0
! !
!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/17/97 17:43'!
copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset
	"Return a new SoundBuffer containing the samples in the given range."

	| startBufIndex startSampleIndex endBufIndex endSampleIndex
	 count resultBuf j buf firstInBuf n |
	startBufIndex _ startPlace at: 1.
	startSampleIndex _ startPlace at: 2.
	endBufIndex _ endPlace at: 1.
	endSampleIndex _ endPlace at: 2.

	startBufIndex = endBufIndex
		ifTrue: [count _ endSampleIndex + 1 - startSampleIndex]
		ifFalse: [
			count _ ((recordedBuffers at: startBufIndex) size + 1 - startSampleIndex).  "first buffer"
			count _ count + endSampleIndex.  "last buffer"
			startBufIndex + 1 to: endBufIndex - 1 do:
				[:i | count _ count + (recordedBuffers at: i) size]].  "middle buffers"
	resultBuf _ SoundBuffer newMonoSampleCount: count.

	j _ 1.  "next destination index in resultBuf"
	startBufIndex to: endBufIndex do: [:i |
		buf _ recordedBuffers at: i.
		firstInBuf _ 1.
	 	n _ buf size.
		i = startBufIndex ifTrue: [
			n _ (recordedBuffers at: startBufIndex) size + 1 - startSampleIndex.
			firstInBuf _ startSampleIndex].
		i = endBufIndex ifTrue: [
			i = startBufIndex
				ifTrue: [n _ endSampleIndex + 1 - startSampleIndex]
				ifFalse: [n _ endSampleIndex]].
		self copyTo: resultBuf from: j to: (j + n - 1)
			from: buf startingAt: firstInBuf
			normalize: nFactor dcOffset: dcOffset.
		j _ j + n].
	^ resultBuf
! !
!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:23'!
copyTo: resultBuf from: startIndex to: endIndex from: buf startingAt: firstInBuf normalize: nFactor dcOffset: dcOffset
	"Copy samples from buf to resultBuf removing the DC offset and normalizing their volume in the process."

	| indexOffset |
	indexOffset _ firstInBuf - startIndex.
	startIndex to: endIndex do: [:i |
		resultBuf at: i put: (((buf at: (i + indexOffset)) - dcOffset) * nFactor) // 1000].
! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!
endPlace

	^ Array with: recordedBuffers size with: recordedBuffers last size! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!
firstSampleOverThreshold: threshold dcOffset: dcOffset startingAt: startPlace
	"Beginning at startPlace, this routine will return the first place at which a sample exceeds the given threshold."

	| buf s iStart jStart nThreshold |
	nThreshold _ threshold negated.
	iStart _ startPlace first.
	jStart _ startPlace second.
	iStart to: recordedBuffers size do:
		[:i | buf _ recordedBuffers at: i.
		jStart to: buf size do:
			[:j | s _ (buf at: j) - dcOffset.
			(s < nThreshold or: [s > threshold]) ifTrue:
				["found a sample over threshold"
				^ Array with: i with: j]].
		jStart _ 1].
	^ self endPlace! !
!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:22'!
normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset
	"Return a normalization factor for the range of sample values and DC offset. A normalization factor is a fixed-point number that will be divided by 1000 after multiplication with each sample value."

	| peak factor |
	peak _ (max - dcOffset) max: (min - dcOffset) negated.
	peak = 0 ifTrue: [^ 1000].
	factor _ (32767.0 * percentOfMaxVolume) / (100.0 * peak).
	^ (factor * 1000.0) asInteger
! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:01'!
place: startPlace plus: nSamples
	"Return the place that is nSamples (may be negative) beyond thisPlace."

	| i j remaining buf |
	i _ startPlace first.
	j _ startPlace second.
	nSamples >= 0
	ifTrue: [remaining _ nSamples.
			[buf _ recordedBuffers at: i.
			(j + remaining) <= buf size ifTrue: [^ Array with: i with: j + remaining].
			i < recordedBuffers size]
				whileTrue: [remaining _ remaining - (buf size - j + 1).
							i _ i+1.  j _ 1].
			^ self endPlace]
	ifFalse: [remaining _ nSamples negated.
			[buf _ recordedBuffers at: i.
			(j - remaining) >= 1 ifTrue: [^ Array with: i with: j - remaining].
			i > 1]
				whileTrue: [remaining _ remaining - j.
							i _ i-1.  j _ (recordedBuffers at: i) size].
			^ #(1 1)]! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:19'!
scanForEndThreshold: threshold dcOffset: dcOffset minLull: lull startingAt: startPlace
	"Beginning at startPlace, this routine will find the last sound that exceeds threshold, such that if you look lull samples later you will not find another sound over threshold within the following block of lull samples.
	Return the place that is lull samples beyond to that last sound.
	If no end of sound is found, return endPlace."

	| buf s iStart jStart nThreshold n |
	nThreshold _ threshold negated.
	iStart _ startPlace first.
	jStart _ startPlace second.
	n _ 0.
	iStart to: recordedBuffers size do:
		[:i | buf _ recordedBuffers at: i.
		jStart to: buf size do:
			[:j | s _ (buf at: j) - dcOffset.
			(s < nThreshold or: [s > threshold])
				ifTrue: ["found a sample over threshold"
						n _ 0]
				ifFalse: ["still not over threshold"
						n _ n + 1.
						n >= lull ifTrue: [^ Array with: i with: j]]].
		jStart _ 1].
	^ self endPlace! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:13'!
scanForStartThreshold: threshold dcOffset: dcOffset minDur: duration startingAt: startPlace
	"Beginning at startPlace, this routine will find the first sound that exceeds threshold, such that if you look duration samples later you will find another sound over threshold within the following block of duration samples.
	Return the place that is duration samples prior to that first sound.
	If no sound is found, return endPlace."

	| soundPlace lookPlace nextSoundPlace thirdPlace |
	soundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset
					startingAt: startPlace.
	[soundPlace = self endPlace ifTrue: [^ soundPlace].
	"Found a sound -- look duration later"
	lookPlace _ self place: soundPlace plus: duration.
	nextSoundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset
					startingAt: lookPlace.
	thirdPlace _ self place: lookPlace plus: duration.
	nextSoundPlace first < thirdPlace first
		or: [nextSoundPlace first = thirdPlace first
			and: [nextSoundPlace second < thirdPlace second]]]
		whileFalse: [soundPlace _ nextSoundPlace].

	"Yes, there is sound in the next interval as well"
	^ self place: soundPlace plus: 0-duration
! !
!SoundRecorder methodsFor: 'trimming' stamp: 'jmv 3/1/2010 13:35'!
segmentsAbove: threshold normalizedVolume: percentOfMaxVolume
	"Break the current recording up into a sequence of sound segments separated by silences."

	| max min sum totalSamples bufSize s dcOffset firstPlace endPlace resultBuf nFactor lastPlace segments gapSize minDur minLull soundSize restSize |
	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].
	paused ifFalse: [self error: 'must stop recording before trimming'].
	(recordedSound == nil or: [recordedSound sounds isEmpty]) ifTrue:[^ self].
	"Reconstruct buffers so old trimming code will work"
	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].
	soundSize _ restSize _ 0.

	max _ min _ sum _ totalSamples _ 0.
	recordedBuffers do: [:buf |
		bufSize _ buf size.
		totalSamples _ totalSamples + buf size.
		1 to: bufSize do: [:i |
			s _ buf at: i.
			s > max ifTrue: [max _ s].
			s < min ifTrue: [min _ s].
			sum _ sum + s]].
	dcOffset _ sum // totalSamples.

	minDur _ (samplingRate/20.0) asInteger.  " 1/20 second "
	minLull _ (samplingRate/4.0) asInteger.  " 1/2 second "
	segments _ SequentialSound new.
	endPlace _ self endPlace.
	lastPlace _ #(1 1).
	[firstPlace _ self scanForStartThreshold: threshold
						dcOffset: dcOffset
						minDur: minDur
						startingAt: lastPlace.
	firstPlace = endPlace]
		whileFalse:
		[firstPlace = lastPlace ifFalse:
			["Add a silence equal to the gap size"
			"Wasteful but simple way to get gap size..."
			gapSize _ (self copyFrom: lastPlace to: firstPlace
						normalize: 1000 dcOffset: dcOffset) size - 2.
			"... -2 makes up for overlap of one sample on either end"
			segments add: (RestSound dur: gapSize asFloat / samplingRate).
			restSize _ restSize + gapSize.
"Transcript cr; print: firstPlace; space; print: lastPlace; space; print: gapSize; space; show: 'gap'."
			].
		lastPlace _ self scanForEndThreshold: threshold
						dcOffset: dcOffset
						minLull: minLull + minDur
						startingAt: firstPlace.
		"Allow room for lead time of next sound"
		lastPlace _ self place: lastPlace plus: minDur negated.
		nFactor _ self normalizeFactorFor: percentOfMaxVolume
						min: min max: max dcOffset: dcOffset.
		resultBuf _ self copyFrom: firstPlace to: lastPlace
						normalize: nFactor dcOffset: dcOffset.
		soundSize _ soundSize + resultBuf size.
"Transcript cr; print: firstPlace; space; print: lastPlace; space; print: resultBuf size; space; show: 'sound'."
		segments add: (codec
			ifNil: [SampledSound new setSamples: resultBuf samplingRate: samplingRate]
			ifNotNil: [codec compressSound: (SampledSound new setSamples: resultBuf samplingRate: samplingRate)])].

	"Final gap for consistency"
	gapSize _ (self copyFrom: lastPlace to: self endPlace
				normalize: 1000 dcOffset: dcOffset) size - 1.
	segments add: (RestSound dur: gapSize asFloat / samplingRate).
	restSize _ restSize + gapSize.
	self inform: ((soundSize+restSize/samplingRate) roundTo: 0.1) printString , ' secs reduced to ' , ((soundSize/samplingRate) roundTo: 0.1) printString.
	recordedBuffers _ nil.
	^ segments! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/17/1999 20:38'!
suppressSilence

	recordedSound _ self soundSegments! !
!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:52'!
trim: threshold normalizedVolume: percentOfMaxVolume
	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."

	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |
	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].
	paused ifFalse: [self error: 'must stop recording before trimming'].
	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].
	recordedBuffers isEmpty ifTrue: [^ self].

	max _ min _ sum _ totalSamples _ 0.
	recordedBuffers do: [:buf |
		bufSize _ buf size.
		totalSamples _ totalSamples + buf size.
		1 to: bufSize do: [:i |
			s _ buf at: i.
			s > max ifTrue: [max _ s].
			s < min ifTrue: [min _ s].
			sum _ sum + s]].
	dcOffset _ sum // totalSamples.

	"a place is an array of <buffer index><index of sample in buffer>"
	startPlace _ self scanForStartThreshold: threshold
					dcOffset: dcOffset
					minDur: (samplingRate/60.0) asInteger "at least 1/60th of a second"
					startingAt: #(1 1).
	startPlace = self endPlace ifTrue:
		["no samples above threshold"
		recordedBuffers _ nil.  ^ self].

	endPlace _ self scanForEndThreshold: threshold
					dcOffset: dcOffset
					minLull: (samplingRate/5) asInteger
					startingAt: startPlace.
	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.
	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.
	recordedSound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate.
	recordedBuffers _ nil
! !
!SoundRecorder methodsFor: 'initialization' stamp: 'jm 4/22/1999 14:30' overrides: 16920235!
initialize
	"SoundRecorder new"

	stereo _ false.
	samplingRate _ 11025.
	recordLevel _ 0.5.
	self initializeRecordingState.
! !
!SoundRecorder methodsFor: 'initialization' stamp: 'jhm 10/15/97 14:30'!
initializeRecordingState

	recordProcess _ nil.
	bufferAvailableSema _ nil.
	paused _ true.
	meteringBuffer _ nil.
	meterLevel _ 0.
	soundPlaying _ nil.
	currentBuffer _ nil.
	nextIndex _ 1.
! !
!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primGetActualRecordingSampleRate
	"Return the actual sample rate being used for recording. This primitive fails unless sound recording is currently in progress."

	<primitive: 'primitiveSoundGetRecordingSampleRate' module: 'SoundPlugin'>
	self primitiveFailed
! !
!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primRecordSamplesInto: aWordArray startingAt: index
	"Record a sequence of 16-bit sound samples into the given array starting at the given sample index. Return the number of samples recorded, which may be zero if no samples are currently available."

	<primitive: 'primitiveSoundRecordSamples' module: 'SoundPlugin'>
	self primitiveFailed
! !
!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSetRecordLevel: anInteger
	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."

	<primitive: 'primitiveSoundSetRecordLevel' module: 'SoundPlugin'>
	self primitiveFailed
! !
!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primStartRecordingDesiredSampleRate: samplesPerSec stereo: stereoFlag semaIndex: anInteger
	"Start sound recording with the given stereo setting. Use a sampling rate as close to the desired rate as the underlying platform will support. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled every time a recording buffer is filled."

	<primitive: 'primitiveSoundStartRecording' module: 'SoundPlugin'>
	self primitiveFailed
! !
!SoundRecorder methodsFor: 'primitives' stamp: 'tpr 2/15/2001 17:13'!
primStopRecording
	"Stop sound recording. Does nothing if recording is not currently in progress. Do not fail if plugin is not available"

	<primitive: 'primitiveSoundStopRecording' module: 'SoundPlugin'>! !
!SoundRecorder class methodsFor: 'accessing' stamp: 'ar 2/1/2001 15:20'!
anyActive
	"Return true if any sound recorder is actively recording"
	^RecorderActive == true! !
!SoundRecorder class methodsFor: 'accessing' stamp: 'RAA 8/7/2000 19:23'!
canRecordWhilePlaying
	"Return true if this platform supports simultaneous sound recording and playback."

	^Preferences canRecordWhilePlaying.		"now in preferences"
! !
!SoundRecorder class methodsFor: 'class initialization' stamp: 'RAA 8/7/2000 19:23' overrides: 16904184!
initialize
	"SoundRecorder initialize"
	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."

	CanRecordWhilePlaying _ #ignoredNowInPreferences.
! !
!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24' overrides: 50612102!
allocateBuffer
	"Allocate a new buffer and reset nextIndex. This message is sent by the sound input process."

	currentBuffer _ SoundBuffer newMonoSampleCount: bufferSize.
	nextIndex _ 1.
! !
!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24' overrides: 50612117!
emitBuffer: buffer
	"Queue a buffer for later processing. This message is sent by the sound input process."

	mutex critical: [recordedBuffers addLast: buffer].
! !
!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!
bufferCount
	"Answer the number of sound buffers that have been queued."

	| n |
	mutex ifNil: [^ 0].  "not recording"
	mutex critical: [n _ recordedBuffers size].
	^ n
! !
!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:36'!
bufferSize

	^ bufferSize
! !
!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!
bufferSize: aNumber
	"Set the sound buffer size. Buffers of this size will be queued for the client to process."

	bufferSize _ aNumber truncated.
! !
!SoundInputStream methodsFor: 'accessing' stamp: 'jmv 3/1/2010 14:07'!
isRecording
	"Answer true if the sound input process is running."

	^ recordProcess notNil
! !
!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:32'!
nextBufferOrNil
	"Answer the next input buffer or nil if no buffer is available."

	| result |
	mutex ifNil: [^ nil].  "not recording"
	mutex critical: [
		recordedBuffers size > 0
			ifTrue: [result _ recordedBuffers removeFirst]
			ifFalse: [result _ nil]].
	^ result
! !
!SoundInputStream methodsFor: 'initialization' stamp: 'jm 9/8/1999 15:22' overrides: 50612795!
initialize

	super initialize.
	bufferSize _ 1024.
	mutex _ nil.
! !
!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23' overrides: 50612257!
startRecording
	"Start the sound input process."

	recordProcess ifNotNil: [self stopRecording].
	recordedBuffers _ OrderedCollection new: 100.
	mutex _ Semaphore forMutualExclusion.
	super startRecording.
	paused _ false.
! !
!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23' overrides: 50612289!
stopRecording
	"Turn off the sound input process and close the driver."

	super stopRecording.
	recordedBuffers _ nil.
	mutex _ nil.
! !
!AbstractScoreEvent methodsFor: 'accessing' stamp: 'di 6/17/1999 14:28'!
adjustTimeBy: delta

	time _ time + delta
! !
!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!
endTime
	"Subclasses should override to return the ending time if the event has some duration."

	^ time
! !
!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:43'!
time

	^ time
! !
!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:43'!
time: aNumber

	time _ aNumber.
! !
!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!
isControlChange

	^ false
! !
!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 12/31/97 11:46'!
isNoteEvent

	^ false
! !
!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!
isPitchBend

	^ false
! !
!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!
isProgramChange

	^ false
! !
!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 12/31/97 11:46'!
isTempoEvent

	^ false
! !
!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!
outputOnMidiPort: aMidiPort
	"Output this event to the given MIDI port. This default implementation does nothing."
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel

	^ channel
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel: midiChannel

	channel _ midiChannel.
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!
control

	^ control
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!
control: midiControl

	control _ midiControl.
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!
control: midiControl value: midiControlValue channel: midiChannel

	control _ midiControl.
	value _ midiControlValue.
	channel _ midiChannel.
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02' overrides: 16902254!
value

	^ value
! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!
value: midiControlValue

	value _ midiControlValue.
! !
!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45' overrides: 50612998!
isControlChange

	^ true
! !
!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31' overrides: 50613017!
outputOnMidiPort: aMidiPort
	"Output this event to the given MIDI port."

	aMidiPort
		midiCmd: 16rB0
		channel: channel
		byte: control
		byte: value.
! !
!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:58'!
keyName
	"Return a note name for my pitch."

	| pitchName octave |
	pitchName _ #(c cs d ef e f fs g af a bf b) at: (midiKey \\ 12) + 1.
	octave _ (#(-1 0 1 2 3 4 5 6 7 8 9) at: (midiKey // 12) + 1) printString.
	^ pitchName, octave
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!
channel

	^ channel
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!
channel: midiChannel

	channel _ midiChannel.
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 19:10'!
duration

	^ duration
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:49'!
duration: aNumber

	duration _ aNumber.
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38' overrides: 50612985!
endTime

	^ time + duration
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:07'!
key: midiKeyNum velocity: midiVelocity channel: midiChannel

	midiKey _ midiKeyNum.
	velocity _ midiVelocity.
	channel _ midiChannel.
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 20:58'!
midiKey

	^ midiKey
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:35'!
midiKey: midiKeyNum

	midiKey _ midiKeyNum.
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!
pitch
	"Convert my MIDI key number to a pitch and return it."

	^ AbstractSound pitchForMIDIKey: midiKey
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:32'!
velocity

	^ velocity
! !
!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:51'!
velocity: midiVelocity

	velocity _ midiVelocity.
! !
!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!
endNoteOnMidiPort: aMidiPort
	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"

	aMidiPort
		midiCmd: 16r90
		channel: channel
		byte: midiKey
		byte: 0.
! !
!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!
startNoteOnMidiPort: aMidiPort
	"Output a noteOn event to the given MIDI port."

	aMidiPort
		midiCmd: 16r90
		channel: channel
		byte: midiKey
		byte: velocity.
! !
!NoteEvent methodsFor: 'classification' stamp: 'jm 12/31/97 11:48' overrides: 50613002!
isNoteEvent

	^ true
! !
!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!
bend

	^ bend
! !
!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!
bend: midiPitchBend

	bend _ midiPitchBend.
! !
!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!
bend: midiPitchBend channel: midiChannel

	bend _ midiPitchBend.
	channel _ midiChannel.
! !
!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel

	^ channel
! !
!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel: midiChannel

	channel _ midiChannel.
! !
!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45' overrides: 50613006!
isPitchBend

	^ true
! !
!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31' overrides: 50613017!
outputOnMidiPort: aMidiPort
	"Output this event to the given MIDI port."

	aMidiPort
		midiCmd: 16rE0
		channel: channel
		byte: (bend bitAnd: 16r7F)
		byte: (bend bitShift: -7).
! !
!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel

	^ channel
! !
!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!
channel: midiChannel

	channel _ midiChannel.
! !
!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!
program

	^ program
! !
!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!
program: midiProgramChange

	program _ midiProgramChange.
! !
!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!
program: midiProgramChange channel: midiChannel

	program _ midiProgramChange.
	channel _ midiChannel.
! !
!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46' overrides: 50613010!
isProgramChange

	^ true
! !
!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31' overrides: 50613017!
outputOnMidiPort: aMidiPort
	"Output this event to the given MIDI port."

	aMidiPort
		midiCmd: 16rC0
		channel: channel
		byte: program.
! !
!TempoEvent methodsFor: 'as yet unclassified' stamp: 'jm 12/30/97 10:10' overrides: 50613014!
isTempoEvent

	^ true
! !
!TempoEvent methodsFor: 'as yet unclassified' stamp: 'jm 12/30/97 10:09'!
tempo

	^ tempo
! !
!TempoEvent methodsFor: 'as yet unclassified' stamp: 'jm 12/30/97 10:09'!
tempo: anInteger

	tempo _ anInteger.
! !
!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 1/6/98 23:20'!
asScore

	^ MIDIScore new
		tracks: tracks;
		trackInfo: trackInfo;
		tempoMap: tempoMap;
		ticksPerQuarterNote: ticksPerQuarter
! !
!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jmv 3/13/2012 12:37'!
readHeaderChunk

	| chunkType chunkSize division |
	chunkType _ self readChunkType.
	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].
	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].
	chunkSize _ self readChunkSize.
	fileType _ self next16BitWord.
	trackCount _ self next16BitWord.
	division _ self next16BitWord.
	(division anyMask: 16r8000)
		ifTrue: [self error: 'SMPTE time formats are not yet supported']
		ifFalse: [ticksPerQuarter _ division].
	maxNoteTicks _ 12 * 4 * ticksPerQuarter.
		"longest acceptable note; used to detect stuck notes"

	"sanity checks"
	((chunkSize < 6) or: [chunkSize > 100])
		ifTrue: [self error: 'unexpected MIDI header size ', chunkSize printString].
	(#(0 1 2) includes: fileType)
		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].

	Transcript
		show: 'Reading Type ', fileType printString, ' MIDI File (';
		show: trackCount printString, ' tracks, ';
		show: ticksPerQuarter printString, ' ticks per quarter note)';
		newLine.
! !
!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!
readMIDIFrom: aBinaryStream
	"Read one or more MIDI tracks from the given binary stream."

	stream _ aBinaryStream.
	tracks _ OrderedCollection new.
	trackInfo _ OrderedCollection new.
	self readHeaderChunk.
	trackCount timesRepeat: [self readTrackChunk].
	stream atEnd ifFalse: [self report: 'data beyond final track'].
	fileType = 0 ifTrue: [self splitIntoTracks].
	self guessMissingInstrumentNames.
! !
!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 12/31/97 10:41'!
readTrackChunk

	| chunkType chunkSize |
	chunkType _ self readChunkType.
	[chunkType = 'MTrk'] whileFalse: [
		self report: 'skipping unexpected chunk type "', chunkType, '"'.
		stream skip: (self readChunkSize).  "skip it"
		chunkType _ (stream next: 4) asString].
	chunkSize _ self readChunkSize.
	chunkSize < 10000000 ifFalse: [
		self error: 'suspiciously large track chunk; this may not be MIDI file'].

	self readTrackContents: chunkSize.
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 3/28/98 05:44'!
endAllNotesAt: endTicks
	"End of score; end any notes still sounding."
	"Details: Some MIDI files have missing note-off events, resulting in very long notes. Truncate any such notes encountered."

	| dur |
	activeEvents do: [:e |
		dur _ endTicks - e time.
		dur > maxNoteTicks ifTrue: [dur _ ticksPerQuarter].  "truncate long note"
		e duration: dur].
	activeEvents _ activeEvents species new.
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jmv 3/2/2010 09:56'!
endNote: midiKey chan: channel at: endTicks

	| evt |
	evt _ activeEvents
		detect: [:e | (e midiKey = midiKey) and: [e channel = channel]]
		ifNone: [^ self].
	evt duration: (endTicks - evt time).
	activeEvents remove: evt ifAbsent: nil! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 1/3/98 09:45'!
isTempoTrack: anEventList
	"Return true if the given event list is non-empty and contains only tempo change events."

	anEventList isEmpty ifTrue: [^ false].
	anEventList do: [:evt | evt isTempoEvent ifFalse: [^ false]].
	^ true
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/27/1998 22:15'!
metaEventAt: ticks
	"Read a meta event. Event types appear roughly in order of expected frequency."

	| type length tempo |
	type _ trackStream next.
	length _ self readVarLengthIntFrom: trackStream.

	type = 16r51 ifTrue: [  "tempo"
		tempo _ 0.
		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].
		track add: (TempoEvent new tempo: tempo; time: ticks).
		^ self].

	type = 16r2F ifTrue: [  "end of track"
		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].
		self endAllNotesAt: ticks.
		trackStream skip: length.
		^ self].

	type = 16r58 ifTrue: [  "time signature"
		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].
		trackStream skip: length.
		^ self].

	type = 16r59 ifTrue: [  "key signature"
		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].
		trackStream skip: length.
		^ self].

	((type >= 1) and: [type <= 7]) ifTrue: [  "string"
		strings add: (trackStream next: length) asString.
		^ self].

	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"
	 [(type = 16r7F) or:  "sequencer specific meta event"
	 [(type = 16r00) or:  "sequence number"
	 [(type = 16r20)]]])  "MIDI channel prefix"
		ifTrue: [
			trackStream skip: length.
			^ self].

	type = 16r54 ifTrue: [
		"SMPTE offset"
		self report: 'Ignoring SMPTE offset'.
		trackStream skip: length.
		^ self].

	"skip unrecognized meta event"
	self report:
		'skipping unrecognized meta event: ', (type printStringBase: 16),
		' (', length printString, ' bytes)'.
	trackStream skip: length.
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jmv 3/13/2012 12:37'!
readTrackContents: byteCount

	| info |
	strings _ OrderedCollection new.
	track _ OrderedCollection new.
	trackStream _ ReadStream on: (stream next: byteCount).
	activeEvents _ OrderedCollection new.
	self readTrackEvents.
	(tracks isEmpty and: [self isTempoTrack: track])
		ifTrue: [tempoMap _ track asArray]
		ifFalse: [
			"Note: Tracks without note events are currently not saved to
			 eliminate clutter in the score player. In control applications,
			 this can be easily changed by modifying the following test."
			(self trackContainsNotes: track) ifTrue: [
				tracks add: track asArray.
				info _ WriteStream on: (String new: 100).
				strings do: [:s | info nextPutAll: s; newLine].
				trackInfo add: info contents]].
	strings _ track _ trackStream _ activeEvents _ nil.
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!
readTrackEvents
	"Read the events of the current track."

	| cmd chan key vel ticks byte length evt |
	cmd _ #unknown.
	chan _ key _ vel _ 0.
	ticks _ 0.
	[trackStream atEnd] whileFalse: [
		ticks _ ticks + (self readVarLengthIntFrom: trackStream).
		byte _ trackStream next.
		byte >= 16rF0
			ifTrue: [  "meta or system exclusive event"
				byte = 16rFF ifTrue: [self metaEventAt: ticks].
				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"
					length _ self readVarLengthIntFrom: trackStream.
					trackStream skip: length].
				cmd _ #unknown]
			ifFalse: [  "channel message event"
				byte >= 16r80
					ifTrue: [  "new command"
						cmd _ byte bitAnd: 16rF0.
						chan _ byte bitAnd: 16r0F.
						key _ trackStream next]
					ifFalse: [  "use running status"
						cmd == #unknown
							ifTrue: [self error: 'undefined running status; bad MIDI file?'].
						key _ byte].

				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [
					"all but program change and channel pressure have two data bytes"
					vel _ trackStream next].

				cmd = 16r80 ifTrue: [  "note off"
					self endNote: key chan: chan at: ticks].

				cmd = 16r90 ifTrue: [  "note on"
					vel = 0
						ifTrue: [self endNote: key chan: chan at: ticks]
						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].

				"cmd = 16A0 -- polyphonic key pressure; skip"

				cmd = 16rB0 ifTrue: [
					evt _ ControlChangeEvent new control: key value: vel channel: chan.
					evt time: ticks.
					track add: evt].

				cmd = 16rC0 ifTrue: [
					evt _ ProgramChangeEvent new program: key channel: chan.
					evt time: ticks.
					track add: evt].

				"cmd = 16D0 -- channel aftertouch pressure; skip"

				cmd = 16rE0 ifTrue: [
					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.
					evt time: ticks.
					track add: evt]
	]].
! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jmv 3/2/2010 09:56'!
startNote: midiKey vel: vel chan: chan at: startTicks
	"Record the beginning of a note."
	"Details: Some MIDI scores have missing note-off events, causing a note-on to be received for a (key, channel) that is already sounding. If the previous note is suspiciously long, truncate it."

	| newActiveEvents dur noteOnEvent |
	newActiveEvents _ nil.
	activeEvents do: [:e |
		((e midiKey = midiKey) and: [e channel = chan]) ifTrue: [
			"turn off key already sounding"
			dur _ startTicks - e time.
			dur > maxNoteTicks ifTrue: [dur _ ticksPerQuarter].  "truncate"
			e duration: dur.
			newActiveEvents ifNil: [newActiveEvents _ activeEvents copy].
			newActiveEvents remove: e ifAbsent: nil]].
	newActiveEvents ifNotNil: [activeEvents _ newActiveEvents].

	noteOnEvent _ NoteEvent new key: midiKey velocity: vel channel: chan.
	noteOnEvent time: startTicks.
	track add: noteOnEvent.
	activeEvents add: noteOnEvent! !
!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!
trackContainsNotes: eventList
	"Answer true if the given track contains at least one note event."

	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].
	^ false
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jmv 3/2/2010 09:56'!
guessMissingInstrumentNames
	"Attempt to guess missing instrument names from the first program change in that track."

	| progChange instrIndex instrName |
	1 to: tracks size do: [:i |
		(trackInfo at: i) isEmpty ifTrue: [
			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: nil.
			progChange ifNotNil: [
				instrIndex _ progChange program + 1.
				instrName _ self class standardMIDIInstrumentNames at: instrIndex.
				trackInfo at: i put: instrName]]].
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 10:30'!
next16BitWord
	"Read a 16-bit positive integer from the input stream, most significant byte first."
	"Assume: Stream has at least two bytes left."

	| n |
	n _ stream next.
	^ (n bitShift: 8) + stream next
! !
!MIDIFileReader methodsFor: 'private' stamp: 'ar 1/27/98 17:27'!
next32BitWord: msbFirst
	"Read a 32-bit positive integer from the input stream."
	"Assume: Stream has at least four bytes left."

	| n |
	n _ stream next: 4.
	^msbFirst
		ifTrue:[((n at: 1) bitShift: 24) + ((n at: 2) bitShift: 16) + ((n at: 3) bitShift: 8) + (n at: 4)]
		ifFalse:[((n at: 4) bitShift: 24) + ((n at: 3) bitShift: 16) + ((n at: 2) bitShift: 8) + (n at: 1)]
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 10:29'!
readChunkSize
	"Read a 32-bit positive integer from the next 4 bytes, most significant byte first."
	"Assume: Stream has at least four bytes left."

	| n |
	n _ 0.
	1 to: 4 do: [:ignore | n _ (n bitShift: 8) + stream next].
	^ n
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!
readChunkType
	"Read a chunk ID string from the next 4 bytes."
	"Assume: Stream has at least four bytes left."

	| s |
	s _ String new: 4.
	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].
	^ s
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 12/31/97 11:33'!
readVarLengthIntFrom: aBinaryStream
	"Read a one to four byte positive integer from the given stream, most significant byte first. Use only the lowest seven bits of each byte. The highest bit of a byte is set for all bytes except the last."

	| n byte |
	n _ 0.
	1 to: 4 do: [:ignore |
		byte _ aBinaryStream next.
		byte < 128 ifTrue: [
			n = 0
				ifTrue: [^ byte]  "optimization for one-byte lengths"
				ifFalse: [^ (n bitShift: 7) + byte]].
		n _ (n bitShift: 7) + (byte bitAnd: 16r7F)].

	self error: 'variable length quantity must not exceed four bytes'.
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jmv 3/13/2012 12:37'!
report: aString

	Transcript show: aString; newLine! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 2/1/98 19:20'!
riffSkipToMidiChunk
	"This file is a RIFF file which may (or may not) contain a MIDI chunk. Thanks to Andreas Raab for this code."

	| dwLength fourcc |
	"Read length of all data"
	dwLength := self next32BitWord: false.
	"Get RIFF contents type "
	fourcc := self readChunkType.
	fourcc = 'RMID' ifFalse:[^fourcc]. "We can only read RMID files here"
	"Search for data"
	[[fourcc := self readChunkType.
	dwLength := self next32BitWord: false.
	fourcc = 'data'] whileFalse:[
		"Skip chunk - rounded to word boundary"
		stream skip: (dwLength + 1 bitAnd: 16rFFFFFFFE).
		stream atEnd ifTrue:[^'']].
	"Data chunk is raw - look into if it contains MIDI data and skip if not"
	fourcc := self readChunkType.
	fourcc = 'MThd'] whileFalse:[
		"Skip data (chunk - 4bytes) rounded to word boundary"
		stream skip: (dwLength - 3 bitAnd: 16rFFFFFFFE)].
	^fourcc! !
!MIDIFileReader methodsFor: 'private' stamp: 'jmv 3/1/2010 14:05'!
scanForMIDIHeader
	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."

	| asciiM p lastSearchPosition byte restOfHeader |
	asciiM _ $M asciiValue.
	stream skip: -3.
	p _ stream position.
	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"
	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [
		[(byte _ stream next) ~= asciiM and: [byte notNil]] whileTrue.  "find the next 'M' or file end"
		restOfHeader _ (stream next: 3) asString.
		restOfHeader = 'Thd'
			ifTrue: [^ self]
			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].
		p _ stream position].

	self error: 'MIDI header chunk not found'.
! !
!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!
splitIntoTracks
	"Split a type zero MIDI file into separate tracks by channel number."

	| newTempoMap newTracks |
	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].
	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].
	newTempoMap _ OrderedCollection new.
	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].
	tracks first do: [:e |
		e isTempoEvent
			ifTrue: [newTempoMap addLast: e]
			ifFalse: [(newTracks at: e channel + 1) addLast: e]].
	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].
	newTracks _ newTracks select: [:t | self trackContainsNotes: t].
	tracks _ newTracks collect: [:t | t asArray].
	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).
! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jmv 4/1/2009 21:42'!
playFileNamed: fileName 
"
	ScorePlayerMorph openOn: (self scoreFromFileNamed: fileName)
		title: (FileDirectory localNameFor: fileName)"! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jmv 4/1/2009 21:43'!
playStream: binaryStream 
"
	ScorePlayerMorph openOn: (self scoreFromStream: binaryStream)
		title: 'a MIDI stream'"! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jmv 4/1/2009 21:43'!
playURLNamed: urlString 
"
	| titleString |
	titleString := urlString copyFrom: (urlString findLast: [:c | c = $/]) + 1
				to: urlString size.
	ScorePlayerMorph openOn: (self scoreFromURL: urlString)
		title: titleString"! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'pb 5/25/2016 01:51'!
scoreFromFileNamed: fileName

	| f score |
	f _ (fileName asFileEntry readStream) binary.
	score _ (self new readMIDIFrom: f) asScore.
	f close.
	^ score
! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'ls 8/8/1998 03:14'!
scoreFromStream: binaryStream

	|  score |
	score _ (self new readMIDIFrom: binaryStream) asScore.
	^ score
! !
!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jm 9/12/1998 19:57'!
standardMIDIInstrumentNames
	"Answer an array of Standard MIDI instrument names."

	^ #(
		'Grand Piano'
		'Bright Piano'
		'Electric Grand Piano'
		'Honky-tonk Piano'
		'Electric Piano 1'
		'Electric Piano 2'
		'Harpsichord'
		'Clavichord'
		'Celesta'
		'Glockenspiel'
		'Music Box'
		'Vibraphone'
		'Marimba'
		'Xylophone'
		'Tubular Bells'
		'Duclimer'
		'Drawbar Organ'
		'Percussive Organ'
		'Rock Organ'
		'Church Organ'
		'Reed Organ'
		'Accordion'
		'Harmonica'
		'Tango Accordion'
		'Nylon Guitar'
		'Steel Guitar'
		'Electric Guitar 1'
		'Electric Guitar 2'
		'Electric Guitar 3'
		'Overdrive Guitar'
		'Distorted Guitar'
		'Guitar Harmonics'
		'Acoustic Bass'
		'Electric Bass 1'
		'Electric Bass 2'
		'Fretless Bass'
		'Slap Bass 1'
		'Slap Bass 2'
		'Synth Bass 1'
		'Synth Bass 2'
		'Violin'
		'Viola'
		'Cello'
		'Contrabass'
		'Tremolo Strings'
		'Pizzicato Strings'
		'Orchestral Harp'
		'Timpani'
		'String Ensemble 1'
		'String Ensemble 2'
		'Synth Strings 1'
		'Synth Strings 2'
		'Choir Ahhs'
		'Choir Oohs'
		'Synth Voice'
		'Orchestra Hit'
		'Trumpet'
		'Trombone'
		'Tuba'
		'Muted Trumpet'
		'French Horn'
		'Brass Section'
		'Synth Brass 1'
		'Synth Brass 2'
		'Soprano Sax'
		'Alto Sax'
		'Tenor Sax'
		'Baritone Sax'
		'Oboe'
		'English Horn'
		'Bassoon'
		'Clarinet'
		'Piccolo'
		'Flute'
		'Recorder'
		'Pan Flute'
		'Blown Bottle'
		'Shakuhachi'
		'Whistle'
		'Ocarina'
		'Lead 1 (square)'
		'Lead 2 (sawtooth)'
		'Lead 3 (calliope)'
		'Lead 4 (chiff)'
		'Lead 5 (charang)'
		'Lead 6 (voice)'
		'Lead 7 (fifths)'
		'Lead 8 (bass+lead)'
		'Pad 1 (new age)'
		'Pad 2 (warm)'
		'Pad 3 (polysynth)'
		'Pad 4 (choir)'
		'Pad 5 (bowed)'
		'Pad 6 (metallic)'
		'Pad 7 (halo)'
		'Pad 8 (sweep)'
		'FX 1 (rain)'
		'FX 2 (soundtrack)'
		'FX 3 (crystals)'
		'FX 4 (atmosphere)'
		'FX 5 (brightness)'
		'FX 6 (goblins)'
		'FX 7 (echoes)'
		'FX 8 (sci-fi)'
		'Sitar'
		'Banjo'
		'Shamisen'
		'Koto'
		'Kalimba'
		'Bagpipe'
		'Fiddle'
		'Shanai'
		'Tinkle Bell'
		'Agogo'
		'Steel Drum'
		'Woodblock'
		'Taiko Drum'
		'Melodic Tom'
		'Synth Drum'
		'Reverse Cymbal'
		'Guitar Fret Noise'
		'Breath Noise'
		'Seashore'
		'Bird Tweet'
		'Telephone Ring'
		'Helicopter'
		'Applause'
		'Gunshot')
! !
!MIDIInputParser methodsFor: 'recording' stamp: 'jmv 4/17/2013 12:05'!
clearBuffers
	"Clear the MIDI record buffers. This should be called at the start of recording or real-time MIDI processing."	

	received _ received species new: 5000.
	rawDataBuffer _ ByteArray new: 1000.
	sysExBuffer _ WriteStream on: (ByteArray new: 100).
	midiPort ifNotNil: [midiPort ensureOpen; flushInput].
	startTime _ Time localMillisecondClock.
	state _ #idle.
! !
!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 21:06'!
processMIDIData
	"Process all MIDI data that has arrived since the last time this method was executed. This method should be called frequently to process, filter, and timestamp MIDI data as it arrives."

	| bytesRead |
	[(bytesRead _ midiPort readInto: rawDataBuffer) > 0] whileTrue: [
		timeNow _ (midiPort bufferTimeStampFrom: rawDataBuffer) - startTime.
		5 to: bytesRead do: [:i | self processByte: (rawDataBuffer at: i)]].
! !
!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 20:24'!
received
	"Answer my current collection of all MIDI commands received. Items in this list have the form (<time><cmd byte>[<arg1>[<arg2>]]). Note that the real-time processing facility, midiDo:, removes items from this list as it processes them."

	^ received
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 18:34'!
endSysExclusive: cmdByte
	"Error!! Received 'end system exclusive' command when not receiving system exclusive data."

	self error: 'unexpected ''End of System Exclusive'' command'.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!
ignoreOne: cmdByte
	"Ignore a one argument command."	

	lastCmdByte _ cmdByte.
	lastSelector _ #ignoreOne:.
	state _ #ignore1.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!
ignoreTwo: cmdByte
	"Ignore a two argument command."	

	lastCmdByte _ cmdByte.
	lastSelector _ #ignoreTwo:.
	state _ #ignore2.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:45'!
ignoreZero: cmdByte
	"Ignore a zero argument command, such as tune request or a real-time message. Stay in the current and don't change active status. Note that real-time messages can arrive between data bytes without disruption."	

	"do nothing"
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:36'!
processByte: aByte
	"Process the given incoming MIDI byte and record completed commands."
	"Details: Because this must be fast, it has been hand-tuned. Be careful!!"

	aByte > 247 ifTrue: [  "real-time message; can arrive at any time"
		^ self perform: (cmdActionTable at: aByte) with: aByte].

	#idle = state ifTrue: [
		aByte >= 128
			ifTrue: [  "command byte in idle state: start new command"
				^ self perform: (cmdActionTable at: aByte) with: aByte]
			ifFalse: [  "data byte in idle state: use running status if possible"
				lastCmdByte ifNil: [^ self].  "running status unknown; skip byte"
				"process this data as if it had the last command byte in front of it"
				 self perform: lastSelector with: lastCmdByte.

				"the previous line put us into a new state; we now 'fall through'
				 to process the data byte given this new state."]].

	#ignore1 = state ifTrue: [^ state _ #idle].
	#ignore2 = state ifTrue: [^ state _ #ignore1].

	#want1of2 = state ifTrue: [
		argByte1 _ aByte.
		^ state _ #want2of2].

	#want2of2 = state ifTrue: [
		argByte2 _ aByte.
		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1 with: argByte2).
		^ state _ #idle].

	#want1only = state ifTrue: [
		argByte1 _ aByte.
		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1).
		^ state _ #idle].

	#sysExclusive = state ifTrue: [
		aByte < 128 ifTrue: [
			"record a system exclusive data byte"
			ignoreSysEx ifFalse: [sysExBuffer nextPut: aByte].
			^ self]
		ifFalse: [
			aByte < 248 ifTrue: [
				"a system exclusive message is terminated by any non-real-time command byte"
				ignoreSysEx ifFalse: [
					received addLast: (Array with: timeNow with: lastCmdByte with: sysExBuffer contents)].
				state _ #idle.
				aByte = 247
					ifTrue: [^ self]							"endSysExclusive command, nothing left to do"
					ifFalse: [^ self processByte: aByte]]]].  	"no endSysExclusive; just start the next command"
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!
recordOne: cmdByte
	"Record a one argument command at the current time."	

	lastCmdByte _ cmdByte.
	lastSelector _ #recordOne:.
	state _ #want1only.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!
recordTwo: cmdByte
	"Record a two argument command at the current time."	

	lastCmdByte _ cmdByte.
	lastSelector _ #recordTwo:.
	state _ #want1of2.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:43'!
recordZero: cmdByte
	"Record a zero-byte message, such as tune request or a real-time message. Don't change active status. Note that real-time messages can arrive between data bytes without disruption."	

	received addLast: (Array with: timeNow with: cmdByte).
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:38'!
startSysExclusive: cmdByte
	"The beginning of a variable length 'system exclusive' command."

	sysExBuffer resetContents.
	lastCmdByte _ nil.  "system exclusive commands clear running status"
	lastSelector _ nil.
	state _ #sysExclusive.
! !
!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 17:12'!
undefined: cmdByte
	"We have received an unexpected MIDI byte (e.g., a data byte when we were expecting a command). This should never happen."

	self error: 'unexpected MIDI byte ', cmdByte printString.
! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:39'!
ignoreChannel: channel
	"Don't record any events arriving on the given MIDI channel (in the range 1-16)."

	((channel isInteger not) | (channel < 1) | (channel > 16))
		ifTrue: [^ self error: 'bad MIDI channel number', channel printString].

	"two-arg channel messages"
	#(128 144 160 176 224) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreTwo:].

	"one-arg channel messages"
	#(192 208) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreOne:].
! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:40'!
ignoreCommand: midiCmd
	"Don't record the given MIDI command on any channel."

	| cmd sel | 
	((midiCmd isInteger not) | (midiCmd < 128) | (midiCmd > 255))
		ifTrue: [^ self error: 'bad MIDI command'].

	midiCmd < 240 ifTrue: [  "channel commands; ignore on all channels"
		cmd _ midiCmd bitAnd: 2r11110000.
		sel _ (#(128 144 160 176 224) includes: cmd)
			ifTrue: [#ignoreTwo:]
			ifFalse: [#ignoreOne:].
		 1 to: 16 do: [:ch | cmdActionTable at: (cmd bitOr: ch - 1) put: sel].
		^ self].

	(#(240 241 244 245 247 249 253) includes: midiCmd) ifTrue: [
		^ self error: 'You can''t ignore the undefined MIDI command: ', midiCmd printString].

	midiCmd = 242 ifTrue: [  "two-arg command"
		cmdActionTable at: midiCmd put: #ignoreTwo:.
		 ^ self].

	midiCmd = 243 ifTrue: [  "one-arg command"
		cmdActionTable at: midiCmd put: #ignoreOne:.
		^ self].

	(#(246 248 250 251 252 254 255) includes: midiCmd) ifTrue:	[  "zero-arg command"
		cmdActionTable at: midiCmd put: #ignore.
		 ^ self].

	"we should not get here"
	self error: 'implementation error'.
! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:38'!
ignoreSysEx: aBoolean
	"If the argument is true, then ignore incoming system exclusive message."

	ignoreSysEx _ aBoolean.
! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:46'!
ignoreTuneAndRealTimeCommands
	"Ignore tuning requests and real-time commands."

	cmdActionTable at: 246 put: #ignoreZero:.	"tune request"
	cmdActionTable at: 248 put: #ignoreZero:.	"timing clock"
	cmdActionTable at: 250 put: #ignoreZero:.	"start"
	cmdActionTable at: 251 put: #ignoreZero:.		"continue"
	cmdActionTable at: 252 put: #ignoreZero:.	"stop/Clock"
	cmdActionTable at: 254 put: #ignoreZero:.	"active sensing"
	cmdActionTable at: 255 put: #ignoreZero:.	"system reset"
! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jmv 5/20/2011 11:14'!
noFiltering
	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."

	cmdActionTable _ DefaultMidiTable copy.
	ignoreSysEx _ false! !
!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:50'!
recordOnlyChannels: channelList
	"Record only MIDI data arriving on the given list of channel numbers (in the range 1-16)."

	channelList do: [:ch |
		((ch isInteger not) | (ch < 1) | (ch > 16))
			ifTrue: [^ self error: 'bad Midi channel specification: ', ch printString]].

	1 to: 16 do: [:ch | (channelList includes: ch) ifFalse: [self ignoreChannel: ch]].
! !
!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/9/1998 07:53'!
midiDo: aBlock
	"Poll the incoming MIDI stream in real time and call the given block for each complete command that has been received. The block takes one argument, which is an array of the form (<time><cmd byte>[<arg1>[<arg2>]]). The number of arguments depends on the command byte. For system exclusive commands, the argument is a ByteArray containing the system exclusive message."

	self processMIDIData.
	[received isEmpty] whileFalse:
		[aBlock value: received removeFirst].
! !
!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jmv 1/14/2013 21:13'!
midiDoUntilMouseDown: midiActionBlock
	"Process the incoming MIDI stream in real time by calling midiActionBlock for each MIDI event. This block takes three arguments: the MIDI command byte and two argument bytes. One or both argument bytes may be nil, depending on the MIDI command. If not nil, evaluatue idleBlock regularly whether MIDI data is available or not. Pressing any mouse button terminates the interaction."

	| time cmd arg1 arg2 |
	self clearBuffers.
	[ Sensor isAnyButtonPressed ] whileFalse: [
		self midiDo: [ :item |
			time _ item at: 1.
			cmd _ item at: 2.
			arg1 _ arg2 _ nil.
			item size > 2 ifTrue: [
				arg1 _ item at: 3.
				item size > 3 ifTrue: [arg2 _ item at: 4]].
				midiActionBlock value: cmd value: arg1 value: arg2]].
! !
!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:25'!
midiPort

	^ midiPort
! !
!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:24'!
midiPort: aMIDIPort
	"Use the given MIDI port."

	midiPort _ aMIDIPort.
	self clearBuffers.
! !
!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/8/1998 21:22'!
monitor
	"Print MIDI messages to the transcript until any mouse button is pressed."

	self midiDoUntilMouseDown: [:cmd :arg1 :arg2 |
		self printCmd: cmd with: arg1 with: arg2].
! !
!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jmv 3/13/2012 12:38'!
printCmd: cmdByte with: arg1 with: arg2
	"Print the given MIDI command."

	| cmd ch bend |
	cmdByte < 240
		ifTrue: [  "channel message" 
			cmd _ cmdByte bitAnd: 2r11110000.
			ch _ (cmdByte bitAnd: 2r00001111) + 1]
		ifFalse: [cmd _ cmdByte].  "system message"

	cmd = 128 ifTrue: [
		^ Transcript show: ('key up ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); newLine].
	cmd = 144 ifTrue: [
		^ Transcript show: ('key down: ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); newLine].
	cmd = 160 ifTrue: [
		^ Transcript show: ('key pressure: ', arg1 printString, ' val: ', arg2 printString, ' chan: ', ch printString); newLine].
	cmd = 176 ifTrue: [
		^ Transcript show: ('CC', arg1 printString, ': val: ', arg2 printString, ' chan: ', ch printString); newLine].
	cmd = 192 ifTrue: [
		^ Transcript show: ('prog: ', (arg1 + 1) printString, ' chan: ', ch printString); newLine].
	cmd = 208 ifTrue: [
		^ Transcript show: ('channel pressure ', arg1 printString, ' chan: ', ch printString); newLine].
	cmd = 224 ifTrue: [
		bend _ ((arg2 bitShift: 7) + arg1) - 8192.
		^ Transcript show: ('bend: ', bend printString, ' chan: ', ch printString); newLine].

	cmd = 240 ifTrue: [
		^ Transcript show: ('system exclusive: ', (arg1 at: 1) printString, ' (', arg1 size printString, ' bytes)'); newLine].

	Transcript show: 'cmd: ', cmd printString, ' arg1: ', arg1 printString, ' arg2: ', arg2 printString; newLine.
! !
!MIDIInputParser methodsFor: 'private-other' stamp: 'jm 10/9/1998 07:56'!
setMIDIPort: aMIDIPort
	"Initialize this instance for recording from the given MIDI port. Tune and real-time commands are filtered out by default; the client can send noFiltering to receive these messages."

	midiPort _ aMIDIPort.
	received _ OrderedCollection new.
	self noFiltering.  "initializes cmdActionTable"
	self ignoreTuneAndRealTimeCommands.
! !
!MIDIInputParser class methodsFor: 'class initialization' stamp: 'jm 10/9/1998 07:35' overrides: 16904184!
initialize
	"Build the default MIDI command-byte action table. This table maps MIDI command bytes to the action to be performed when that is received. Note that MIDI data bytes (bytes whose value is < 128) are never used to index into this table."
	"MIDIInputParser initialize"

	DefaultMidiTable _ Array new: 255 withAll: #undefined:.
	128 to: 143 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key off"
	144 to: 159 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key on"
	160 to: 175 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"polyphonic after-touch"
	176 to: 191 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"control change"
	192 to: 207 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"program change"
	208 to: 223 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"channel after-touch"
	224 to: 239 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"pitch bend"

	DefaultMidiTable at: 240 put: #startSysExclusive:.		"start a system exclusive block"
	DefaultMidiTable at: 241 put: #recordOne:.			"MIDI time code quarter frame"
	DefaultMidiTable at: 242 put: #recordTwo:.			"song position select"
	DefaultMidiTable at: 243 put: #recordOne:.			"song select"
	DefaultMidiTable at: 244 put: #undefined:.
	DefaultMidiTable at: 245 put: #undefined:.
	DefaultMidiTable at: 246 put: #recordZero:.			"tune request"
	DefaultMidiTable at: 247 put: #endSysExclusive:.		"end a system exclusive block"
	DefaultMidiTable at: 248 put: #recordZero:.			"timing clock"
	DefaultMidiTable at: 249 put: #undefined:.
	DefaultMidiTable at: 250 put: #recordZero:.			"start"
	DefaultMidiTable at: 251 put: #recordZero:.			"continue"
	DefaultMidiTable at: 252 put: #recordZero:.			"stop/Clock"
	DefaultMidiTable at: 253 put: #undefined:.
	DefaultMidiTable at: 254 put: #recordZero:.			"active sensing"
	DefaultMidiTable at: 255 put: #recordZero:.			"system reset"
! !
!MIDIInputParser class methodsFor: 'instance creation' stamp: 'jm 10/8/1998 20:29'!
on: aSimpleMIDIPort
	"Answer a new MIDI parser on the given port."

	^ super new setMIDIPort: aSimpleMIDIPort
! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/20/1999 00:08'!
appendEvent: noteEvent fullDuration: fullDuration at: selection
	"It is assumed that the noteEvent already has the proper time"

	| track noteLoc |
	track _ tracks at: selection first.
	noteLoc _ selection third + 1.
	noteEvent midiKey = -1
		ifTrue: [noteLoc _ noteLoc - 1]
		ifFalse: ["If not a rest..."
				track _ track copyReplaceFrom: noteLoc to: noteLoc - 1
								with: (Array with: noteEvent)].
	track size >= (noteLoc + 1) ifTrue:
		["Adjust times of following events"
		noteLoc + 1 to: track size do:
			[:i | (track at: i) adjustTimeBy: fullDuration]].
	tracks at: selection first put: track! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 15:12'!
cutSelection: selection

	| track selStartTime delta |
	track _ tracks at: selection first.
	selStartTime _ (track at: selection second) time.
	track _ track copyReplaceFrom: selection second to: selection third with: Array new.
	track size >=  selection second ifTrue:
		["Adjust times of following events"
		delta _ selStartTime - (track at: selection second) time.
		selection second to: track size do:
			[:i | (track at: i) adjustTimeBy: delta]].
	tracks at: selection first put: track! !
!MIDIScore methodsFor: 'editing' stamp: 'jm 9/10/1998 17:22'!
eventForTrack: trackIndex after: eventIndex ticks: scoreTick

	| track evt |
	track _ tracks at: trackIndex.
	eventIndex > track size ifTrue: [^ nil].
	evt _ track at: eventIndex.
	evt time > scoreTick ifTrue: [^ nil].
	^ evt
! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 16:06'!
gridToNextQuarterNote: tickTime

	^ self gridToQuarterNote: tickTime + ticksPerQuarterNote! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 14:55'!
gridToQuarterNote: tickTime

	^ tickTime truncateTo: ticksPerQuarterNote! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 16:14'!
gridTrack: trackIndex toQuarter: quarterDelta at: indexInTrack

	| track selStartTime delta |
	track _ tracks at: trackIndex.
	selStartTime _ (track at: indexInTrack) time.
	delta _ (self gridToQuarterNote: selStartTime + (quarterDelta*ticksPerQuarterNote))
				- selStartTime.
	indexInTrack to: track size do:
		[:i | (track at: i) adjustTimeBy: delta].
! !
!MIDIScore methodsFor: 'editing' stamp: 'di 6/21/1999 10:56'!
insertEvents: events at: selection

	| track selStartTime delta |
	track _ tracks at: selection first.
	selection second = 0
		ifTrue: [selStartTime _ 0.
				selection at: 2 put: 1]
		ifFalse: [selStartTime _ (track at: selection second) time].
	track _ track copyReplaceFrom: selection second to: selection second - 1
				with: (events collect: [:e | e copy]).
	track size >=  (selection second + events size) ifTrue:
		["Adjust times of following events"
		delta _ selStartTime - (track at: selection second) time.
		selection second to: selection second + events size - 1 do:
			[:i | (track at: i) adjustTimeBy: delta].
		delta _ (self gridToNextQuarterNote: (track at: selection second + events size - 1) endTime)
					- (track at: selection second + events size) time.
		selection second + events size to: track size do:
			[:i | (track at: i) adjustTimeBy: delta].
		].
	tracks at: selection first put: track! !
!MIDIScore methodsFor: 'editing' stamp: 'jm 8/6/1998 21:16'!
jitterStartAndEndTimesBy: mSecs

	| r range halfRange oldEnd newEnd newStart |
	r _ Random new.
	range _ 2.0 * mSecs.
	halfRange _ mSecs.
	tracks do: [:t |
		t do: [:e |
			e isNoteEvent ifTrue: [
				oldEnd _ e time + e duration.
				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).
				newStart _ e time + ((r next * range) asInteger - halfRange).
				e time: newStart.
				e duration: (newEnd - newStart)]]].

				! !
!MIDIScore methodsFor: 'nil' stamp: 'jmv 4/6/2009 17:15'!
durationInTicks
	
	| t |
	t _ 0.
	tracks do: [ :track |
		track do:
			[:n | (n isNoteEvent)
				ifTrue: [t _ t max: n endTime]
				ifFalse: [t _ t max: n time]]].
	^ t
! !
!MIDIScore methodsFor: 'initialization' stamp: 'jmv 4/6/2009 17:15' overrides: 16920235!
initialize

	tracks _ #().
	tempoMap _ #().
	ticksPerQuarterNote _ 100.
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/3/98 07:36'!
tempoMap

	^ tempoMap
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/29/98 18:09'!
tempoMap: tempoEventList

	tempoEventList ifNil: [
		tempoMap _ #().
		^ self].
	tempoMap _ tempoEventList asArray.
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/3/98 07:37'!
ticksPerQuarterNote

	^ ticksPerQuarterNote
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/3/98 07:37'!
ticksPerQuarterNote: anInteger

	ticksPerQuarterNote _ anInteger.
! !
!MIDIScore methodsFor: 'accessing' stamp: 'di 10/21/2000 10:02'!
trackInfo

	^ trackInfo ifNil: [tracks collect: [:i | String new]]
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/6/98 23:20'!
trackInfo: trackInfoList

	trackInfo _ trackInfoList asArray.
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jm 1/3/98 08:15'!
tracks

	^ tracks
! !
!MIDIScore methodsFor: 'accessing' stamp: 'jmv 4/6/2009 17:14'!
tracks: trackList

	tracks _ trackList asArray collect: [:trackEvents | trackEvents asArray]! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 22:16'!
channel: i

	^ channels at: i
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:50'!
closeMIDIPort

	midiParser midiPort ifNil: [^ self].
	midiParser midiPort close.
	midiParser midiPort: nil.
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jmv 12/2/2011 09:43' overrides: 16920235!
initialize

	midiParser _ MIDIInputParser on: nil.
	channels _ (1 to: 16) collect: [:ch | MIDISynthChannel new]! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:13'!
instrumentForChannel: channelIndex

	^ (channels at: channelIndex) instrument
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:14'!
instrumentForChannel: channelIndex put: aSoundProto

	(channels at: channelIndex) instrument: aSoundProto.
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:27'!
isOn

	^ process notNil
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 21:52'!
midiParser

	^ midiParser
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:26'!
midiPort

	^ midiParser midiPort
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:32'!
midiPort: aMIDIPortOrNil

	midiParser midiPort: aMIDIPortOrNil.
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/13/1998 12:09'!
midiTrackingLoop

	midiParser clearBuffers.
	[true] whileTrue: [
		self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]].
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 20:12'!
mutedForChannel: channelIndex put: aBoolean

	^ (channels at: channelIndex) muted: aBoolean
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 19:45'!
panForChannel: channelIndex

	^ (channels at: channelIndex) pan
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 19:45'!
panForChannel: channelIndex put: newPan

	(channels at: channelIndex) pan: newPan.
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 14:13'!
processMIDI
	"Process some MIDI commands. Answer true if any commands were processed."

	| didSomething cmdByte byte1 byte2 cmd chan |
	didSomething _ false.
	midiParser midiDo: [:item |
		didSomething _ true.
		cmdByte _ item at: 2.
		byte1 _ byte2 _ nil.
		item size > 2 ifTrue: [
			byte1 _ item at: 3.
			item size > 3 ifTrue: [byte2 _ item at: 4]].
		cmdByte < 240
			ifTrue: [  "channel message" 
				cmd _ cmdByte bitAnd: 2r11110000.
				chan _ (cmdByte bitAnd: 2r00001111) + 1.
				(channels at: chan) doChannelCmd: cmd byte1: byte1 byte2: byte2]
			ifFalse: [  "system message"
				"process system messages here"
			]].
	^ didSomething
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jmv 1/14/2013 21:13'!
processMIDIUntilMouseDown
	"Used for debugging. Do MIDI processing until the mouse is pressed."

	midiParser clearBuffers.
	[ Sensor isAnyButtonPressed ] whileFalse: [ self processMIDI ]! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:36'!
setAllChannelMasterVolumes: aNumber

	| vol |
	vol _ (aNumber asFloat min: 1.0) max: 0.0.
	channels do: [:ch | ch masterVolume: vol].
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jmv 10/8/2012 22:16'!
startMIDITracking

	midiParser ifNil: [^ self].
	midiParser midiPort ifNil: [^ self].
	midiParser midiPort ensureOpen.
	self stopMIDITracking.
	SoundPlayer useShortBuffer.
	process _ [self midiTrackingLoop] newProcess.
	process priority: Processor userInterruptPriority.
	process name: 'MIDISynth'.
	process resume! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:34'!
stopMIDITracking

	process ifNotNil: [
		process terminate.
		process _ nil].
	SoundPlayer shutDown; initialize.  "revert to normal buffer size"
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:40'!
volumeForChannel: channelIndex

	^  (channels at: channelIndex) masterVolume
! !
!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:40'!
volumeForChannel: channelIndex put: newVolume

	(channels at: channelIndex) masterVolume: newVolume.
! !
!MIDISynth class methodsFor: 'examples' stamp: 'jm 1/6/1999 16:39'!
example
	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."
	"MIDISynth example"

	| portNum synth |
	portNum _ SimpleMIDIPort inputPortNumFromUser.
	portNum ifNil: [^ self].
	SoundPlayer useShortBuffer.
	synth _ MIDISynth new
		midiPort: (SimpleMIDIPort openOnPortNumber: portNum).
	synth midiParser ignoreCommand: 224.  "filter out pitch bends"
	1 to: 16 do: [:i |
		(synth channel: i) instrument:
 			 (AbstractSound soundNamed: 'oboe1')].
	1 to: 16 do: [:ch | synth volumeForChannel: ch put: 0.2].

	synth processMIDIUntilMouseDown.
	SoundPlayer shutDown; initialize.  "revert to normal buffer size"
! !
!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 21:45'!
adjustPitch: bend
	"Handle a pitch-bend change."

	| snd pitchAdj centerPitch |
	pitchBend _ bend.
	pitchAdj _ 2.0 raisedTo: (bend asFloat / 8192.0) / 6.0.
	activeSounds copy do: [:entry |
		snd _ entry at: 2.
		centerPitch _ entry at: 3.
		snd pitch: pitchAdj * centerPitch.
		snd internalizeModulationAndRatio].
! !
!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:43'!
convertVelocity: valueByte
	"Map a value in the range 0..127 to a volume in the range 0.0..1.0."
	"Details: A quadratic function seems to give a good keyboard feel."

	| r |
	r _ (valueByte * valueByte) / 12000.0.
	r > 1.0 ifTrue: [^ 1.0].
	r < 0.08 ifTrue: [^ 0.08].
	^ r
! !
!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:41'!
newVolume: valueByte
	"Set the channel volume to the level given by the given number in the range 0..127."

	| snd newVolume |
	channelVolume _ valueByte asFloat / 127.0.
	newVolume _ masterVolume * channelVolume.
	activeSounds do: [:entry |
		snd _ entry at: 2.
		snd adjustVolumeTo: newVolume overMSecs: 10].
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:40'!
channelPressure: newPressure
	"Handle a channel pressure (channel aftertouch) change."

	self newVolume: newPressure.
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:48'!
control: control value: newValue
	"Handle a continuous controller change."

	control = 2 ifTrue: [self newVolume: newValue].  "breath controller"
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:44'!
doChannelCmd: cmdByte byte1: byte1 byte2: byte2
	"Dispatch a channel command with the given arguments."
	"Details: Cases appear in order of expected frequency, most frequent cases first."

	cmdByte = 144 ifTrue: [
		byte2 = 0
			ifTrue: [^ self keyUp: byte1 vel: 0]
			ifFalse: [^ self keyDown: byte1 vel: byte2]].
	cmdByte = 128 ifTrue: [^ self keyUp: byte1 vel: byte2].
	cmdByte = 224 ifTrue: [^ self pitchBend: ((byte2 bitShift: 7) + byte1) - 8192].
	cmdByte = 176 ifTrue: [^ self control: byte1 value: byte2].
	cmdByte = 208 ifTrue: [^ self channelPressure: byte1].
	cmdByte = 160 ifTrue: [^ self key: byte1 pressure: byte2].
	cmdByte = 192 ifTrue: [^ self programChange: byte1].
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!
key: key pressure: press
	"Handle a key pressure (polyphonic aftertouch) change. Rarely implemented."

	"Do nothing for now."
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/10/1999 08:42'!
keyDown: key vel: vel
	"Handle a key down event with non-zero velocity."

	| pitch snd |
	muted ifTrue: [^ self].
	pitch _ AbstractSound pitchForMIDIKey: key.
	snd _ instrument
		soundForPitch: pitch
		dur: 10000.0  "sustain a long time, or until turned off"
		loudness: masterVolume * channelVolume * (self convertVelocity: vel).
	snd _ (MixedSound new add: snd pan: pan) reset.
	SoundPlayer resumePlaying: snd quickStart: false.
	activeSounds add: (Array with: key with: snd with: pitch).
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!
keyUp: key vel: vel
	"Handle a key up event."

	| snd |
	activeSounds copy do: [:entry |
		(entry at: 1) = key ifTrue: [
			snd _ entry at: 2.
			snd stopGracefully.
			activeSounds remove: entry]].
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/11/1999 11:32'!
pitchBend: bend
	"Handle a pitch-bend change."

	self adjustPitch: bend.
! !
!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:50'!
programChange: newProgram
	"Handle a program (instrument) change."

	"Do nothing for now."
! !
!MIDISynthChannel methodsFor: 'initialization' stamp: 'jm 1/6/1999 20:10' overrides: 16920235!
initialize

	instrument _ FMSound default.
	muted _ false.
	masterVolume _ 0.5.
	channelVolume _ 1.0.
	pan _ 0.5.
	pitchBend _ 0.0.
	activeSounds _ OrderedCollection new.
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!
instrument

	^ instrument
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!
instrument: aSound

	instrument _ aSound.
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:47'!
masterVolume

	^ masterVolume
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 11:49'!
masterVolume: aNumber
	"Set the master volume the the given value (0.0 to 1.0)."

	masterVolume _ aNumber asFloat.
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:10'!
muted

	^ muted
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:11'!
muted: aBoolean

	muted _ aBoolean.
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!
pan

	^ pan
! !
!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!
pan: aNumber
	"Set the left-right pan to the given value (0.0 to 1.0)."

	pan _ aNumber asFloat.
! !
!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:47'!
bufferTimeStampFrom: aByteArray
	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."

	^ ((aByteArray at: 1) bitShift: 24) +
	  ((aByteArray at: 2) bitShift: 16) +
	  ((aByteArray at: 3) bitShift: 8) +
	   (aByteArray at: 4)
! !
!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:53'!
flushInput
	"Read any lingering MIDI data from this port's input buffer."

	| buf |
	buf _ ByteArray new: 1000.
	[(self readInto: buf) > 0] whileTrue.
! !
!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/12/1998 15:49'!
readInto: aByteArray
	"Read any data from this port into the given buffer."

	^ self primMIDIReadPort: portNumber into: aByteArray
! !
!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:10'!
close
	"Close this MIDI port."

	portNumber ifNotNil: [self primMIDIClosePort: portNumber].
	accessSema _ nil.
	lastCommandByteOut _ nil.
! !
!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:23'!
ensureOpen
	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."

	portNumber ifNil: [^ self error: 'Use "openOn:" to open a MIDI port initially'].
	self primMIDIClosePort: portNumber.
	self primMIDIOpenPort: portNumber readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.
	accessSema _ Semaphore forMutualExclusion.
	lastCommandByteOut _ Array new: 16 withAll: 0.  "clear running status"
! !
!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:09'!
openOnPortNumber: portNum
	"Open this MIDI port on the given port number."

	self close.
	portNumber _ portNum.
	accessSema _ Semaphore forMutualExclusion.
	self ensureOpen.
! !
!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 15:48'!
portNumber
	"Answer my port number."

	^ portNumber
! !
!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!
midiCmd: cmd channel: channel byte: dataByte
	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."

	accessSema critical: [
		self primMIDIWritePort: portNumber
			from: (ByteArray
					with: (cmd bitOr: channel)
					with: dataByte)
			at: 0].
! !
!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!
midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2
	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."

	accessSema critical: [
		self primMIDIWritePort: portNumber
			from: (ByteArray
					with: (cmd bitOr: channel)
					with: dataByte1
					with: dataByte2)
			at: 0].
! !
!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!
midiOutput: aByteArray
	"Output the given bytes to this MIDI port immediately. Assume that the port is open."

	accessSema critical: [
		self primMIDIWritePort: portNumber from: aByteArray at: 0].
! !
!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primMIDIClosePort: portNum
	"Close the given MIDI port. Don't fail if port is already closed."

	<primitive: 'primitiveMIDIClosePort' module: 'MIDIPlugin'>
! !
!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate
	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."

	<primitive: 'primitiveMIDIOpenPort' module: 'MIDIPlugin'>
	self primitiveFailed.
! !
!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primMIDIReadPort: portNum into: byteArray
	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."

	<primitive: 'primitiveMIDIRead' module: 'MIDIPlugin'>
	self primitiveFailed.
! !
!SimpleMIDIPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primMIDIWritePort: portNum from: byteArray at: midiClockValue
	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."

	<primitive: 'primitiveMIDIWrite' module: 'MIDIPlugin'>
	self primitiveFailed.
! !
!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 1/13/1999 08:11'!
closeAllPorts
	"Close all MIDI ports."
	"SimpleMIDIPort closeAllPorts"

	| lastPortNum |
	lastPortNum _ self primPortCount - 1.
	0 to: lastPortNum do: [:portNum | self basicNew primMIDIClosePort: portNum].
! !
!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jmv 5/13/2018 19:06:00'!
inputPortNumFromUser
	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."
	"
	SimpleMIDIPort inputPortNumFromUser
	"

	| portCount aMenu dir |
	portCount _ self primPortCount.
	portCount = 0 ifTrue: [^ nil].
	aMenu _ PopUpMenu new label: 'MIDI port for input:'.
	0 to: portCount - 1 do:[:i |
		dir _ self primPortDirectionalityOf: i.
		(dir = 1) | (dir = 3) ifTrue:[
			aMenu add: (self portDescription: i) action: i]].
	 ^ aMenu startUpMenu! !
!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:10'!
midiIsSupported
	"Answer true if this platform supports MIDI."

	^ self primPortCount > 0
! !
!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jmv 5/13/2018 19:06:33'!
outputPortNumFromUser
	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."
	"
	SimpleMIDIPort outputPortNumFromUser
	"

	| portCount aMenu dir |
	portCount _ self primPortCount.
	portCount = 0 ifTrue: [^ nil].
	aMenu _ PopUpMenu new label: 'MIDI port for output:'.
	0 to: portCount - 1 do:[:i |
		dir _ self primPortDirectionalityOf: i.
		(dir = 2) | (dir = 3) ifTrue:[
			aMenu add: (self portDescription: i) action: i]].
	 ^ aMenu startUpMenu! !
!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:46'!
portDescription: portNum
	"Answer a string indicating the directionality of the given MIDI port."
	"(0 to: SimpleMIDIPort primPortCount - 1) collect:
		[:i | SimpleMIDIPort portDescription: i]"

	| portName dir |
	portName _ self primPortNameOf: portNum.
	dir _ self primPortDirectionalityOf: portNum.
	dir = 1 ifTrue: [^ portName, ' (in)'].
	dir = 2 ifTrue: [^ portName, ' (out)'].
	dir = 3 ifTrue: [^ portName, ' (in/out)'].
	^ self error: 'unknown MIDI port directionality'
! !
!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33' overrides: 16904184!
initialize
	"SimpleMIDIPort initialize"

	InterfaceClockRate _ 1000000.
	DefaultPortNumber _ 0.
! !
!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!
openDefault
	"Answer a new instance of me opened on the default MIDI port."

	^ self openOnPortNumber: DefaultPortNumber
! !
!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'tk 6/24/1999 11:42'!
openOnPortNumber: portNum
	"Answer a new instance of me for the given MIDI port number."
	"Details: All clients of a particular MIDI port should share the same instance of me. This allows accesses to the port to be serialized and shared port-related state state to be maintained."

	SimpleMIDIPort allSubInstancesDo: [:p |
		p portNumber = portNum ifTrue: [
			"share the existing port object for this port number"
			^ p]].

	^ super new openOnPortNumber: portNum
! !
!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primPortCount
	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."

	<primitive: 'primitiveMIDIGetPortCount' module: 'MIDIPlugin'>
	^ 0
! !
!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primPortDirectionalityOf: portNum
	"Answer the platform-specific name for the given MIDI port."

	<primitive: 'primitiveMIDIGetPortDirectionality' module: 'MIDIPlugin'>
	self primitiveFailed.
! !
!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primPortNameOf: portNum
	"Answer the platform-specific name for the given MIDI port."

	<primitive: 'primitiveMIDIGetPortName' module: 'MIDIPlugin'>
	self primitiveFailed.
! !
!Beeper methodsFor: 'play interface' stamp: 'jmv 6/7/2013 22:03'!
play
	"This is how the default Beeper makes a beep,
	by sending beep to the default sound service.
	The sound system will check if sounds are enabled."

	SoundSystem default beep! !
!Beeper class methodsFor: 'beeping' stamp: 'gk 2/24/2004 08:38'!
beep
	"The preferred way of producing an audible feedback.
	The default playable entity (an instance of Beeper)
	also uses the pluggable SoundService
	mechanism, so it will use the primitive beep only
	if there is no other sound mechanism available."

	self default play
! !
!Beeper class methodsFor: 'beeping' stamp: 'gk 2/24/2004 08:38'!
beepPrimitive
	"Make a primitive beep. Only use this if
	you want to force this to be a primitive beep.
	Otherwise use Beeper class>>beep
	since this method bypasses the current
	registered playable entity."

	Preferences soundsEnabled ifTrue: [
		self primitiveBeep]! !
!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:51'!
clearDefault
	"Clear the default playable.
	Will be lazily initialized in Beeper class >>default."

	default := nil! !
!Beeper class methodsFor: 'customize' stamp: 'jmv 3/2/2010 15:31'!
default
	"When the default is not defined it is
	initialized using #newDefault."

	default ifNil: [ default := self newDefault ].
	^ default! !
!Beeper class methodsFor: 'customize' stamp: 'gk 2/24/2004 22:12'!
newDefault
	"Subclasses may override me to provide a default beep.
	This base implementation returns an instance of Beeper
	which uses the pluggable sound service."

	^ self new! !
!Beeper class methodsFor: 'customize' stamp: 'gk 2/22/2004 17:54'!
setDefault: aPlayableEntity
	"Set the playable entity used when making a beep.
	The playable entity should implement the message #play."

	default := aPlayableEntity! !
!Beeper class methodsFor: 'private' stamp: 'gk 2/24/2004 23:51'!
primitiveBeep
	"Make a primitive beep. Not to be called directly.
	It is much better to use Beeper class>>beep
	or Beeper class>>beepPrimitive
	since this method bypasses the current
	registered playable entity and does not
	check Preferences class>>soundsEnabled."

	<primitive: 140>
	self primitiveFailed! !
!SoundSystem methodsFor: 'misc' stamp: 'jmv 6/7/2013 21:58'!
randomBitsFromSoundInput: bitCount
	"Answer a positive integer with the given number of random bits of 'noise' from a sound input source. Typically, one would use a microphone or line input as the sound source, although many sound cards have enough thermal noise that you get random low-order sample bits even with no microphone connected. Only the least signficant bit of the samples is used. Since not all sound cards support 16-bits of sample resolution, we use the lowest bit that changes."
	"(1 to: 10) collect: [:i | BaseSoundSystem new randomBitsFromSoundInput: 512]"

	| recorder buf mid samples bitMask randomBits bit |
	"collect some sound data"
	recorder _ SoundRecorder new clearRecordedSound.
	recorder resumeRecording.
	(Delay forSeconds: 1) wait.
	recorder stopRecording.
	buf _ recorder condensedSamples.

	"grab bitCount samples from the middle"
	mid _ buf monoSampleCount // 2.
	samples _ buf copyFrom: mid to: mid + bitCount - 1.

	"find the least significant bit that varies"
	bitMask _ 1.
	[bitMask < 16r10000 and:
	 [(samples collect: [:s | s bitAnd: bitMask]) asSet size < 2]]
		whileTrue: [bitMask _ bitMask bitShift: 1].
	bitMask = 16r10000 ifTrue: [^ self error: 'sound samples do not vary'].

	"pack the random bits into a positive integer"
	randomBits _ 0.
	1 to: samples size do: [:i |
		bit _ ((samples at: i) bitAnd: bitMask) = 0 ifTrue: [0] ifFalse: [1].
		randomBits _ (randomBits bitShift: 1) + bit].

	^ randomBits	
! !
!SoundSystem methodsFor: 'misc' stamp: 'jmv 6/7/2013 21:58'!
sampledSoundChoices
	^ SampledSound soundNames! !
!SoundSystem methodsFor: 'misc' stamp: 'jmv 8/9/2018 11:33:08'!
soundNameFromUser
	"Pop up a list of available sound names and answer the one the user chooses, or nil if no choice made"

	^ (SelectionMenu selections: self sampledSoundChoices sorted) startUpWithCaption: 'Sounds'

"
SoundService default soundNameFromUser
"! !
!SoundSystem methodsFor: 'misc' stamp: 'jmv 6/7/2013 21:58'!
soundNamed: soundName
	^ SampledSound soundNamed: soundName! !
!SoundSystem methodsFor: 'playing' stamp: 'jmv 6/7/2013 21:58'!
beep
	"There is sound support, so we use the default
	sampled sound for a beep."

	Preferences soundsEnabled ifTrue: [
		SampledSound beep]! !
!SoundSystem methodsFor: 'playing' stamp: 'jmv 6/7/2013 21:58'!
playSampledSound: samples rate: rate

	Preferences soundsEnabled ifTrue: [
		(SampledSound samples: samples samplingRate: rate) play]! !
!SoundSystem methodsFor: 'playing' stamp: 'jmv 6/7/2013 21:58'!
playSoundNamed: soundName
	"There is sound support, so we play the given sound."

	Preferences soundsEnabled ifTrue: [
		SampledSound playSoundNamed: soundName asString]! !
!SoundSystem methodsFor: 'playing' stamp: 'pb 5/25/2016 01:12'!
playSoundNamed: soundName ifAbsentReadFrom: aifFileName

	Preferences soundsEnabled ifTrue: [
		(SampledSound soundNames includes: soundName) ifFalse: [
			(DirectoryEntry smalltalkImageDirectory // aifFileName) exists ifTrue: [
				SampledSound
					addLibrarySoundNamed: soundName
					fromAIFFfileNamed: aifFileName]].
		(SampledSound soundNames includes: soundName) ifTrue: [
			SampledSound playSoundNamed: soundName]]! !
!SoundSystem methodsFor: 'playing' stamp: 'jmv 6/7/2013 21:58'!
playSoundNamedOrBeep: soundName
	"There is sound support, so we play the given sound
	instead of beeping."

	Preferences soundsEnabled ifTrue: [
		^self playSoundNamed: soundName]! !
!SoundSystem class methodsFor: 'class initialization' stamp: 'jmv 6/7/2013 22:03'!
default
	Default ifNil: [ self initialize ].
	^Default! !
!SoundSystem class methodsFor: 'class initialization' stamp: 'jmv 6/7/2013 22:01' overrides: 16904184!
initialize
	Default _ self new! !
!FileEntry methodsFor: '*Sound' stamp: 'jmv 7/24/2017 16:25:59'!
wavContents
	^SampledSound fromFileEntry: self! !

!classDefinition: #DigitalSignatureAlgorithm category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #DigitalSignatureAlgorithm
	instanceVariableNames: 'randKey randSeed'
	classVariableNames: 'HighBitOfByte SmallPrimes'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: #DigitalSignatureAlgorithm category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #DigitalSignatureAlgorithm
	instanceVariableNames: 'randKey randSeed'
	classVariableNames: 'HighBitOfByte SmallPrimes'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: 'DigitalSignatureAlgorithm class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
DigitalSignatureAlgorithm class
	instanceVariableNames: ''!

!classDefinition: 'DigitalSignatureAlgorithm class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
DigitalSignatureAlgorithm class
	instanceVariableNames: ''!

!classDefinition: #SecureHashAlgorithm category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #SecureHashAlgorithm
	instanceVariableNames: 'totalA totalB totalC totalD totalE totals'
	classVariableNames: 'K1 K2 K3 K4'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: #SecureHashAlgorithm category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #SecureHashAlgorithm
	instanceVariableNames: 'totalA totalB totalC totalD totalE totals'
	classVariableNames: 'K1 K2 K3 K4'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: 'SecureHashAlgorithm class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
SecureHashAlgorithm class
	instanceVariableNames: ''!

!classDefinition: 'SecureHashAlgorithm class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
SecureHashAlgorithm class
	instanceVariableNames: ''!

!classDefinition: #SecureHashAlgorithm256 category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #SecureHashAlgorithm256
	instanceVariableNames: 'totals totalA totalB totalC totalD totalE totalF totalG totalH'
	classVariableNames: 'HashValues RoundConstants'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: #SecureHashAlgorithm256 category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #SecureHashAlgorithm256
	instanceVariableNames: 'totals totalA totalB totalC totalD totalE totalF totalG totalH'
	classVariableNames: 'HashValues RoundConstants'
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: 'SecureHashAlgorithm256 class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
SecureHashAlgorithm256 class
	instanceVariableNames: ''!

!classDefinition: 'SecureHashAlgorithm256 class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
SecureHashAlgorithm256 class
	instanceVariableNames: ''!

!classDefinition: #ThirtyTwoBitRegister category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #ThirtyTwoBitRegister
	instanceVariableNames: 'hi low'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: #ThirtyTwoBitRegister category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
Object subclass: #ThirtyTwoBitRegister
	instanceVariableNames: 'hi low'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cryptography-DigitalSignatures'!

!classDefinition: 'ThirtyTwoBitRegister class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
ThirtyTwoBitRegister class
	instanceVariableNames: ''!

!classDefinition: 'ThirtyTwoBitRegister class' category: 'Cryptography-DigitalSignatures' stamp: 'VV 11/10/2022 00:44:28'!
ThirtyTwoBitRegister class
	instanceVariableNames: ''!
!DigitalSignatureAlgorithm commentStamp: '<historical>' prior: 0!
This class implements the Digital Signature Algorithm (DSA) of the U.S. government's "Digital Signature Standard" (DSS). The DSA algorithm was proposed in 1991 and became a standard in May 1994. The official description is available as a Federal Information Processing Standards Publication (FIPS PUB 186, May 19, 1994). A companion standard, the Secure Hash Standard, or SHS (FIPS PUB 180-1, April 17, 1995), describes a 160-bit message digest algorithm known as the Secure Hash Algorithm (SHA). This message digest is used to compute the document signature.

Here's how to use it:

  1. The "signer" creates a pair of keys. One of these must be kept private. The other may be freely distributed. For example, it could be built into the signature checking code of an application.

  2. When the signer wishes to sign a packet of data (a "message") , he uses the secure hash algorithm to create a 160-bit message digest (hash) which is used as the input to DSA. The result of this is a pair of large numbers called a "signature" that is attached to the original message.

  3. When someone receives a signed message purported to have come from the signer, they compute the 160-bit hash of the message and pass that, along with the message signature and the signer's public key, to the signature verification algorithm. If the signature checks, then it is virtually guaranteed that the message originated from someone who had the signer's private key. That is, the message is not a forgery and has not been modified since it was signed. For example, if the message contains a program, and the recipient trusts the signer, then the recipient can run the program with the assurance that it won't do anything harmful. (At least, not intentionally. A digital signature is no guarantee against bugs!! :->)

The signer must keep the private key secure, since anyone who has the private key can forge the signer's signature on any message they like. As long as the secret key is not stolen, cryptographers believe it to be virtually impossible either to forge a signature, to find a message that matches an existing sigature, or to discover the signer's private key by analyzing message signatures. Knowing the public key (which, for example, could be recovered from an application that had it built in), does not weaken the security at all.

An excellent reference work on digital signatures and cryptography in general is:

  Schneier, Bruce
  "Applied Cryptography: Protocols, Algorithms, and Source Code in C"
  John Wiley and Sons, 1996.

I used this book as a guide to implementing many of the numerical algorithms required by DSA.

Patents and Export Restrictions:

Many digital signature technologies are patented. DSA is also patented, but the patent is owned by the U.S. government which has made DSA available royalty-free. There is a claim that the government patent infringes on an earlier patent by Schnorr, but the government is requiring the use of DSA, so they apparently believe this claim is not strong enough to be a serious threat to their own patent.

Most cryptography technology, including digital signature technology, requires an export license for it to be distributed outside the U.S. Recent legislation may have relaxed the export license requirements, but it would be prudent to check the current regulations before exporting this code.!
!SecureHashAlgorithm commentStamp: '<historical>' prior: 0!
This class implements the Secure Hash Algorithm (SHA) described in the U.S. government's Secure Hash Standard (SHS). This standard is described in FIPS PUB 180-1, "SECURE HASH STANDARD", April 17, 1995.

The Secure Hash Algorithm is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996.

See the comment in class DigitalSignatureAlgorithm for details on its use.

Implementation notes:
The secure hash standard was created with 32-bit hardware in mind. All arithmetic in the hash computation must be done modulo 2^32. This implementation uses ThirtyTwoBitRegister objects to simulate hardware registers; this implementation is about six times faster than using LargePositiveIntegers (measured on a Macintosh G3 Powerbook). Implementing a primitive to process each 64-byte buffer would probably speed up the computation by a factor of 20 or more.
!
!SecureHashAlgorithm256 commentStamp: '<historical>' prior: 0!
Implements the SHA-256 hash algorithm as defined in https://tools.ietf.org/html/rfc6234!
!ThirtyTwoBitRegister commentStamp: 'ul 4/13/2015 05:24' prior: 0!
I represent a 32-bit register. An instance of me can hold any non-negative integer in the range [0..(2^32 - 1)]. Operations are performed on my contents in place, like a hardware register, and results are always modulo 2^32. All operations avoid LargeInteger arithmetic as much as possible.

I'm mainly used by the SecureHashAlgorithm class, but I can be used for implementing other algorithms designed for 32-bit arithmetic. For examble George Marsaglia's Xorshift PRNG from http://www.jstatsoft.org/v08/i14/paper :

"Internal state."
x := ThirtyTwoBitRegister fromInteger: 123456789.
y := ThirtyTwoBitRegister fromInteger: 362436069.
z := ThirtyTwoBitRegister fromInteger: 521288629.
w := ThirtyTwoBitRegister fromInteger: 88675123.
"Temporaries."
t := ThirtyTwoBitRegister new.
temp := nil.
"The algorithm: t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))(t^(t>>8)) );"
xorShift128 := [
	"t=(x^(x<<11));"
	t
		loadFrom: x;
		<< 11;
		bitXor: x.
	"x=y;y=z;z=w;"
	temp := x.
	x := y.
	y := z.
	z := w.
	"w=(w^(w>>19))(t^(t>>8))"
	w := temp.
	w
		loadFrom: z;
		>> 19;
		bitXor: z;
		bitXor: t.
	t >> 8.
	w bitXor: t.
	"Truncate to 30 bits."
	(w hi bitShift: 14) bitXor: w low ].

The code is about 9.5x faster than an implementation using LargeIntegers:

"Implementation using LargeIntegers."
x := 123456789.
y := 362436069.
z := 521288629.
w := 88675123.
largeIntegerXorShift128 := [
	| t |
	t := ((x bitAnd: 16r1FFFFF) bitShift: 11) bitXor: x.
	x := y.
	y := z.
	z := w.
	w := (((w bitShift: -19) bitXor: w) bitXor: t) bitXor: (t bitShift: -8) ].

xorShift128 bench. '4,990,000 per second. 201 nanoseconds per run.'.
largeIntegerXorShift128 bench. '529,000 per second. 1.89 microseconds per run.'.!
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'ul 4/10/2015 20:54'!
>> anInteger
	"Unsigned right shift."

	| bitCount shift |
	bitCount := anInteger.
	bitCount >= 32 ifTrue: [
		hi := low := 0.
		^self ].
	bitCount >= 16 ifTrue: [
		low := hi.
		hi := 0.
		bitCount := bitCount - 16 ].
	bitCount >= 2 ifTrue: [
		shift := 0 - bitCount.
		low := (low bitShift: shift) bitOr: ((hi bitShift: shift + 16) bitAnd: 16rFFFF).
		hi := hi bitShift: shift.
		^self ].
	bitCount >= 1 ifTrue: [
		low := (low bitShift: -1) bitOr: ((hi bitAnd: 16r1) bitShift: 15).
		hi := hi bitShift: -1 ]! !
!ThirtyTwoBitRegister methodsFor: 'printing' stamp: 'laza 3/29/2004 12:22' overrides: 16902975!
printOn: aStream
	"Print my contents in hex with a leading 'R' to show that it is a register object being printed."

	aStream nextPutAll: 'R:'.
	self asInteger storeOn: aStream base: 16.
! !
!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48'!
computeSignatureForMessageHash: hash privateKey: privateKey
	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."

	| p q g x r s k tmp |
	p := privateKey first.
	q := privateKey second.
	g := privateKey third.
	x := privateKey fourth.

	r := s := 0.
	[r = 0 or: [s = 0]] whileTrue: [
		k := self nextRandom160 \\ q.
		r := (g raisedTo: k modulo: p) \\ q.
		tmp := (hash + (x * r)) \\ q.
		s := ((k reciprocalModulo: q) * tmp) \\ q].

	^ Array with: r with: s
! !
!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jmv 5/19/2015 21:41'!
generateKeySet
	"Generate and answer a key set for DSA. The result is a pair (<private key><public key>). Each key is an array of four large integers. The private key is (p, q, g, x); the public one is (p, q, g, y). The signer must be sure to record (p, q, g, x), and must keep x secret to prevent someone from forging their signature."
	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"

	| qAndPandS q p exp g h x y |
	qAndPandS := self generateQandP.
	Transcript show: 'Computing g...'.
	q := qAndPandS first.
	p := qAndPandS second.
	exp := (p - 1) / q.
	h := 2.
	[g := h raisedTo: exp modulo: p. g = 1] whileTrue: [h := h + 1].
	Transcript show: 'done.'; newLine.
	Transcript show: 'Computing x and y...'.
	x := self nextRandom160.
	y := g raisedTo: x modulo: p.
	Transcript show: 'done.'; newLine.
	Transcript show: 'Key generation complete!!'; newLine.
	^ Array
		with: (Array with: p with: q with: g with: x)
		with: (Array with: p with: q with: g with: y)
! !
!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'md 7/30/2005 14:12'!
signatureToString: aSignature
	"Answer a string representation of the given signature. This string can be parsed using the stringToSignature: method."

	| s |
	s := WriteStream on: (String new: 2000).
	s nextPutAll: '[DSA digital signature '.
	s nextPutAll: aSignature first printStringHex.
	s space.
	s nextPutAll: aSignature second printStringHex.
	s nextPutAll: ']'.
	^ s contents
! !
!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 13:33'!
stringToSignature: aString
	"Answer the signature stored in the given string. A signature string has the format:

		 '[DSA digital signature <r> <s>]'

	where <r> and <s> are large positive integers represented by strings of hexidecimal digits."

	| prefix stream r s |
	prefix := '[DSA digital signature '.
	(aString beginsWith: prefix) ifFalse: [self error: 'bad signature prefix'].
	stream := ReadStream on: aString.
	stream position: prefix size.
	r := Integer readFrom: stream base: 16.
	stream next.
	s := Integer readFrom: stream base: 16.
	^ Array with: r with: s
! !
!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48'!
verifySignature: aSignature ofMessageHash: hash publicKey: publicKey
	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."

	| p q g y r s w u1 u2 v0 v |
	p := publicKey first.
	q := publicKey second.
	g := publicKey third.
	y := publicKey fourth.
	r := aSignature first.
	s := aSignature last.
	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"
	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"

	w := s reciprocalModulo: q.
	u1 := (hash * w) \\ q.
	u2 := (r * w) \\ q.
	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).
	v := ( v0 \\ p) \\ q.
	^ v = r
! !
!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jmv 5/19/2015 21:41'!
generateQandP
	"Generate the two industrial-grade primes, q (160-bits) and p (512-bit) needed to build a key set. Answer the array (q, p, s), where s is the seed that from which q and p were created. This seed is normally discarded, but can be used to verify the key generation process if desired."

	| pBits halfTwoToTheP chunkCount sAndq q twoQ n c w x p s |
	pBits := 512.  "desired size of p in bits"
	halfTwoToTheP := 2 raisedTo: (pBits - 1).
	chunkCount := pBits // 160.

	Transcript show: 'Searching for primes q and p...'; newLine.
	[
		sAndq := self generateSandQ.
		Transcript show: '  Found a candidate q.';newLine.
		s := sAndq first.
		q := sAndq last.
		twoQ := q bitShift: 1.
		n := 2.
		c := 0.
		[c < 4096] whileTrue: [
			w := self generateRandomLength: pBits s: s n: n.
			x := w + halfTwoToTheP.
			p := (x - ( x \\ twoQ)) + 1.
			p highBit = pBits ifTrue: [
				Transcript show: '    Testing potential p ', (c + 1) printString, '...'; newLine.
				(self isProbablyPrime: p) ifTrue: [
					Transcript show: '  Found p!!'; newLine .
					^ Array with: q with: p with: s]].
			n := n + chunkCount + 1.
			c := c + 1]] repeat! !
!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 16:36'!
generateRandomLength: bitLength s: s n: n
	"Answer a random number of bitLength bits generated using the secure hash algorithm."

	| sha out count extraBits v |
	sha := SecureHashAlgorithm new.
	out := 0.
	count := (bitLength // 160).
	extraBits := bitLength - (count * 160).
	0 to: count do: [:k |
		v := sha hashInteger: (s + n + k).
		k = count ifTrue: [
			v := v - ((v >> extraBits) << extraBits)].
		out := out bitOr: (v bitShift: (160 * k))].
	^ out
! !
!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 4/11/2011 17:01'!
generateSandQ
	"Generate a 160-bit random seed s and an industrial grade prime q."

	| hasher s sPlusOne u q |
	hasher := SecureHashAlgorithm new.
	[
		s := self nextRandom160.
		sPlusOne := s + 1.
		sPlusOne highBit > 160 ifTrue: [sPlusOne := sPlusOne bitAnd: (1 bitShift: 160) - 1].
		u := (hasher hashInteger: s) bitXor: (hasher hashInteger: sPlusOne).
		q := u bitOr: ((1 bitShift: 159) bitOr: 1).
		(self isProbablyPrime: q) ifTrue: [^ Array with: s with: q]] repeat! !
!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 21:04'!
logOfLargestPowerOfTwoDividing: aPositiveInteger
	"Answer the base-2 log of the largest power of two that divides the given integer. For example, the largest power of two that divides 24 is 8, whose log base-2 is 3. Do this efficiently even when the given number is a large integer. Assume that the given integer is > 0."
	"DigitalSignatureAlgorithm new logOfLargestPowerOfTwoDividing: (32 * 3)"

	^aPositiveInteger lowBit - 1! !
!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 14:39'!
nextRandom160
	"Answer a newly generated 160-bit random number in the range [1..(2^160 - 1)]."
	"Details: Try again in the extremely unlikely chance that zero is encountered."

	| result |
	result := 0.
	[result = 0] whileTrue: [
		result := SecureHashAlgorithm new hashInteger: randKey seed: randSeed.
		randKey := randKey + result + 1].
	^ result
! !
!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jmv 5/19/2015 21:41'!
initRandom: randomInteger
	"Initialize the the secure random number generator with the given value. The argument should be a positive integer of up to 512 bits chosen randomly to avoid someone being able to predict the sequence of random values generated."
	"Note: The random generator must be initialized before generating a key set or signature. Signature verification does not require initialization of the random generator."

	randSeed := 16rEFCDAB8998BADCFE10325476C3D2E1F067452301.  "initial seed"
	randKey := randomInteger.
	Transcript show: 'Random seed: ', randomInteger printString; newLine.
! !
!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jmv 9/5/2016 21:13:01'!
initRandomFromString: aString
	"Ask the user to type a long random string and use the result to seed the secure random number generator."

	| s k srcIndex |
	s := aString.
	k := LargePositiveInteger new: (s size min: 64).
	srcIndex := 0.
	k digitLength to: 1 by: -1 do: [:i |
		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) numericValue].
	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"
	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].
	self initRandom: k.
! !
!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jmv 9/5/2016 21:13:06'!
initRandomFromUser
	"Ask the user to type a long random string and use the result to seed the secure random number generator."

	| s k srcIndex |
	s := FillInTheBlankMorph request: 'Enter a long random string to seed the random generator.'.
	k := LargePositiveInteger new: (s size min: 64).
	srcIndex := 0.
	k digitLength to: 1 by: -1 do: [:i |
		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) numericValue].
	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"
	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].
	self initRandom: k.
! !
!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'DSG 12/4/2013 17:41'!
initRandomNonInteractively
	[self initRandom: (SoundSystem default randomBitsFromSoundInput: 512)]
		ifError: [self initRandomFromString: 
			Time millisecondClockValue printString, 
			Date today printString, 
			Smalltalk platformName printString].! !
!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'nice 8/28/2010 21:16'!
inverseOf: x mod: n
	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x < n and that x and n are integers."
	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."

	| v u u1 u2 u3 t1 t2 t3 tmp |
	((x <= 0) or: [n <= 0]) ifTrue: [self error: 'x and n must be greater than zero'].
	x >= n ifTrue: [self error: 'x must be < n'].

	v := x.
	u := n.
	(x even and: [n even]) ifTrue: [self error: 'no inverse'].

	u1 := 1. u2 := 0. u3 := u.
	t1 := v. t2 := u - 1. t3 := v.
	[	[u3 even ifTrue: [
			((u1 odd) or: [u2 odd]) ifTrue: [
				u1 := u1 + v.
				u2 := u2 + u].
			u1 := u1 bitShift: -1.
			u2 := u2 bitShift: -1.
			u3 := u3 bitShift: -1].
		((t3 even) or: [u3 < t3]) ifTrue: [
			tmp := u1. u1 := t1. t1 := tmp.
			tmp := u2. u2 := t2. t2 := tmp.
			tmp := u3. u3 := t3. t3 := tmp].
		u3 even and: [u3 > 0]] whileTrue: ["loop while u3 is even"].

		[((u1 < t1) or: [u2 < t2]) and: [u1 > 0]] whileTrue: [
			u1 := u1 + v.
			u2 := u2 + u].
	
		u1 := u1 - t1.
		u2 := u2 - t2.
		u3 := u3 - t3.
		t3 > 0] whileTrue: ["loop while t3 > 0"].

	[u1 >= v and: [u2 >= u]] whileTrue: [
		u1 := u1 - v.
		u2 := u2 - u].

	u3 = 1 ifFalse: [self error: 'no inverse'].
	^ u - u2
! !
!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jmv 5/19/2015 21:46'!
isProbablyPrime: p
	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."

	| iterations factor pMinusOne b m r a j z couldBePrime |
	iterations := 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"

	"quick elimination: check for p divisible by a small prime"
	SmallPrimes ifNil: [  "generate list of small primes > 2"
		SmallPrimes := Integer primesUpTo: 2000.
		SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size].
	factor := SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].
	factor ifNotNil: [^ p = factor].

	pMinusOne := p - 1.
	b := self logOfLargestPowerOfTwoDividing: pMinusOne.
	m := pMinusOne bitShift: b negated.
	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"

	Transcript show: '      Prime test pass '.
	r := Random new.
	1 to: iterations do: [:i |
		Transcript show: i printString; space.
		a := (r next * 16rFFFFFF) truncated.
		j := 0.
		z := (a raisedTo: m modulo: p) normalize.
		couldBePrime := z = 1.
		[couldBePrime] whileFalse: [
			z = 1 ifTrue: [Transcript show: 'failed!!'; newLine. ^ false].  "not prime"
			z = pMinusOne
				ifTrue: [couldBePrime := true]
				ifFalse: [
					(j := j + 1) < b
						ifTrue: [z := (z * z) \\ p]
						ifFalse: [Transcript show: 'failed!!'; newLine. ^ false]]]].  "not prime"

	Transcript show: 'passed!!'; newLine.
	^ true  "passed all tests; probably prime"
! !
!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jm 12/22/1999 11:23'!
example
	"Example of signing a message and verifying its signature."
	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."
	"DigitalSignatureAlgorithm example"

	| msg keys sig |
	msg := 'This is a test...'.
	keys := self testKeySet.
	sig := self sign: msg privateKey: keys first.
	self inform: 'Signature created'.
	(self verify: sig isSignatureOf: msg publicKey: keys last)
		ifTrue: [self inform: 'Signature verified.']
		ifFalse: [self error: 'ERROR!! Signature verification failed'].
! !
!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'pb 5/25/2016 01:32'!
testExamplesFromDisk
	"verify messages from file on disk"
	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."
	"DigitalSignatureAlgorithm testExamplesFromDisk"

	'dsa.test.out' asFileEntry readStreamDo: [ :stream |
		| msg  sig publicKey |
		[stream atEnd] whileFalse: [
			sig := stream nextChunk.
			msg := stream nextChunk.
			publicKey := Compiler evaluate: stream nextChunk.
			(self verify: sig isSignatureOf: msg publicKey: publicKey) ifTrue: [
				Transcript show: 'SUCCESS: ',msg; newLine.
			] ifFalse: [
				self error: 'ERROR!! Signature verification failed'
			].
		].
	]! !
!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jm 12/22/1999 11:28'!
testKeySet
	"Answer a pair of keys for testing. The first key is the private key, the second one is the public key."
	"WARNING: This test key set is public should be used only for testing!! In a real application, the user would create a set of keys using generateKeySet and would keep the private key secret."

	^ #(
		(8343811888543852523216773185009428259187948644369498021763210776677854991854533186365944349987509452133156416880596803846631577352387751880552969116768071 1197175832754339660404549606408619548226315875117 1433467472198821951822151391684734233265646022897503720591270330985699984763922266163182803556189497900262038518780931942996381297743579119123094520048965 957348690772296812)
		(8343811888543852523216773185009428259187948644369498021763210776677854991854533186365944349987509452133156416880596803846631577352387751880552969116768071 1197175832754339660404549606408619548226315875117 1433467472198821951822151391684734233265646022897503720591270330985699984763922266163182803556189497900262038518780931942996381297743579119123094520048965 4645213122572190617807944614677917601101008235397095646475699959851618402406173485853587185431290863173614335452934961425661774118334228449202337038283799))
! !
!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jmv 9/5/2016 20:48:35'!
timeDecode: count
	"Example of signing a message and verifying its signature."
	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."
	"DigitalSignatureAlgorithm timeDecode: 20"

	| dsa |
	dsa := DigitalSignatureAlgorithm new.
	dsa initRandomFromUser.

	#(1 10 100 1000 10000 100000) do: [ :extraLen |
		| msg keys sig s |
		s := String new: extraLen.
		1 to: s size do: [ :i | s at: i put: (Character numericValue: 200 atRandom)].
		msg := 'This is a test...',s.
		keys := self testKeySet.
		sig := self sign: msg privateKey: keys first dsa: dsa.
		"self inform: 'Signature created'."
		self timeDirect: [
			count timesRepeat: [
				(self verify: sig isSignatureOf: msg publicKey: keys last)
					ifFalse: [self error: 'ERROR!! Signature verification failed'].
			].
		] as: 'verify msgLen = ',msg size printString count: count
	].
! !
!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'pb 5/25/2016 01:36'!
writeExamplesToDisk
	"Example of signing a message and verifying its signature. Used to create samples from one implementation that could later be tested with a different implementation"
	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."
	"DigitalSignatureAlgorithm writeExamplesToDisk"

	| keyList dsa msgList |
	dsa := DigitalSignatureAlgorithm new.
	dsa initRandomFromUser.
	self inform: 'About to generate 5 key sets. Will take a while'.
	keyList := {self testKeySet},((1 to: 5) collect: [ :ignore | self generateKeySet]).
	msgList := {'This is a test...'. 'This is the second test period.'. 'And finally, a third message'}.
	'dsa.test.out' asFileEntry writeStreamDo: [ :stream |
		msgList do: [ :msg |
			keyList do: [ :keys |
				| sig |
				sig := self sign: msg privateKey: keys first dsa: dsa.
				(self verify: sig isSignatureOf: msg publicKey: keys last) ifTrue: [
					stream
						nextChunkPut: sig;
						nextChunkPut: msg;
						nextChunkPut: keys last storeString.
				] ifFalse: [
					self error: 'ERROR!! Signature verification failed'
				].
			].
		].
	]! !
!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'ads 7/31/2003 14:01'!
generateKeySet
	"Generate and answer a key set for code signing. The result is a pair (<private key><public key>). Each key is an array of four large integers. The signer must be sure to record this keys set and must keep the private key secret to prevent someone from forging their signature."
	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"
	"Note: Unguessable random numbers are needed for key generation. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before generating a key set. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."
	"DigitalSignatureAlgorithm generateKeySet"

	| dsa |
	dsa := DigitalSignatureAlgorithm new.
	(self confirm: 'Shall I seed the random generator from the current sound input?')
		ifTrue: [dsa initRandomNonInteractively]
		ifFalse: [dsa initRandomFromUser].
	^ dsa generateKeySet
! !
!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:18'!
sign: aStringOrStream privateKey: privateKey
	"Sign the given message (a stream or string) and answer a signature string."
	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."

	| dsa hasher h sig |
	dsa := DigitalSignatureAlgorithm new.
	dsa initRandomFromUser.
	hasher := SecureHashAlgorithm new.
	(aStringOrStream class isBytes)
		ifTrue: [h := hasher hashMessage: aStringOrStream]
		ifFalse: [h := hasher hashStream: aStringOrStream].
	sig := dsa computeSignatureForMessageHash: h privateKey: privateKey.
	^ dsa signatureToString: sig
! !
!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'RAA 5/31/2000 08:46'!
sign: aStringOrStream privateKey: privateKey dsa: dsa
	"Sign the given message (a stream or string) and answer a signature string."
	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."

	| hasher h sig |

	hasher := SecureHashAlgorithm new.
	(aStringOrStream class isBytes)
		ifTrue: [h := hasher hashMessage: aStringOrStream]
		ifFalse: [h := hasher hashStream: aStringOrStream].
	sig := dsa computeSignatureForMessageHash: h privateKey: privateKey.
	^ dsa signatureToString: sig
! !
!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:20'!
verify: signatureString isSignatureOf: aStringOrStream publicKey: publicKey
	"Answer true if the given signature string signs the given message (a stream or string)."
	"Note: Random numbers are not needed for signature verification; thus, there is no need to call initRandomFromUser before verifying a signature."

	| dsa hasher h sig |
	dsa := DigitalSignatureAlgorithm new.
	hasher := SecureHashAlgorithm new.
	(aStringOrStream class isBytes)
		ifTrue: [h := hasher hashMessage: aStringOrStream]
		ifFalse: [h := hasher hashStream: aStringOrStream].
	sig := dsa stringToSignature: signatureString.
	^ dsa verifySignature: sig ofMessageHash: h publicKey: publicKey
! !
!DigitalSignatureAlgorithm class methodsFor: 'class initialization' stamp: 'jm 12/21/1999 19:15' overrides: 16904184!
initialize
	"DigitalSignatureAlgorithm initialize"

	"SmallPrimes is a list of small primes greater than two."
	SmallPrimes := Integer primesUpTo: 2000.
	SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size.

	"HighBitOfByte maps a byte to the index of its top non-zero bit."
	HighBitOfByte := (0 to: 255) collect: [:byte | byte highBit].
! !
!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'RAA 5/31/2000 08:21'!
time: aBlock as: aString count: anInteger

	^{anInteger. aString. (Time millisecondsToRun: aBlock)}! !
!DigitalSignatureAlgorithm class methodsFor: 'testing' stamp: 'jmv 5/19/2015 21:48'!
timeDirect: aBlock as: aString count: anInteger

	Transcript show: anInteger printStringWithCommas,'  ',
		aString ,' took ',
		(Time millisecondsToRun: aBlock) printStringWithCommas,' ms'; newLine
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/7/1999 23:25'!
constantForStep: i
	"Answer the constant for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."

	i <= 20 ifTrue: [^ K1].
	i <= 40 ifTrue: [^ K2].
	i <= 60 ifTrue: [^ K3].
	^ K4
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:43'!
expandedBlock: aByteArray
	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 
	| out src v |
	out := Array new: 80.
	src := 1.
	1 to: 16 do: [:i |
		out at: i put: (ThirtyTwoBitRegister fromByteArray: aByteArray at: src).
		src := src + 4].

	17 to: 80 do: [:i |
		v := (out at: i - 3) copy.
		v	bitXor: (out at: i - 8);
			bitXor: (out at: i - 14);
			bitXor: (out at: i - 16);
			leftRotateBy: 1.
		out at: i put: v].
	^ out
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 20:02'!
finalHash
	"Concatenate the final totals to build the 160-bit integer result."
	"Details: If the primitives are supported, the results are in the totals array. Otherwise, they are in the instance variables totalA through totalE."

	| r |
	totals ifNil: [  "compute final hash when not using primitives"
		^ (totalA asInteger bitShift: 128) +
		  (totalB asInteger bitShift:  96) +
		  (totalC asInteger bitShift:  64) +
		  (totalD asInteger bitShift:  32) +
		  (totalE asInteger)].

	"compute final hash when using primitives"
	r := 0.
	1 to: 5 do: [:i |
		r := r bitOr: ((totals at: i) bitShift: (32 * (5 - i)))].
	^ r
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/7/1999 22:15'!
hashFunction: i of: x with: y with: z
	"Compute the hash function for the i-th step of the block hash loop. We number our steps 1-80, versus the 0-79 of the standard."
	"Details: There are four functions, one for each 20 iterations. The second and fourth are the same."

	i <= 20 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitInvert; bitAnd: z)].
	i <= 40 ifTrue: [^ x copy bitXor: y; bitXor: z].
	i <= 60 ifTrue: [^ x copy bitAnd: y; bitOr: (x copy bitAnd: z); bitOr: (y copy bitAnd: z)].
	^ x copy bitXor: y; bitXor: z
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:39'!
initializeTotals
	"Initialize totalA through totalE to their seed values."

	"total registers for use when primitives are absent"
	totalA := ThirtyTwoBitRegister fromInteger: 16r67452301.
	totalB := ThirtyTwoBitRegister fromInteger: 16rEFCDAB89.
	totalC := ThirtyTwoBitRegister fromInteger: 16r98BADCFE.
	totalD := ThirtyTwoBitRegister fromInteger: 16r10325476.
	totalE := ThirtyTwoBitRegister fromInteger: 16rC3D2E1F0.
	self initializeTotalsArray.
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:38'!
initializeTotalsArray
	"Initialize the totals array from the registers for use with the primitives."

	totals := Bitmap new: 5.
	totals at: 1 put: totalA asInteger.
	totals at: 2 put: totalB asInteger.
	totals at: 3 put: totalC asInteger.
	totals at: 4 put: totalD asInteger.
	totals at: 5 put: totalE asInteger.
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:28'!
processBuffer: aByteArray
	"Process given 64-byte buffer, accumulating the results in totalA through totalE."

	| a b c d e w tmp |
	self primHasSecureHashPrimitive
		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]
		ifFalse: [totals := nil].

	"initialize registers a through e from the current totals" 
	a := totalA copy.
	b := totalB copy.
	c := totalC copy.
	d := totalD copy.
	e := totalE copy.

	"expand and process the buffer"
	w := self expandedBlock: aByteArray.
	1 to: 80 do: [:i |
		tmp := (a copy leftRotateBy: 5)
			+= (self hashFunction: i of: b with: c with: d);
			+= e;
			+= (w at: i);
			+= (self constantForStep: i).
		e := d.
		d := c.
		c := b leftRotateBy: 30.
		b := a.
		a := tmp].

	"add a through e into total accumulators"
	totalA += a.
	totalB += b.
	totalC += c.
	totalD += d.
	totalE += e.
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 23:32'!
processBufferUsingPrimitives: aByteArray
	"Process given 64-byte buffer using the primitives, accumulating the results in totals."

	| w |
	"expand and process the buffer"
	w := Bitmap new: 80.
	self primExpandBlock: aByteArray into: w.
	self primHashBlock: w using: totals.
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:40'!
processFinalBuffer: buffer bitLength: bitLength
	"Process given buffer, whose length may be <= 64 bytes, accumulating the results in totalA through totalE. Also process the final padding bits and length."

	| out |
	out := ByteArray new: 64.
	out replaceFrom: 1 to: buffer size with: buffer startingAt: 1.
	buffer size < 56 ifTrue: [  "padding and length fit in last data block"
		out at: buffer size + 1 put: 128.  "trailing one bit"
		self storeLength: bitLength in: out.  "end with length"
		self processBuffer: out.
		^ self].

	"process the final data block"
	buffer size < 64 ifTrue: [
		out at: buffer size + 1 put: 128].  "trailing one bit"
	self processBuffer: out.

	"process one additional block of padding ending with the length"
	out := ByteArray new: 64.  "filled with zeros"
	buffer size = 64 ifTrue: [
		"add trailing one bit that didn't fit in final data block"
		out at: 1 put: 128].
	self storeLength: bitLength in: out.
	self processBuffer: out.
! !
!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:10'!
storeLength: bitLength in: aByteArray
	"Fill in the final 8 bytes of the given ByteArray with a 64-bit big-endian representation of the original message length in bits."

	| n i |
	n := bitLength.
	i := aByteArray size.
	[n > 0] whileTrue: [
		aByteArray at: i put: (n bitAnd: 16rFF).
		n := n bitShift: -8.
		i := i - 1].
! !
!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:56'!
hashInteger: aPositiveInteger
	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in key generation."

	| buffer dstIndex |
	self initializeTotals.

	"pad integer with zeros"
	aPositiveInteger highBit <= 512
		ifFalse: [self error: 'integer cannot exceed 512 bits'].
	buffer := ByteArray new: 64.
	dstIndex := 0.
	aPositiveInteger digitLength to: 1 by: -1 do: [:i |
		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].

	"process that one block"
	self processBuffer: buffer.

	^ self finalHash
! !
!SecureHashAlgorithm methodsFor: 'public' stamp: 'nice 8/28/2010 22:40'!
hashInteger: aPositiveInteger seed: seedInteger
	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"

	| buffer dstIndex |
	"Initialize totalA through totalE to their seed values."
	totalA := ThirtyTwoBitRegister
		fromInteger: ((seedInteger bitShift: -128) bitAnd: 16rFFFFFFFF).
	totalB := ThirtyTwoBitRegister
		fromInteger: ((seedInteger bitShift: -96) bitAnd: 16rFFFFFFFF).
	totalC := ThirtyTwoBitRegister
		fromInteger: ((seedInteger bitShift: -64) bitAnd: 16rFFFFFFFF).
	totalD := ThirtyTwoBitRegister
		fromInteger: ((seedInteger bitShift: -32) bitAnd: 16rFFFFFFFF).
	totalE := ThirtyTwoBitRegister
		fromInteger: (seedInteger bitAnd: 16rFFFFFFFF).
	self initializeTotalsArray.

	"pad integer with zeros"
	buffer := ByteArray new: 64.
	dstIndex := 0.
	aPositiveInteger digitLength to: 1 by: -1 do: [:i |
		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].

	"process that one block"
	self processBuffer: buffer.

	^ self finalHash
! !
!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:28'!
hashMessage: aStringOrByteArray
	"Hash the given message using the Secure Hash Algorithm."

	^ self hashStream: (ReadStream on: aStringOrByteArray asByteArray)
! !
!SecureHashAlgorithm methodsFor: 'public' stamp: 'ar 2/25/2010 23:40'!
hashStream: aPositionableStream
	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."
	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"

	| startPosition buf bitLength |
	self initializeTotals.

	"(SecureHashAlgorithm new hashMessage: '') radix: 16 	
	=> 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709'"
	aPositionableStream atEnd ifTrue: [self processFinalBuffer: #() bitLength: 0].

	startPosition := aPositionableStream position.
	[aPositionableStream atEnd] whileFalse: [
		buf := aPositionableStream next: 64.
		(aPositionableStream atEnd not and: [buf size = 64])
			ifTrue: [self processBuffer: buf]
			ifFalse: [
				bitLength := (aPositionableStream position - startPosition) * 8.
				self processFinalBuffer: buf bitLength: bitLength]].

	^ self finalHash
! !
!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 20:11'!
primExpandBlock: aByteArray into: wordBitmap
	"Expand the given 64-byte buffer into the given Bitmap of length 80."

	<primitive: 'primitiveExpandBlock' module: 'DSAPrims'>
	^ self primitiveFailed
! !
!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 22:58'!
primHasSecureHashPrimitive
	"Answer true if this platform has primitive support for the Secure Hash Algorithm."

	<primitive: 'primitiveHasSecureHashPrimitive' module: 'DSAPrims'>
	^ false
! !
!SecureHashAlgorithm methodsFor: 'primitives' stamp: 'jm 12/21/1999 20:13'!
primHashBlock: blockBitmap using: workingTotalsBitmap
	"Hash the given block (a Bitmap) of 80 32-bit words, using the given workingTotals."

	<primitive: 'primitiveHashBlock' module: 'DSAPrims'>
	^ self primitiveFailed
! !
!SecureHashAlgorithm class methodsFor: 'class initialization' stamp: 'nice 8/28/2010 22:39' overrides: 16904184!
initialize
	"SecureHashAlgorithm initialize"
	"For the curious, here's where these constants come from:
	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"

	K1 := ThirtyTwoBitRegister fromInteger: 16r5A827999.
	K2 := ThirtyTwoBitRegister fromInteger: 16r6ED9EBA1.
	K3 := ThirtyTwoBitRegister fromInteger: 16r8F1BBCDC.
	K4 := ThirtyTwoBitRegister fromInteger: 16rCA62C1D6.
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 23:05:57'!
expandedBlock: aByteArray
	"Convert the given 64 byte buffer into 64 32-bit registers and answer the result." 
	| out src |
	out _ Array new: 64.
	src _ 1.
	
	1 to: 16 do: [:i |
		out at: i put: (ThirtyTwoBitRegister fromByteArray: aByteArray at: src).
		src _ src + 4].

	17 to: 64 do: [:t |
		| v1 v2 v3 v4 result |
		"SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)"
		"SSIG1(x) = ROTR^17(x) XOR ROTR^19(x) XOR SHR^10(x)"
		"Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16)"
		v1 _ (out at: t - 2) copy.
		v2 _ (out at: t - 7) copy.
		v3 _ (out at: t - 15) copy.
		v4 _ (out at: t - 16) copy.
		
		result _ self smallSigmaOne: v1.
		result += v2.
		result += (self smallSigmaZero: v3).
		result += v4.
		
		out at: t put: result ].
	
	^ out
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 14:18:46'!
finalHash
	"Concatenate the final totals to build the 256-bit integer result."

	^ (totalA asInteger bitShift: 224) +
	   (totalB asInteger bitShift: 192) +
	   (totalC asInteger bitShift: 160) +
	   (totalD asInteger bitShift: 128) +
	   (totalE asInteger bitShift:  96) +
	   (totalF asInteger bitShift: 64) +
	   (totalG asInteger bitShift: 32) +
	   (totalH asInteger)! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 13:59:19'!
findConstantBy: aSmallInteger 
	^(RoundConstants at: aSmallInteger) copy! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 23:32:38'!
hash1With: register1 with: register2 with: register3 
	 "BSIG1(e) + CH(e,f,g) "
	| result chResult |
	result _ register1 copy.
	
	"BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x)"
	result rightRotateBy: 6.
	result bitXor: (register1 copy rightRotateBy: 11).
	result bitXor: (register1 copy rightRotateBy: 25).
	
	"CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z)"
	chResult _ register1 copy.
	chResult bitAnd: register2.
	chResult bitXor: (register1 copy bitInvert bitAnd: register3).
	
	result += chResult.
	
	^result.! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 23:37:28'!
hash2With: register1 with: register2 with: register3
	| result majResult |

	"BSIG0(a) + MAJ(a,b,c)" 
	result _ register1 copy.

	"BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x)"
	result rightRotateBy: 2.
	result bitXor: (register1 copy rightRotateBy: 13).
	result bitXor: (register1 copy rightRotateBy: 22).
	
	"MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z)"
	majResult _ register1 copy.
	majResult bitAnd: register2.
	majResult bitXor: (register1 copy bitAnd: register3).
	majResult bitXor: (register2 copy bitAnd: register3).
	
	result += majResult.
	
	^result! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 4/25/2020 19:19:04'!
hashMessage: aStringOrByteArray
	"Hash the given message using the Secure Hash Algorithm 256."

	^ self hashStream: (ReadStream on: aStringOrByteArray asByteArray)
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 4/30/2020 18:12:30'!
hashStream: aPositionableStream
	| startPosition buf bitLength |
	self initializeTotals.

	aPositionableStream atEnd ifTrue: [self processFinalBuffer: #() bitLength: 0].

	startPosition _ aPositionableStream position.
	[aPositionableStream atEnd] whileFalse: [
		buf _ aPositionableStream next: 64.
		(aPositionableStream atEnd not and: [buf size = 64])
			ifTrue: [self processBuffer: buf]
			ifFalse: [
				bitLength _ (aPositionableStream position - startPosition) * 8.
				self processFinalBuffer: buf bitLength: bitLength]].

	^ self finalHash
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/3/2020 23:01:19'!
initializeTotals
	| initialValues |
	initialValues _ self class makeHashValuesArray.
	
	totalA _ initialValues at: 1.
	totalB _ initialValues at: 2.
	totalC _ initialValues at: 3.
	totalD _ initialValues at: 4.
	totalE _ initialValues at: 5.
	totalF _ initialValues at: 6.
	totalG _ initialValues at: 7.
	totalH _ initialValues at: 8.
	! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/3/2020 23:01:56'!
processBuffer: aByteArray
	"Process given 64-byte buffer, accumulating the results in totalA through totalE."
	| a b c d e f g h w tmp1 tmp2 |

	"initialize registers a through e from the current totals" 
	a _ totalA copy.
	b _ totalB copy.
	c _ totalC copy.
	d _ totalD copy.
	e _ totalE copy.
	f _ totalF copy. 
	g _ totalG copy.
	h _ totalH copy.

	"expand and process the buffer"
	w _ self expandedBlock: aByteArray.
	1 to: 64 do: [:i |
		tmp1 _ h copy.
		tmp1 += (self hash1With: e with: f with: g). "T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt"
		tmp1 += (self findConstantBy: i).
		tmp1 += (w at: i).
		
		tmp2 _ self hash2With: a with: b with: c. "T2 = BSIG0(a) + MAJ(a,b,c)"
			
		h _ g.
		g _ f.
           f _ e.
           e _ d copy += tmp1.
           d _ c.
           c _ b.
           b _ a.
		a _ tmp1 copy += tmp2.
	 ].

	"add a through e into total accumulators"
	totalA  += a.
	totalB += b.
	totalC += c.
	totalD += d.
	totalE += e.
	totalF += f.
	totalG += g.
	totalH += h.
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 14:39:11'!
processFinalBuffer: buffer bitLength: bitLength 
	"Process given buffer, whose length may be <= 64 bytes, accumulating the results in totalA through totalE. Also process the final padding bits and length."

	| out |
	out _ ByteArray new: 64.
	out replaceFrom: 1 to: buffer size with: buffer startingAt: 1.

	buffer size < 56 ifTrue: [  "padding and length fit in last data block"
		out at: buffer size + 1 put: 128.  "trailing one bit"
		self storeLength: bitLength in: out.  "end with length"
		self processBuffer: out.
		^ self].

	"process the final data block"
	buffer size < 64 ifTrue: [
		out at: buffer size + 1 put: 128].  "trailing one bit"

	self processBuffer: out.

	"process one additional block of padding ending with the length"
	out _ ByteArray new: 64.  "filled with zeros"
	buffer size = 64 ifTrue: [
		"add trailing one bit that didn't fit in final data block"
		out at: 1 put: 128].
	
	self storeLength: bitLength in: out.
	self processBuffer: out.
! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 11:09:27'!
smallSigmaOne: register
	"SSIG1(x) = ROTR^17(x) XOR ROTR^19(x) XOR SHR^10(x)"
	| result v1 v2 |
	result _ register copy.
	v1 _ register copy.
	v2 _ register copy.
	
	result rightRotateBy: 17.
	v1 rightRotateBy: 19.
	v2 >> 10.
	
	result bitXor: v1.
	result bitXor: v2.

	^result
	! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 5/2/2020 11:07:55'!
smallSigmaZero: register
	"SSIG0(x) = ROTR^7(x) XOR ROTR^18(x) XOR SHR^3(x)"
	| result v1 v2 |
	result _ register copy.
	v1 _ register copy.
	v2 _ register copy.
	
	result rightRotateBy: 7.
	v1 rightRotateBy: 18.
	v2 >> 3.
	
	result bitXor: v1.
	result bitXor: v2.
	
	^result! !
!SecureHashAlgorithm256 methodsFor: 'as yet unclassified' stamp: 'jpb 4/27/2020 17:07:04'!
storeLength: bitLength in: aByteArray
	"Fill in the final 8 bytes of the given ByteArray with a 64-bit big-endian representation of the original message length in bits."

	| n i |
	n _ bitLength.
	i _ aByteArray size.
	
	[n > 0] whileTrue: [
		aByteArray at: i put: (n bitAnd: 16rFF).
		n _ n bitShift: -8.
		i _ i - 1].
! !
!SecureHashAlgorithm256 class methodsFor: 'as yet unclassified' stamp: 'jpb 4/25/2020 18:41:51' overrides: 16904184!
initialize
	HashValues _ self makeHashValuesArray.
	RoundConstants _ self makeRoundConstantsArray.! !
!SecureHashAlgorithm256 class methodsFor: 'as yet unclassified' stamp: 'jpb 4/25/2020 18:46:21'!
makeHashValuesArray
	| constants |
	constants _ #(
		16r6A09E667 16rBB67AE85 16r3C6EF372 16rA54FF53A
		16r510E527F 16r9B05688C 16r1F83D9AB 16r5BE0CD19
	).
	^constants collect: [:const| ThirtyTwoBitRegister fromInteger: const ]! !
!SecureHashAlgorithm256 class methodsFor: 'as yet unclassified' stamp: 'jpb 5/3/2020 22:18:14'!
makeRoundConstantsArray
	| constants |
	constants _ #(
		16r428A2F98 16r71374491 16rB5C0FBCF 16rE9B5DBA5 16r3956C25B
 		16r59F111F1 16r923F82A4 16rAB1C5ED5  16rD807AA98 16r12835B01
		16r243185BE 16r550C7DC3 16r72BE5D74 16r80DEB1FE 16r9BDC06A7
		16rC19BF174 16rE49B69C1 16rEFBE4786 16r0FC19DC6 16r240CA1CC
		16r2DE92C6F 16r4A7484AA 16r5CB0A9DC 16r76F988DA 16r983E5152
		16rA831C66D 16rB00327C8 16rBF597FC7 16rC6E00BF3 16rD5A79147
		16r06CA6351 16r14292967  16r27B70A85 16r2E1B2138 16r4D2C6DFC
		16r53380D13 16r650A7354 16r766A0ABB 16r81C2C92E 16r92722C85
		16rA2BFE8A1 16rA81A664B 16rC24B8B70 16rC76C51A3 16rD192E819
		16rD6990624 16rF40E3585 16r106AA070 16r19A4C116 16r1E376C08
		16r2748774C 16r34B0BCB5 16r391C0CB3 16r4ED8AA4A 16r5B9CCA4F
		16r682E6FF3  16r748F82EE 16r78A5636F 16r84C87814 16r8CC70208
		16r90BEFFFA 16rA4506CEB 16rBEF9A3F7 16rC67178F2
	).
	^constants collect: [:const | ThirtyTwoBitRegister fromInteger: const ].! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'ul 4/11/2015 02:24'!
*= aThirtTwoBitRegister
	"Replace my contents with the product of the given register and my current contents."

	| otherLow otherHi mul newLow newHi |
	otherLow := aThirtTwoBitRegister low.
	otherHi := aThirtTwoBitRegister hi.
	"Multiply low with otherLow. Process the two highest bits of low separately if necessary to avoid LargeInteger operations."
	(low bitShift: -8) * (otherLow bitShift: -8) > 16r3FFF
		ifTrue: [ 
			mul := (low bitAnd: 16r3FFF) * otherLow. "Without the two most significant bits of low."
			newLow := (mul bitAnd: 16rFFFF).
			newHi := (mul bitShift: -16).
			mul := (low bitShift: -14) * otherLow. "The two most significant bits of low"
			newLow := newLow + ((mul bitAnd: 16r3) bitShift: 14).
			newHi := newHi + (mul bitShift: -2) + (newLow bitShift: -16) "Carry from newLow" ]
		ifFalse: [
			newLow := low * otherLow. "We'll trim newLow at the end of the method."
			newHi := newLow bitShift: -16 ].
	"Multiply hi with otherLow."
	(hi bitShift: -8) * (otherLow bitShift: -8) > 16r3FFF
		ifTrue: [
			newHi := newHi + 
				((hi bitAnd: 16r3FFF) * otherLow bitAnd: 16rFFFF) +
				(((hi bitShift: -14) * otherLow bitAnd: 16r3) bitShift: 14) ]
		ifFalse: [ newHi := newHi + (hi * otherLow bitAnd: 16rFFFF) ].
	"Multiply low with otherHi."
	(low bitShift: -8) * (otherHi bitShift: -8) > 16r3FFF
		ifTrue: [
			newHi := newHi + 
				((low bitAnd: 16r3FFF) * otherHi bitAnd: 16rFFFF) +
				(((low bitShift: -14) * otherHi bitAnd: 16r3) bitShift: 14) ]
		ifFalse: [ newHi := newHi + (low * otherHi bitAnd: 16rFFFF) ].
	"Truncate and store the results."
	hi := newHi bitAnd: 16rFFFF.
	low := newLow bitAnd: 16rFFFF 
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:36'!
+= aThirtTwoBitRegister
	"Replace my contents with the sum of the given register and my current contents."

	| lowSum |
	lowSum := low + aThirtTwoBitRegister low.
	hi := (hi + aThirtTwoBitRegister hi + (lowSum bitShift: -16)) bitAnd: 16rFFFF.
	low := lowSum bitAnd: 16rFFFF.
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'ul 4/11/2015 04:39'!
<< anInteger
	"Unsigned left shift."

	| bitCount |
	bitCount := anInteger.
	bitCount >= 32 ifTrue: [
		hi := low := 0.
		^self ].
	bitCount >= 16 ifTrue: [
		hi := low.
		low := 0.
		bitCount := bitCount - 16 ].
	bitCount >= 15 ifTrue: [
		hi := ((hi bitAnd: 1) bitShift: 15) bitOr: (low bitShift: -1).
		low := (low bitAnd: 1) bitShift: 15.
		^self ].
	bitCount >= 1 ifTrue: [
		hi := ((hi bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (low bitShift: bitCount - 16).
		low := (low bitShift: bitCount) bitAnd: 16rFFFF ]! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:41'!
bitAnd: aThirtTwoBitRegister
	"Replace my contents with the bitwise AND of the given register and my current contents."

	hi := hi bitAnd: aThirtTwoBitRegister hi.
	low := low bitAnd: aThirtTwoBitRegister low.
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!
bitInvert
	"Replace my contents with the bitwise inverse my current contents."

	hi := hi bitXor: 16rFFFF.
	low := low bitXor: 16rFFFF.
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!
bitOr: aThirtTwoBitRegister
	"Replace my contents with the bitwise OR of the given register and my current contents."

	hi := hi bitOr: aThirtTwoBitRegister hi.
	low := low bitOr: aThirtTwoBitRegister low.
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:38'!
bitXor: aThirtTwoBitRegister
	"Replace my contents with the bitwise exclusive OR of the given register and my current contents."

	hi := hi bitXor: aThirtTwoBitRegister hi.
	low := low bitXor: aThirtTwoBitRegister low.
! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'ul 3/6/2015 02:50'!
leftRotateBy: bits
	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."
	"Details: Perform this operation with no LargeInteger arithmetic."

	| bitCount newHi |
	bitCount := bits.
	bitCount >= 32 ifTrue: [ bitCount := bitCount \\ 32 ].
	bitCount >= 16 ifTrue: [
		newHi := low.
		low := hi.
		hi := newHi.
		bitCount := bitCount - 16 ].
	bitCount >= 15 ifTrue: [
		newHi := ((hi bitAnd: 16r1) bitShift: 15) bitOr: (low bitShift: -1).
		low := ((low bitAnd: 16r1) bitShift: 15) bitOr: (hi bitShift: -1).
		hi := newHi.
		^self ].
	bitCount >= 1 ifTrue: [
		| shift |
		shift := bitCount - 16.
		newHi := ((hi bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (low bitShift: shift).
		low := ((low bitShift: bitCount) bitAnd: 16rFFFF) bitOr: (hi bitShift: shift).
		hi := newHi ]! !
!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jpb 5/1/2020 19:23:07'!
rightRotateBy: bits
	"Rotate my contents right by the given number of bits, retaining exactly 32 bits."
	"Details: Perform this operation with no LargeInteger arithmetic."
	| bitCount newLow |
	
	bitCount _ bits.
	bitCount >= 32 ifTrue: [ bitCount _ bitCount \\ 32 ].
	bitCount >= 16 ifTrue: [
		newLow _ hi.
		hi _ low.
		low _ newLow.
		bitCount _ bitCount - 16 ].

	bitCount >= 15 ifTrue: [
		newLow _ ((low bitAnd: 16r8000) bitShift: -15) bitOr: (hi << 1 bitAnd: 16rFFFF).
		hi _ ((hi bitAnd: 16r8000) bitShift: -15) bitOr: (low << 1 bitAnd: 16rFFFF).
		low _ newLow.
		^self ].
	
	bitCount >= 1 ifTrue: [
		| shift |
		shift _ 16 - bitCount .
		newLow _ ((hi bitShift: shift) bitAnd: 16rFFFF) bitOr: low >> bitCount.
		hi _ ((low bitShift: shift) bitAnd: 16rFFFF) bitOr: hi >> bitCount.
		low _ newLow ]! !
!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/7/1999 15:26'!
hi

	^ hi
! !
!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'nice 8/28/2010 22:34'!
load: anInteger
	"Set my contents to the value of given integer."

	(anInteger positive and: [anInteger digitLength <= 4])
		ifFalse: [self error: 'out of range: ', anInteger printString].
	low := anInteger bitAnd: 16rFFFF.
	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF
! !
!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'ul 4/11/2015 04:01'!
loadFrom: aThirtyTwoBitRegister
	"Set my contents from the given ThirtyTwoBitRegister."

	hi := aThirtyTwoBitRegister hi.
	low := aThirtyTwoBitRegister low
! !
!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:07'!
loadFrom: aByteArray at: index
	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."

	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).
	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).
! !
!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/7/1999 15:26'!
low

	^ low! !
!ThirtyTwoBitRegister methodsFor: 'copying' stamp: 'jm 12/7/1999 15:26' overrides: 16901906!
copy
	"Use the clone primitive for speed."

	<primitive: 148>
	^ super copy
! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/11/2015 04:50'!
< aThirtyTwoBitRegister

	^hi < aThirtyTwoBitRegister hi or: [
		hi = aThirtyTwoBitRegister hi and: [
			low < aThirtyTwoBitRegister low ] ]! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/11/2015 04:51'!
<= aThirtyTwoBitRegister

	^hi < aThirtyTwoBitRegister hi or: [
		hi = aThirtyTwoBitRegister hi and: [
			low <= aThirtyTwoBitRegister low ] ]! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/6/2015 02:30' overrides: 16901772!
= anObject

	^self class == anObject class
		and: [ anObject low = low
		and: [ anObject hi = hi ] ]! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/11/2015 04:51'!
> aThirtyTwoBitRegister

	^hi > aThirtyTwoBitRegister hi or: [
		hi = aThirtyTwoBitRegister hi and: [
			low > aThirtyTwoBitRegister low ] ]! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/11/2015 04:51'!
>= aThirtyTwoBitRegister

	^hi > aThirtyTwoBitRegister hi or: [
		hi = aThirtyTwoBitRegister hi and: [
			low >= aThirtyTwoBitRegister low ] ]! !
!ThirtyTwoBitRegister methodsFor: 'comparing' stamp: 'ul 4/6/2015 03:06' overrides: 16901788!
hash

	^((hi bitShift: 14) bitXor: low) hashMultiply! !
!ThirtyTwoBitRegister methodsFor: 'converting' stamp: 'jm 12/14/1999 16:03'!
asInteger
	"Answer the integer value of my current contents."

	^ (hi bitShift: 16) + low
! !
!ThirtyTwoBitRegister methodsFor: 'converting' stamp: 'ul 4/10/2015 20:52'!
asSignedInteger
	"Answer the signed integer value of my current contents."

	hi >= 16r8000 ifFalse: [ ^(hi bitShift: 16) + low ].
	^-1 - (low bitXor: 16rFFFF) - ((hi bitXor: 16rFFFF) bitShift: 16)


! !
!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:42'!
fromByteArray: aByteArray at: startIndex
	"Answer a new instance whose initial contents is copied from next four bytes from aByteArray starting at startIndex..
	Convention is Most Significant Byte first (aka big endian)."

	^ self basicNew loadFrom: aByteArray at: startIndex
! !
!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:38'!
fromInteger: aPositiveInteger
	"Answer a new instance whose initial contents is copied from aPositiveInteger.
	It is required that aPositiveInteger has no more than 32 bits."

	^ self basicNew load: aPositiveInteger
! !
!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'jm 12/14/1999 16:05' overrides: 16785646!
new
	"Answer a new instance whose initial contents is zero."

	^ super new load: 0
! !

!classDefinition: #UUID category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
ByteArray variableByteSubclass: #UUID
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Identities-UUID'!

!classDefinition: #UUID category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
ByteArray variableByteSubclass: #UUID
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Identities-UUID'!

!classDefinition: 'UUID class' category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
UUID class
	instanceVariableNames: ''!

!classDefinition: 'UUID class' category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
UUID class
	instanceVariableNames: ''!

!classDefinition: #UUIDGenerator category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #UUIDGenerator
	instanceVariableNames: 'timeLow timeMid timeHiAndVersion clockSeqHiAndReserved clockSeqLow node randomCounter randomGenerator semaphoreForGenerator'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Identities-UUID'!

!classDefinition: #UUIDGenerator category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #UUIDGenerator
	instanceVariableNames: 'timeLow timeMid timeHiAndVersion clockSeqHiAndReserved clockSeqLow node randomCounter randomGenerator semaphoreForGenerator'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Identities-UUID'!

!classDefinition: 'UUIDGenerator class' category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
UUIDGenerator class
	instanceVariableNames: ''!

!classDefinition: 'UUIDGenerator class' category: 'Identities-UUID' stamp: 'VV 11/10/2022 00:44:29'!
UUIDGenerator class
	instanceVariableNames: ''!
!UUID commentStamp: '<historical>' prior: 0!
A class to generate UUID
by John M McIntosh johnmci@smalltalkconsulting.com

See http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt

If a plugin does not exist then we generate a UUID version 4 type GUUID!
!UUIDGenerator commentStamp: '<historical>' prior: 0!
This class generates a pseudo-random UUID
by John M McIntosh johnmci@smalltalkconsulting.com

See http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt!
!UUID methodsFor: 'printing' stamp: 'JMM 10/9/2001 14:46' overrides: 16799033!
printOn: aStream
	aStream nextPutAll: 'an UUID('.
	self asString printOn: aStream.
	aStream nextPutAll: ')'! !
!UUIDGenerator class methodsFor: 'class initialization' stamp: 'CdG 11/19/2002 21:07' overrides: 16787245!
startUp
	Default := nil! !
!UUID methodsFor: 'printing' stamp: 'ar 2/8/2004 12:16' overrides: 16902983!
printString
	^self asString! !
!UUID methodsFor: 'comparing' stamp: 'jmv 6/17/2015 18:03'!
< aMagnitude 
	"Answer whether the receiver is less than the argument."

	| x y |
	1 to: self size do: [ :i |
		(x := self at: i) = (y := aMagnitude at: i) ifFalse: [ ^x < y ] ].
	^false.! !
!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!
<= aMagnitude 
	"Answer whether the receiver is less than or equal to the argument."

	^(self > aMagnitude) not! !
!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!
> aMagnitude 
	"Answer whether the receiver is greater than the argument."

	^aMagnitude < self! !
!UUID methodsFor: 'comparing' stamp: 'JMM 11/22/2001 17:30'!
>= aMagnitude 
	"Answer whether the receiver is greater than or equal to the argument."

	^(self < aMagnitude) not! !
!UUID methodsFor: 'converting' stamp: 'ar 2/8/2004 12:16' overrides: 16798942!
asString
	| result data |
	data := String new: 36.
	result := WriteStream on: data.
	1 to: 4 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	5 to: 6 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	7 to: 8 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	9 to: 10 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	11 to: 16 do:[:i| self printHexAt: i to: result].
	^data.
	! !
!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:09'!
asUUID: aString
	| stream token byte |
	stream := ReadStream on: (aString copyReplaceAll: '-' with: '') asUppercase.
	1 to: stream size/2 do: [:i | 
		token := stream next: 2.
		byte := Integer readFrom: (ReadStream on: token ) base: 16.
		self at: i put: byte].
	^self
! !
!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:13'!
createStringStartingAt: index for: bytes

	| results candidate data |
	data := String new: bytes*2.
	results := WriteStream on: data.
	index to: index+bytes -1 do: 
		[:i |
		candidate := ((self at: i) printStringBase: 16) last: 2.
		candidate first = $r ifTrue: [candidate := String with: $0 with: candidate last].
		results nextPutAll: candidate].
	^data asLowercase! !
!UUID methodsFor: 'converting' stamp: 'ar 2/8/2004 12:16'!
printHexAt: index to: aStream
	| map v |
	map := '0123456789abcdef'.
	v := self at: index.
	aStream nextPut: (map at: (v bitShift: -4) + 1). 
	aStream nextPut: (map at: (v bitAnd: 15) + 1).
! !
!UUID methodsFor: 'initalize-release' stamp: 'ar 2/3/2002 19:42' overrides: 16920235!
initialize
	self primMakeUUID.! !
!UUID methodsFor: 'testing' stamp: 'JMM 10/9/2001 14:17'!
isNilUUID
	1 to: self size do: [:i | (self at: i) ~= 0 ifTrue: [^false]].
	^true.! !
!UUID methodsFor: 'system primitives' stamp: 'ar 2/3/2002 19:42'!
primMakeUUID
	<primitive: 'primitiveMakeUUID' module: 'UUIDPlugin'>
	UUIDGenerator default generateBytes: self forVersion: 4.! !
!UUID class methodsFor: 'instance creation' stamp: 'dvf 9/10/2004 23:10'!
fromString: aString
	| object |
	aString size ~= 36 ifTrue: [Error signal].
	object := self nilUUID. 
	object asUUID: aString.
	^object! !
!UUID class methodsFor: 'instance creation' stamp: 'nk 6/28/2004 16:10'!
nilUUID
	"Must call basicNew: here because I have a non-trivial initialize method."

	^self basicNew: 16! !
!UUID class methodsFor: 'instance creation' stamp: 'jmv 9/29/2019 12:55:03' overrides: 16781786!
numElements
	^16! !
!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 13:45'!
generateBytes: aPlaceHolder forVersion: aVersion
	aVersion = 4 ifTrue: [self generateFieldsVersion4]
		ifFalse: [self error: 'Unsupported version'].
	self placeFields: aPlaceHolder.! !
!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 23:13'!
generateFieldsVersion4

	timeLow := self generateRandomBitsOfLength: 32.
	timeMid := self generateRandomBitsOfLength: 16.
	timeHiAndVersion := 16r4000 bitOr: (self generateRandomBitsOfLength: 12).
	clockSeqHiAndReserved := 16r80 bitOr: (self generateRandomBitsOfLength: 6).
	clockSeqLow := self generateRandomBitsOfLength: 8.
	node := self generateRandomBitsOfLength: 48.
	! !
!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/21/2001 14:30' overrides: 16920235!
initialize
	self setupRandom.
	semaphoreForGenerator := Semaphore forMutualExclusion.
	! !
!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 23:12'!
placeFields: aByteArray

	aByteArray at: 1 put: ((timeLow bitShift: -24) bitAnd: 16rFF).
	aByteArray at: 2 put: ((timeLow bitShift: -16) bitAnd: 16rFF).
	aByteArray at: 3 put: ((timeLow bitShift: -8) bitAnd: 16rFF).
	aByteArray at: 4 put: (timeLow bitAnd: 16rFF).
	aByteArray at: 5 put: ((timeMid bitShift: -8) bitAnd: 16rFF).
	aByteArray at: 6 put: (timeMid bitAnd: 16rFF).
	aByteArray at: 7 put: ((timeHiAndVersion bitShift: -8) bitAnd: 16rFF).
	aByteArray at: 8 put: (timeHiAndVersion bitAnd: 16rFF).
	aByteArray at: 9 put: clockSeqHiAndReserved.
	aByteArray at: 10 put: clockSeqLow.
	0 to: 5 do: [:i |
		aByteArray at: 11 + i put: ((node bitShift: (-8*i)) bitAnd: 16rFF)]
! !
!UUIDGenerator methodsFor: 'instance creation' stamp: 'CdG 11/19/2002 21:30'!
setupRandom
	randomCounter := 0.
	randomGenerator := Random seed: self makeSeed.! !
!UUIDGenerator methodsFor: 'generator' stamp: 'nice 12/26/2009 22:20'!
generateOneOrZero
	^self semaphoreForGenerator
		critical: [| value | 
			value := self randomGenerator next.
			self randomCounter: self randomCounter + 1.
			self randomCounter > 100000
				ifTrue: [self setupRandom].
			value < 0.5
				ifTrue: [0]
				ifFalse: [1]].! !
!UUIDGenerator methodsFor: 'generator' stamp: 'JMM 11/21/2001 15:12'!
generateRandomBitsOfLength: aNumberOfBits
| target |
	target := 0.
	aNumberOfBits isZero ifTrue: [^target].
	target := self generateOneOrZero.
	(aNumberOfBits - 1)  timesRepeat:
		[target := (target bitShift: 1)  bitOr: self generateOneOrZero].
	^target! !
!UUIDGenerator methodsFor: 'random seed' stamp: 'jmv 11/9/2021 18:16:32'!
makeSeed
	"Try various methods of getting good seeds"
	| seed |
	seed := self makeUnixSeed.
	seed ifNotNil: [^seed].

	"not sure if this is reliably random... commented out for now. -dew"
	"seed := self makeSeedFromSound.
	seed ifNotNil: [^seed]."
	
	"default"
	[seed := (Time millisecondClockValue bitAnd: 16r3FFFFFFF) bitXor: self hash.
	seed := seed bitXor: (Time localSecondClock bitAnd: 16r3FFFFFFF).
	seed = 0] whileTrue: ["Try again if ever get a seed = 0"].

	^seed
! !
!UUIDGenerator methodsFor: 'random seed' stamp: 'DSG 12/4/2013 20:39'!
makeSeedFromSound
	^[SoundSystem default randomBitsFromSoundInput: 32]
		ifError: [nil].! !
!UUIDGenerator methodsFor: 'random seed' stamp: 'pb 5/25/2016 01:34'!
makeUnixSeed
	
	^[
		'/dev/urandom' asFileEntry readStreamDo: [ :stream |
			stream binary.
			(Integer
				byte1: stream next
				byte2: stream next
				byte3: stream next
				byte4: stream next) ] ] 
		on: Error
		do: [ nil ]! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:28'!
randomCounter
	^randomCounter! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!
randomCounter: aNumber
	randomCounter := aNumber
! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:27'!
randomGenerator
	^randomGenerator
! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:27'!
randomGenerator: aGenerator
	randomGenerator := aGenerator
! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!
semaphoreForGenerator
	^semaphoreForGenerator! !
!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!
semaphoreForGenerator: aSema
	semaphoreForGenerator := aSema
! !
!UUIDGenerator class methodsFor: 'class initialization' stamp: 'CdG 11/19/2002 21:06' overrides: 16904184!
initialize
	Smalltalk addToStartUpList: self after: nil.! !
!UUIDGenerator class methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 13:41'!
default
	Default ifNil: [self generateDefault].
	^Default! !
!UUIDGenerator class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 21:51'!
generateDefault
	Default := self new! !

!classDefinition: #InvalidSocketStatusException category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Error subclass: #InvalidSocketStatusException
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #InvalidSocketStatusException category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Error subclass: #InvalidSocketStatusException
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'InvalidSocketStatusException class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
InvalidSocketStatusException class
	instanceVariableNames: ''!

!classDefinition: 'InvalidSocketStatusException class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
InvalidSocketStatusException class
	instanceVariableNames: ''!

!classDefinition: #NetworkError category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Error subclass: #NetworkError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #NetworkError category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Error subclass: #NetworkError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'NetworkError class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError class
	instanceVariableNames: ''!

!classDefinition: 'NetworkError class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError class
	instanceVariableNames: ''!

!classDefinition: #ConnectionClosed category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #ConnectionClosed category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'ConnectionClosed class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionClosed class
	instanceVariableNames: ''!

!classDefinition: 'ConnectionClosed class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionClosed class
	instanceVariableNames: ''!

!classDefinition: #ConnectionRefused category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionRefused
	instanceVariableNames: 'host port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #ConnectionRefused category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionRefused
	instanceVariableNames: 'host port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'ConnectionRefused class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionRefused class
	instanceVariableNames: ''!

!classDefinition: 'ConnectionRefused class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionRefused class
	instanceVariableNames: ''!

!classDefinition: #ConnectionTimedOut category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionTimedOut
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #ConnectionTimedOut category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #ConnectionTimedOut
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'ConnectionTimedOut class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionTimedOut class
	instanceVariableNames: ''!

!classDefinition: 'ConnectionTimedOut class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionTimedOut class
	instanceVariableNames: ''!

!classDefinition: #NameLookupFailure category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #NameLookupFailure
	instanceVariableNames: 'hostName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #NameLookupFailure category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #NameLookupFailure
	instanceVariableNames: 'hostName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'NameLookupFailure class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NameLookupFailure class
	instanceVariableNames: ''!

!classDefinition: 'NameLookupFailure class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NameLookupFailure class
	instanceVariableNames: ''!

!classDefinition: #NoNetworkError category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #NoNetworkError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #NoNetworkError category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #NoNetworkError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'NoNetworkError class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NoNetworkError class
	instanceVariableNames: ''!

!classDefinition: 'NoNetworkError class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NoNetworkError class
	instanceVariableNames: ''!

!classDefinition: #SocketPrimitiveFailed category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #SocketPrimitiveFailed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #SocketPrimitiveFailed category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetworkError subclass: #SocketPrimitiveFailed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'SocketPrimitiveFailed class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
SocketPrimitiveFailed class
	instanceVariableNames: ''!

!classDefinition: 'SocketPrimitiveFailed class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
SocketPrimitiveFailed class
	instanceVariableNames: ''!

!classDefinition: #ConnectionQueue category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #ConnectionQueue
	instanceVariableNames: 'portNumber maxQueueLength connections accessSema socket process'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #ConnectionQueue category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #ConnectionQueue
	instanceVariableNames: 'portNumber maxQueueLength connections accessSema socket process'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'ConnectionQueue class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionQueue class
	instanceVariableNames: ''!

!classDefinition: 'ConnectionQueue class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
ConnectionQueue class
	instanceVariableNames: ''!

!classDefinition: #NetNameResolver category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #NetNameResolver
	instanceVariableNames: ''
	classVariableNames: 'DefaultHostName HaveNetwork ResolverBusy ResolverError ResolverMutex ResolverReady ResolverSemaphore ResolverUninitialized'
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #NetNameResolver category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #NetNameResolver
	instanceVariableNames: ''
	classVariableNames: 'DefaultHostName HaveNetwork ResolverBusy ResolverError ResolverMutex ResolverReady ResolverSemaphore ResolverUninitialized'
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'NetNameResolver class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetNameResolver class
	instanceVariableNames: ''!

!classDefinition: 'NetNameResolver class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
NetNameResolver class
	instanceVariableNames: ''!

!classDefinition: #Socket category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #Socket
	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore'
	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection'
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #Socket category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #Socket
	instanceVariableNames: 'semaphore socketHandle readSemaphore writeSemaphore'
	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed Registry RegistryThreshold TCPSocketType ThisEndClosed UDPSocketType Unconnected WaitingForConnection'
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'Socket class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Socket class
	instanceVariableNames: ''!

!classDefinition: 'Socket class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Socket class
	instanceVariableNames: ''!

!classDefinition: #SocketStream category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #SocketStream
	instanceVariableNames: 'recentlyRead socket inBuffer outBuffer inNextToWrite outNextToWrite lastRead timeout autoFlush bufferSize binary shouldSignal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: #SocketStream category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
Object subclass: #SocketStream
	instanceVariableNames: 'recentlyRead socket inBuffer outBuffer inNextToWrite outNextToWrite lastRead timeout autoFlush bufferSize binary shouldSignal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Network-Kernel'!

!classDefinition: 'SocketStream class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
SocketStream class
	instanceVariableNames: ''!

!classDefinition: 'SocketStream class' category: 'Network-Kernel' stamp: 'VV 11/10/2022 00:44:29'!
SocketStream class
	instanceVariableNames: ''!
!InvalidSocketStatusException commentStamp: '<historical>' prior: 0!
Signals if an operation on a Socket found it in a state invalid for that operation.!
!NetworkError commentStamp: 'mir 5/12/2003 18:12' prior: 0!
Abstract super class for all network related exceptions.!
!ConnectionClosed commentStamp: '<historical>' prior: 0!
Signals a prematurely closed connection.!
!ConnectionRefused commentStamp: 'mir 5/12/2003 18:14' prior: 0!
Signals that a connection to the specified host and port was refused.

	host		host which refused the connection
	port		prot to which the connection was refused
!
!ConnectionTimedOut commentStamp: '<historical>' prior: 0!
Signals that a connection attempt timed out.!
!NameLookupFailure commentStamp: 'mir 5/12/2003 18:16' prior: 0!
Signals that a name lookup operation failed.

	hostName	hostName for which the name loopup failed
!
!NoNetworkError commentStamp: '<historical>' prior: 0!
Signals that no network was found. This could happen, e.g., on dial-up connection when no connection was established when Squeak tried to access it.!
!ConnectionQueue commentStamp: '<historical>' prior: 0!
A ConnectionQueue listens on a given port number and collects a queue of client connections. In order to handle state changes quickly, a ConnectionQueue has its own process that: (a) tries to keep a socket listening on the port whenever the queue isn't already full of connections and (b) prunes stale connections out of the queue to make room for fresh ones.
!
!NetNameResolver commentStamp: '<historical>' prior: 0!
This class implements TCP/IP style network name lookup and translation facilities.

Attempt to keep track of whether there is a network available.
HaveNetwork	true if last attempt to contact the network was successful.
LastContact		Time of that contact (totalSeconds).
haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!
!Socket commentStamp: 'gk 12/13/2005 00:43' prior: 0!
A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocols. Sockets are the lowest level of networking object in Squeak and are not normally used directly. SocketStream is a higher level object wrapping a Socket in a stream like protocol.

ProtocolClient and subclasses are in turn wrappers around a SocketStream to provide support for specific network protocols such as POP, NNTP, HTTP, and FTP.!
!SocketStream commentStamp: '<historical>' prior: 0!
SocketStream is a wrapper for class Socket making it easy to write networking code by giving the programmer a stream-like protocol. A Socket is a two way communication link with two logically separate channels - input and output. The Socket class is the lowest level in Squeak for network communication and using it directly can be difficult and bug prone.

A SocketStream can be in binary or ascii mode, ascii is the default which means you are transmitting and receiving Strings. Most Internet protocols are in clear text ascii, like for example HTTP. Another setting is what timeout you want to use - default is the standardTimeout from Socket. More settings can be found in the method category 'configuration'.

Simplest example of connecting, sending/receiving and closing:

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]

There are two important things to note above:
	- The methods in category "stream in" can signal two exceptions (unless turned off with #shouldSignal:):
		ConnectionClosed and ConnectionTimedOut
	- We close the stream using #ensure:, that is to make sure it isn't left opened.
	- We use #on:do: to catch any signal. In this case we do not need to catch ConnectionClosed since #upToEnd does that for us intrinsically.

----------------
SocketStream (below called SS) is a reimplementation of 'Old'-SocketStream (below called OSS) - the class that originates from the original Comanche implementation but now is included in standard Squeak. SS has the same protocol as OSS and is meant to replace it. SS is faster, more flexible, is better documented and adds a few features:

1. #shouldSignal:, which decides if SS should signal low level Socket exceptions (true) or if it should swallow them like original OSS did. Default is true. The only reason I added this is for backwards compatibility - not signalling causes problems - see bug 4 below.

2. #nextAllInBuffer, #nextInBuffer:, #skip:, #receiveData:, #nextPutAllFlush: and #recentlyRead are new additions to the public protocol.


It also fixes various bugs:

1. #isDataAvailable could theoretically answer false, when there actually is some in the buffer in OSS. If #receiveDataIfAvailable reads the last byte then the following "socket dataAvailable" would answer false. So the last byte would be sitting in the inStream missed.

2. #upToAll: in OSS has several problems, for example - #positionOfSubCollection:ifAbsent: which was introduced answers one position too low. This was compensated in upToAll:, but only in the pushBack: call, not the actual result being returned which was cut short 1 byte. Amusingly this makes KomHttpServer not use "Keep-Alive" since the last $e in 'Alive' was cut short. :)

3. SS doesn't inherit from PositionableStream since that just breaks various inherited messages, like for example #skip:. OSS should IMHO be changed to inherit from Object - or of course, replaced in full with SS. :)

4. Since SocketStream by default signals closes and timeouts the SocketStreamTest now passes. The reason for SocketStream to fail is that while it does timeout on a low level (#SocketStream>>receiveData doesn't hang forever) - the callers of #receiveData sometimes loop - like in #next:, and thus eliminates the timeout. SS warns about some methods (in their method comments) not honouring timeouts if shouldSignal is false, I really don't know what they should do in that case:
	#next:, #upTo:, #upToAll: and #upToEnd (and #receiveData:)


The primary reason for the SS implementation is optimal performance. The main differences in implementation with the old OSS are:

1. SS uses two buffers directly (inBuffer and outBuffer) with pointers marking start and stop within the buffer. OSS instead uses two regular streams, a ReadStream and a WriteStream. Using internal buffers makes it possible to avoid copying and reallocation in various ways, it also makes SS be able to have specialized growing/buffer moving behaviour.

2. #upTo:, #upToAll: and #peekForAll: uses selectged String messages that in turn uses fast primitives for searching. OSS used other messages that fell back on byte per byte reading.

3. #receiveData in OSS creates a temporary buffer stream for each call!! During a long read operation, like say #upToAll: (which for example is used when uploading files using HTTP POST forms), this is devastating - especially since the default size is only 2000 bytes - and leads to a very high number of low level read operations on the Socket, typically 100 times more calls than with OSS. The buffer in OSS is held in an instvar (not recreated for each call), is larger from the start and above all - grows dynamically by doubling. OSS can also avoid a grow/reallocation by doing a "move down" if data has been read from the SS as it comes in and through that making room in the lower part of the inBuffer. The net result is that upToAll: for large files is about 10 times faster.

4. The implementation of upTo: and upToAll: tries to avoid doing unnecessary find operations in the buffer and is greedy by default, which means it favors reading more data - if available - before searching for the stop sequence. If we had #findString:startingAt:stoppingAt: this wouldn't have to be greedy and we wouldn't be needlessly scanning dead buffer area. VM hackers? Also, while you are at it - make it work for ByteArrays too. :)


SS can not be run unbuffered, since that seems unneeded. The option to autoFlush is still available, with it set to true SocketStream (just like OSS) will flush on its own on each nextPut:/nextPutAll:, otherwise flushing it will have to be done manually but is done on close.

The first performance tests shows that, as noted above, receiving large amounts of data using #upToAll: is greatly improved - factor of 10. Serving HTTP with small payloads seemed at first not be faster at all - but this is due to the high overhead of Socket connect/close and other things. Increasing payloads show a difference and especially with keep alive on - where the new SS roughly doubles the throughput!!!
!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:58'!
host
	^ host! !
!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:39'!
host: addressOrHostName port: portNumber
	host _ addressOrHostName.
	port _ portNumber! !
!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:58'!
port
	^ port! !
!ConnectionRefused class methodsFor: 'instance creation' stamp: 'len 12/14/2002 11:39'!
host: addressOrHostName port: portNumber
	^ self new host: addressOrHostName port: portNumber! !
!NameLookupFailure methodsFor: 'accessing' stamp: 'jmv 3/13/2012 23:13' overrides: 16848979!
defaultAction
	"Backward compatibility"
	| response |
	response _ (PopUpMenu labels: 'Retry\Give Up' withNewLines)
			startUpWithCaption: self messageText.
	^ response = 2
		ifFalse: [self retry]! !
!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 11:57'!
hostName
	^ hostName! !
!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 11:57'!
hostName: aString
	hostName _ aString! !
!NameLookupFailure class methodsFor: 'instance creation' stamp: 'len 12/14/2002 11:57'!
hostName: aString
	^ self new hostName: aString! !
!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:23'!
connectionCount
	"Return an estimate of the number of currently queued connections. This is only an estimate since a new connection could be made, or an existing one aborted, at any moment."

	self pruneStaleConnections.
	^accessSema critical: [connections size]! !
!ConnectionQueue methodsFor: 'public' stamp: 'jm 3/9/98 14:34'!
destroy
	"Terminate the listener process and destroy all sockets in my possesion."

	process ifNotNil: [
		process terminate.
		process _ nil].
	socket ifNotNil: [
		socket destroy.
		socket _ nil].
	connections do: [:s | s destroy].
	connections _ OrderedCollection new.
! !
!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:24'!
getConnectionOrNil
	"Return a connected socket, or nil if no connection has been established."

	^accessSema critical: [
		| result |
		connections isEmpty
			ifTrue: [result := nil]
			ifFalse: [
				result := connections removeFirst.
				((result isValid) and: [result isConnected]) ifFalse: [  "stale connection"
					result destroy.
					result := nil]].
		result]! !
!ConnectionQueue methodsFor: 'public' stamp: 'nice 12/26/2009 01:25'!
getConnectionOrNilLenient
	"Return a connected socket, or nil if no connection has been established."

	^accessSema critical: [
		| result |
		connections isEmpty ifTrue: [
			result := nil
		] ifFalse: [
			result := connections removeFirst.
			(result isValid and: [result isConnected or: [result isOtherEndClosed]]) ifFalse: [
				"stale connection"
				result destroy.
				result := nil
			]
		].
		result
	].
! !
!ConnectionQueue methodsFor: 'private' stamp: 'jmv 10/8/2012 22:17'!
initPortNumber: anInteger queueLength: queueLength
	"Private!! Initialize the receiver to listen on the given port number. Up to queueLength connections will be queued."

	portNumber _ anInteger.
	maxQueueLength _ queueLength.
	connections _ OrderedCollection new.
	accessSema _ Semaphore forMutualExclusion.
	socket _ nil.
	process _ [self listenLoop] newProcess.
	process priority: Processor highIOPriority.
	process name: 'ConnectionQueue'.
	process resume! !
!ConnectionQueue methodsFor: 'public' stamp: 'ls 9/26/1999 15:34'!
isValid
	^process notNil! !
!ConnectionQueue methodsFor: 'private' stamp: 'jmv 6/1/2011 23:00'!
listenLoop
	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."
	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."
	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."


	| newConnection |

	socket := Socket newTCP.
	"We'll accept four simultanous connections at the same time"
	socket listenOn: portNumber backlogSize: 4.
	"If the listener is not valid then the we cannot use the
	BSD style accept() mechanism."
	socket isValid ifFalse: [^self oldStyleListenLoop].
	[true] whileTrue: [
		socket isValid ifFalse: [
			"socket has stopped listening for some reason"
			socket destroy.
			(Delay forMilliseconds: 10) wait.
			^self listenLoop ].
		newConnection := socket 
			waitForAcceptFor: 10
			ifTimedOut: [ nil ].
		(newConnection notNil and: [newConnection isConnected]) ifTrue: [
			accessSema critical: [connections addLast: newConnection.].
			newConnection := nil.
			self changed: self].
		self pruneStaleConnections]. ! !
!ConnectionQueue methodsFor: 'private' stamp: 'ul 11/25/2010 21:20'!
oldStyleListenLoop
	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."
	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."
	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."

	[true] whileTrue: [
		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [
			"try to create a new socket for listening"
			socket := Socket createIfFail: [nil]].

		socket == nil
			ifTrue: [(Delay forMilliseconds: 100) wait]
			ifFalse: [
				socket isUnconnected ifTrue: [socket listenOn: portNumber].
				socket 
					waitForConnectionFor: 10
					ifTimedOut: [
						socket isConnected
							ifTrue: [  "connection established"
								accessSema critical: [connections addLast: socket].
								socket := nil]
							ifFalse: [
								socket isWaitingForConnection
									ifFalse: [socket destroy. socket := nil]]]].  "broken socket; start over"
		self pruneStaleConnections].
! !
!ConnectionQueue methodsFor: 'private' stamp: 'nice 12/26/2009 01:25'!
pruneStaleConnections
	"Private!! The client may establish a connection and then disconnect while it is still in the connection queue. This method is called periodically to prune such sockets out of the connection queue and make room for fresh connections."

	accessSema critical: [
		| foundStaleConnection |
		foundStaleConnection := false.
		connections do: [:s |
			s isUnconnected ifTrue: [
				s destroy.
				foundStaleConnection := true]].
		foundStaleConnection ifTrue: [
			connections := connections select: [:s | s isValid]]].
! !
!ConnectionQueue class methodsFor: 'instance creation' stamp: 'jm 3/9/98 14:09'!
portNumber: anInteger queueLength: queueLength

	^ self new initPortNumber: anInteger queueLength: queueLength
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'ls 9/5/1998 01:14'!
addressForName: aString
	^self addressForName: aString timeout: 60! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jmv 4/17/2013 12:07'!
addressForName: hostName timeout: secs
	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."
	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"
	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"
	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"
	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"

	| deadline result |
	self initializeNetwork.
	"check if this is a valid numeric host address (e.g. 1.2.3.4)"
	result _ self addressFromString: hostName.
	result ifNotNil: [^result].

	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"
	deadline _ Time localMillisecondClock + (secs * 1000).
	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."
	self resolverMutex
		critical: [
			(self waitForResolverReadyUntil: deadline)
				ifTrue: [
					self primStartLookupOfName: hostName.
					(self waitForCompletionUntil: deadline)
						ifTrue: [result _ self primNameLookupResult]
						ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]
				ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]].
	^result! !
!NetNameResolver class methodsFor: 'address string utils' stamp: 'jmv 3/2/2010 11:22'!
addressFromString: addressString
	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."
	"NetNameResolver addressFromString: '1.2.3.4'"
	"NetNameResolver addressFromString: '1,2,3,4'"
	"NetNameResolver addressFromString: '1 2 3 4'"

	| newAddr s byte delimiter |
	newAddr _ ByteArray new: 4.
	s _ ReadStream on: addressString.
	s skipSeparators.
	1 to: 4 do: [:i |
		byte _ self readDecimalByteFrom: s.
		byte ifNil: [^ nil].
		newAddr at: i put: byte.
		i < 4 ifTrue: [
			delimiter _ s next.
			((delimiter = $.) or: [(delimiter = $,) or: [delimiter = $ ]])
				ifFalse: [^ nil]]].
	^ newAddr
! !
!NetNameResolver class methodsFor: 'class initialization' stamp: 'jm 9/17/97 16:18' overrides: 16904184!
initialize
	"NetNameResolver initialize"
	"Note: On the Mac, the name resolver is asynchronous (i.e., Squeak can do other things while it is working), but can only handle one request at a time. On other platforms, such as Unix, the resolver is synchronous; a call to, say, the name lookup primitive will block all Squeak processes until it returns."

	"Resolver Status Values"
	ResolverUninitialized _ 0.	"network is not initialized"
	ResolverReady _ 1.			"resolver idle, last request succeeded"
	ResolverBusy _ 2.			"lookup in progress"
	ResolverError _ 3.			"resolver idle, last request failed"

	DefaultHostName _ ''.
! !
!NetNameResolver class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 15:03'!
initializeNetwork
	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."
	"NetNameResolver initializeNetwork"

	| semaIndex |
	self resolverStatus = ResolverUninitialized
		ifFalse: [^HaveNetwork _ true].  "network is already initialized"

	HaveNetwork _ false.	"in case abort"
	ResolverSemaphore _ Semaphore new.
	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.

	"result is nil if network initialization failed, self if it succeeds"
	(self primInitializeNetwork: semaIndex)
		ifNil: [NoNetworkError signal: 'failed network initialization']
		ifNotNil: [HaveNetwork _ true].
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:52'!
localAddressString
	"Return a string representing the local host address as four decimal bytes delimited with decimal points."
	"NetNameResolver localAddressString"

	^ NetNameResolver stringFromAddress: NetNameResolver localHostAddress
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:50'!
localHostAddress
	"Return the local address of this host."
	"NetNameResolver localHostAddress"

	self initializeNetwork.
	^ self primLocalAddress
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:12'!
localHostName
	"Return the local name of this host."
	"NetNameResolver localHostName"

	| hostName |
	hostName _ NetNameResolver
		nameForAddress: self localHostAddress
		timeout: 5.
	^hostName
		ifNil: [self localAddressString]
		ifNotNil: [hostName]! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jmv 4/17/2013 12:07'!
nameForAddress: hostAddress timeout: secs
	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."
	"NetNameResolver
		nameForAddress: (NetNameResolver addressFromString: '128.111.92.2')
		timeout: 30"

	| deadline |
	self initializeNetwork.
	deadline := Time localMillisecondClock + (secs * 1000).
	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."
	^self resolverMutex
		critical: [
			(self waitForResolverReadyUntil: deadline)
				ifTrue: [
					self primStartLookupOfAddress: hostAddress.
					(self waitForCompletionUntil: deadline)
						ifTrue: [self primAddressLookupResult]
						ifFalse: [nil]]
				ifFalse: [nil]].! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primAbortLookup
	"Abort the current lookup operation, freeing the name resolver for the next query."

	<primitive: 'primitiveResolverAbortLookup' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primAddressLookupResult
	"Return the host name found by the last host address lookup. Returns nil if the last lookup was unsuccessful."

	<primitive: 'primitiveResolverAddressLookupResult' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'network initialization' stamp: 'ar 2/2/2001 15:09'!
primInitializeNetwork: resolverSemaIndex
	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the receiver if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."
	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."

	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>
	^ nil  "return nil if primitive fails"
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primLocalAddress
	"Return the local address of this host."

	<primitive: 'primitiveResolverLocalAddress' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primNameLookupResult
	"Return the host address found by the last host name lookup. Returns nil if the last lookup was unsuccessful."

	<primitive: 'primitiveResolverNameLookupResult' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primNameResolverError
	"Return an integer reflecting the error status of the last network name resolver request. Zero means no error."

	<primitive: 'primitiveResolverError' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primNameResolverStatus
	"Return an integer reflecting the status of the network name resolver. For a list of possible values, see the comment in the 'initialize' method of this class."

	<primitive: 'primitiveResolverStatus' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primStartLookupOfAddress: hostAddr
	"Look up the given host address in the Domain Name Server to find its name. This call is asynchronous. To get the results, wait for it to complete or time out and then use primAddressLookupResult."

	<primitive: 'primitiveResolverStartAddressLookup' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primStartLookupOfName: hostName
	"Look up the given host name in the Domain Name Server to find its address. This call is asynchronous. To get the results, wait for it to complete or time out and then use primNameLookupResult."

	<primitive: 'primitiveResolverStartNameLookup' module: 'SocketPlugin'>
	self primitiveFailed
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/17/97 16:26'!
promptUserForHostAddress
	"Ask the user for a host name and return its address."
	"NetNameResolver promptUserForHostAddress"

	^ NetNameResolver promptUserForHostAddressDefault: ''
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'jmv 9/24/2012 19:47'!
promptUserForHostAddressDefault: defaultName
	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."
	"NetNameResolver promptUserForHostAddressDefault: ''"

	| default hostName serverAddr |
	defaultName isEmpty
		ifTrue: [default _ DefaultHostName]
		ifFalse: [default _ defaultName].
	hostName _ FillInTheBlankMorph
		request: 'Host name or address?'
		initialAnswer: default.
	hostName isEmpty ifTrue: [^ 0].
	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.
	hostName size > 0 ifTrue: [DefaultHostName _ hostName].
	^ serverAddr! !
!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 13:57'!
readDecimalByteFrom: aStream
	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255.
JMM - 000503 fixed didn't work correctly"

	| digitSeen value digit |
	digitSeen _ false.
	value _ 0.
	[aStream atEnd] whileFalse: 
		[digit _ aStream next digitValue.
		(digit < 0 or: [digit > 9]) ifTrue: [
			aStream skip: -1.
			(digitSeen not or: [value > 255]) ifTrue: [^ nil].
			^ value].
		digitSeen _ true.
		value _ (value * 10) + digit].
	(digitSeen not or: [value > 255]) ifTrue: [^ nil].
	^ value
! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!
resolverError
	^self primNameResolverError
! !
!NetNameResolver class methodsFor: 'private' stamp: 'mir 6/18/2001 21:05'!
resolverMutex
	ResolverMutex ifNil: [ResolverMutex _ Semaphore forMutualExclusion].
	^ResolverMutex! !
!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!
resolverStatus
	^self primNameResolverStatus
! !
!NetNameResolver class methodsFor: 'address string utils' stamp: 'jmv 2/23/2013 22:08'!
stringFromAddress: addr
	"Return a string representing the given host address as four decimal bytes delimited with decimal points."
	"NetNameResolver stringFromAddress: NetNameResolver localHostAddress"

	| s |
	s _ WriteStream on: String new.
	1 to: 3 do: [ :i | (addr at: i) printOn: s. s nextPut: $. ].
	(addr at: 4) printOn: s.
	^ s contents! !
!NetNameResolver class methodsFor: 'private' stamp: 'jmv 4/17/2013 12:07'!
waitForCompletionUntil: deadline
	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."

	| status |
	status _ self resolverStatus.
	[(status = ResolverBusy) and:
	 [Time localMillisecondClock < deadline]]
		whileTrue: [
			"wait for resolver to be available"
			ResolverSemaphore waitTimeoutMSecs: (deadline - Time localMillisecondClock).
			status _ self resolverStatus].

	status = ResolverReady
		ifTrue: [^ true]
		ifFalse: [
			status = ResolverBusy ifTrue: [self primAbortLookup].
			^ false].
! !
!NetNameResolver class methodsFor: 'private' stamp: 'jmv 4/17/2013 12:07'!
waitForResolverReadyUntil: deadline
	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."

	| status |
	status _ self resolverStatus.
	status = ResolverUninitialized ifTrue: [^ false].

	[(status = ResolverBusy) and:
	 [Time localMillisecondClock < deadline]]
		whileTrue: [
			"wait for resolver to be available"
			ResolverSemaphore waitTimeoutMSecs: (deadline - Time localMillisecondClock).
			status _ self resolverStatus].

	^ status ~= ResolverBusy
! !
!Socket methodsFor: 'connection open/close' stamp: 'jmv 6/25/2017 21:35:04'!
accept
	"Accept a connection from the receiver socket.
	Return a new socket that is connected to the client"
	^self class acceptFrom: self! !
!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!
acceptFrom: aSocket
	"Initialize a new socket handle from an accept call"
	| semaIndex readSemaIndex writeSemaIndex |

	semaphore := Semaphore new.
	readSemaphore := Semaphore new.
	writeSemaphore := Semaphore new.
	semaIndex := Smalltalk registerExternalObject: semaphore.
	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.
	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.
	socketHandle := self primAcceptFrom: aSocket socketHandle
						receiveBufferSize: 8000
						sendBufSize: 8000
						semaIndex: semaIndex
						readSemaIndex: readSemaIndex
						writeSemaIndex: writeSemaIndex.
	socketHandle
		ifNotNil: [ self register ]
		ifNil: [  "socket creation failed"
			Smalltalk unregisterExternalObject: semaphore.
			Smalltalk unregisterExternalObject: readSemaphore.
			Smalltalk unregisterExternalObject: writeSemaphore.
			readSemaphore := writeSemaphore := semaphore := nil ]
! !
!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!
address
	"Shortcut"
	^self localAddress! !
!Socket methodsFor: 'connection open/close' stamp: 'jm 9/11/97 20:29'!
close
	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."

	self primSocketCloseConnection: socketHandle.  "close this end"
! !
!Socket methodsFor: 'connection open/close' stamp: 'jm 11/4/97 07:15'!
closeAndDestroy
	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."

	self closeAndDestroy: 20.

! !
!Socket methodsFor: 'connection open/close' stamp: 'marcus.denker 9/14/2008 21:20'!
closeAndDestroy: timeoutSeconds
	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."

	socketHandle ifNotNil: [
			self isConnected ifTrue: [
				self close.  "close this end"
				(self waitForDisconnectionFor: timeoutSeconds) ifFalse: [
						"The other end didn't close so we just abort the connection"
						self primSocketAbortConnection: socketHandle]].
			self destroy].
! !
!Socket methodsFor: 'connection open/close' stamp: 'mir 5/9/2003 18:13'!
connectNonBlockingTo: hostAddress port: port
	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."

	| status |
	self initializeNetwork.
	status := self primSocketConnectionStatus: socketHandle.
	(status == Unconnected)
		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before opening a new connection'].

	self primSocket: socketHandle connectTo: hostAddress port: port.
! !
!Socket methodsFor: 'connection open/close' stamp: 'mir 5/15/2003 18:29'!
connectTo: hostAddress port: port
	"Initiate a connection to the given port at the given host address.
	Waits until the connection is established or time outs."

	self connectTo: hostAddress port: port waitForConnectionFor: Socket standardTimeout! !
!Socket methodsFor: 'connection open/close' stamp: 'mu 8/14/2003 15:15'!
connectTo: hostAddress port: port waitForConnectionFor: timeout 
	"Initiate a connection to the given port at the given host 
	address. Waits until the connection is established or time outs."
	self connectNonBlockingTo: hostAddress port: port.
	self
		waitForConnectionFor: timeout
		ifTimedOut: [ConnectionTimedOut signal: 'Cannot connect to '
					, (NetNameResolver stringFromAddress: hostAddress) , ':' , port asString]! !
!Socket methodsFor: 'connection open/close' stamp: 'mir 5/8/2003 16:03'!
connectToHostNamed: hostName port: portNumber
	| serverIP |
	serverIP _ NetNameResolver addressForName: hostName timeout: 20.
	^self connectTo: serverIP port: portNumber
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
dataAvailable
	"Return true if this socket has unread received data."

	socketHandle ifNil: [^ false].
	^ self primSocketReceiveDataAvailable: socketHandle
! !
!Socket methodsFor: 'initialize-destroy' stamp: 'jmv 3/2/2010 11:28'!
destroy
	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."

	socketHandle ifNotNil: [
		self isValid ifTrue: [self primSocketDestroy: socketHandle].
		Smalltalk unregisterExternalObject: semaphore.
		Smalltalk unregisterExternalObject: readSemaphore.
		Smalltalk unregisterExternalObject: writeSemaphore.
		socketHandle _ nil.
		readSemaphore _ writeSemaphore _ semaphore _ nil.
		self unregister]! !
!Socket methodsFor: 'receiving' stamp: 'gk 12/14/2005 10:02'!
discardReceivedData
	"Discard any data received up until now, and return the number of bytes discarded."

	| buf totalBytesDiscarded |
	buf := String new: 10000.
	totalBytesDiscarded := 0.
	[self isConnected] whileTrue: [
		totalBytesDiscarded :=
			totalBytesDiscarded + (self receiveDataInto: buf)].
	^ totalBytesDiscarded
! !
!Socket methodsFor: 'connection open/close' stamp: 'jm 3/10/98 11:56'!
disconnect
	"Break this connection, no matter what state it is in. Data that has been sent but not received will be lost."

	self primSocketAbortConnection: socketHandle.
! !
!Socket methodsFor: 'finalization' stamp: 'JMM 5/22/2000 22:52' overrides: 16902461!
finalize
	self primSocketDestroyGently: socketHandle.
	Smalltalk unregisterExternalObject: semaphore.
	Smalltalk unregisterExternalObject: readSemaphore.
	Smalltalk unregisterExternalObject: writeSemaphore.
! !
!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:25'!
getOption: aName 
	"Get options on this socket, see Unix man pages for values for 
	sockets, IP, TCP, UDP. IE SO_KEEPALIVE
	returns an array, element one is an status number (0 ok, -1 read only option)
	element two is the resulting of the requested option"

	(socketHandle == nil or: [self isValid not])
		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before getting an option'].
	^self primSocket: socketHandle getOption: aName

"| foo options |
Socket initializeNetwork.
foo _ Socket newTCP.
foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.
foo waitForConnectionUntil: (Socket standardDeadline).

options _ {
'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.
'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.
'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.
'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.
'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.
'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.
'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 
'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.
'TCP_URGENT_PTR_TYPE'}.

1 to: options size do: [:i | | fum |
	fum _foo getOption: (options at: i).
	Transcript show: (options at: i),fum printString;cr].

foo _ Socket newUDP.
foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.
foo waitForConnectionUntil: (Socket standardDeadline).

1 to: options size do: [:i | | fum |
	fum _foo getOption: (options at: i).
	Transcript show: (options at: i),fum printString;cr].
"! !
!Socket methodsFor: 'initialize-destroy' stamp: 'ul 4/20/2011 01:56'!
initialize: socketType
	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."
	| semaIndex readSemaIndex writeSemaIndex |

	semaphore := Semaphore new.
	readSemaphore := Semaphore new.
	writeSemaphore := Semaphore new.
	semaIndex := Smalltalk registerExternalObject: semaphore.
	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.
	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.
	socketHandle :=
		self primSocketCreateNetwork: 0
			type: socketType
			receiveBufferSize: 8000
			sendBufSize: 8000
			semaIndex: semaIndex
			readSemaIndex: readSemaIndex
			writeSemaIndex: writeSemaIndex.

	socketHandle 
		ifNotNil: [ self register ]
		ifNil: [  "socket creation failed"
			Smalltalk unregisterExternalObject: semaphore.
			Smalltalk unregisterExternalObject: readSemaphore.
			Smalltalk unregisterExternalObject: writeSemaphore.
			readSemaphore := writeSemaphore := semaphore := nil ]
! !
!Socket methodsFor: 'initialize-destroy' stamp: 'mir 2/22/2002 15:48'!
initializeNetwork
	self class initializeNetwork! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
isConnected
	"Return true if this socket is connected."

	socketHandle ifNil: [^ false].
	^ (self primSocketConnectionStatus: socketHandle) == Connected
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
isOtherEndClosed
	"Return true if this socket had the other end closed."

	socketHandle ifNil: [^ false].
	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
isThisEndClosed
	"Return true if this socket had the this end closed."

	socketHandle ifNil: [^ false].
	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
isUnconnected
	"Return true if this socket's state is Unconnected."

	socketHandle ifNil: [^ false].
	^ (self primSocketConnectionStatus: socketHandle) == Unconnected
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:32'!
isUnconnectedOrInvalid
	"Return true if this socket is completely disconnected or is invalid."

	| status |
	socketHandle ifNil: [^ true].
	status _ self primSocketConnectionStatus: socketHandle.
	^ (status = Unconnected) | (status = InvalidSocket)
! !
!Socket methodsFor: 'queries' stamp: 'jm 11/4/97 07:15'!
isValid
	"Return true if this socket contains a valid, non-nil socket handle."

	| status |
	socketHandle ifNil: [^ false].
	status _ self primSocketConnectionStatus: socketHandle.
	^ status ~= InvalidSocket
! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:33'!
isWaitingForConnection
	"Return true if this socket is waiting for a connection."

	socketHandle ifNil: [^ false].
	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection
! !
!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!
listenOn: port
	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."

	| status |
	status := self primSocketConnectionStatus: socketHandle.
	(status == Unconnected)
		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].

	self primSocket: socketHandle listenOn: port.
! !
!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!
listenOn: portNumber backlogSize: backlog
	"Listen for a connection on the given port.
	If this method succeeds, #accept may be used to establish a new connection"
	| status |
	status := self primSocketConnectionStatus: socketHandle.
	(status == Unconnected)
		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].
	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.
! !
!Socket methodsFor: 'connection open/close' stamp: 'ikp 9/1/2003 20:32'!
listenOn: portNumber backlogSize: backlog interface: ifAddr
	"Listen for a connection on the given port.
	If this method succeeds, #accept may be used to establish a new connection"
	| status |
	status := self primSocketConnectionStatus: socketHandle.
	(status == Unconnected)
		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].
	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog interface: ifAddr.
! !
!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!
localAddress

	self isWaitingForConnection ifFalse: [
		self
			waitForConnectionFor: Socket standardTimeout
			ifTimedOut: [ ^ByteArray new: 4 ] ].
	^self primSocketLocalAddress: socketHandle! !
!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21'!
localPort

	self isWaitingForConnection ifFalse: [
		self
			waitForConnectionFor: Socket standardTimeout
			ifTimedOut: [ ^0] ].
	^ self primSocketLocalPort: socketHandle! !
!Socket methodsFor: 'accessing' stamp: 'jm 3/13/98 12:11'!
peerName
	"Return the name of the host I'm connected to, or nil if its name isn't known to the domain name server or the request times out."
	"Note: Slow. Calls the domain name server, taking up to 20 seconds to time out. Even when sucessful, delays of up to 13 seconds have been observed during periods of high network load." 

	^ NetNameResolver
		nameForAddress: self remoteAddress
		timeout: 20
! !
!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!
port
	"Shortcut"
	^self localPort! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex
	"Create and return a new socket handle based on accepting the connection from the given listening socket"
	<primitive: 'primitiveSocketAccept' module: 'SocketPlugin'>
	^self primitiveFailed! !
!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:55'!
primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema
	"Create and return a new socket handle based on accepting the connection from the given listening socket"
	
	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>
	self primitiveFailed! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: socketID connectTo: hostAddress port: port
	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."

	<primitive: 'primitiveSocketConnectToPort' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!
primSocket: socketID getOption: aString 
	"Get some option information on this socket. Refer to the UNIX 
	man pages for valid SO, TCP, IP, UDP options. In case of doubt
	refer to the source code.
	TCP_NODELAY, SO_KEEPALIVE are valid options for example
	returns an array containing the error code and the option value"

	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: socketID listenOn: port
	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."

	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: aHandle listenOn: portNumber backlogSize: backlog
	"Primitive. Set up the socket to listen on the given port.
	Will be used in conjunction with #accept only."
	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>
	self destroy. "Accept not supported so clean up"! !
!Socket methodsFor: 'primitives' stamp: 'ikp 9/1/2003 20:33'!
primSocket: aHandle listenOn: portNumber backlogSize: backlog interface: ifAddr
	"Primitive. Set up the socket to listen on the given port.
	Will be used in conjunction with #accept only."
	<primitive: 'primitiveSocketListenOnPortBacklogInterface' module: 'SocketPlugin'>
	self destroy. "Accept not supported so clean up"! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count
	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."

	<primitive: 'primitiveSocketReceiveDataBufCount' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'JMM 5/24/2000 17:19'!
primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count
	"Receive data from the given socket into the given array starting at the given index. 
	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"

	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count
	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."
	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."

	<primitive: 'primitiveSocketSendDataBufCount' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 00:08'!
primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count
	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."
	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."

	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>
	self primitiveFailed

! !
!Socket methodsFor: 'primitives' stamp: 'ar 7/18/2000 11:42'!
primSocket: socketID setOption: aString value: aStringValue
	"Set some option information on this socket. Refer to the UNIX 
	man pages for valid SO, TCP, IP, UDP options. In case of doubt
	refer to the source code.
	TCP_NODELAY, SO_KEEPALIVE are valid options for example
	returns an array containing the error code and the negotiated value"

	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>
	^nil! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocket: socketID setPort: port
	"Set the local port associated with a UDP socket.
	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but
	the effects will not be what was desired.  Best solution would be to split Socket into
	two subclasses, TCPSocket and UDPSocket."

	<primitive: 'primitiveSocketListenWithOrWithoutBacklog' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketAbortConnection: socketID
	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."

	<primitive: 'primitiveSocketAbortConnection' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketCloseConnection: socketID
	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."

	<primitive: 'primitiveSocketCloseConnection' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketConnectionStatus: socketID
	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"

	<primitive: 'primitiveSocketConnectionStatus' module: 'SocketPlugin'>
	^ InvalidSocket
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex
	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.
	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.
	The socketType parameter specifies:
		0	reliable stream socket (TCP if the protocol is IP)
		1	unreliable datagram socket (UDP if the protocol is IP)
	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing.
 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."

	<primitive: 'primitiveSocketCreate' module: 'SocketPlugin'>
	^ nil  "socket creation failed"
! !
!Socket methodsFor: 'primitives' stamp: 'ul 4/20/2011 01:56'!
primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema
	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for reading and writing"

	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>
	self primitiveFailed! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketDestroy: socketID
	"Release the resources associated with this socket. If a connection is open, it is aborted."

	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketDestroyGently: socketID
	"Release the resources associated with this socket. If a connection is open, it is aborted.
	Do not fail if the receiver is already closed."

	<primitive: 'primitiveSocketDestroy' module: 'SocketPlugin'>
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketError: socketID
	"Return an integer encoding the most recent error on this socket. Zero means no error."

	<primitive: 'primitiveSocketError' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketLocalAddress: socketID
	"Return the local host address for this socket."

	<primitive: 'primitiveSocketLocalAddress' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketLocalPort: socketID
	"Return the local port for this socket, or zero if no port has yet been assigned."

	<primitive: 'primitiveSocketLocalPort' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 20:13'!
primSocketReceiveDataAvailable: socketID
	"Return true if data may be available for reading from the current socket."

	<primitive: 'primitiveSocketReceiveDataAvailable' module: 'SocketPlugin'>
	self primitiveFailed! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketRemoteAddress: socketID
	"Return the remote host address for this socket, or zero if no connection has been made."

	<primitive: 'primitiveSocketRemoteAddress' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketRemotePort: socketID
	"Return the remote port for this socket, or zero if no connection has been made."

	<primitive: 'primitiveSocketRemotePort' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!
primSocketSendDone: socketID
	"Return true if there is no send in progress on the current socket."

	<primitive: 'primitiveSocketSendDone' module: 'SocketPlugin'>
	self primitiveFailed
! !
!Socket methodsFor: 'primitives' stamp: 'mtf 3/14/2011 19:59' overrides: 50341511!
primitiveFailed: selector
	SocketPrimitiveFailed signal: selector asString, ' failed'! !
!Socket methodsFor: 'printing' stamp: 'jm 11/23/1998 11:57' overrides: 16902975!
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: '[', self statusString, ']'.
! !
!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:54'!
readSemaphore
	
	^readSemaphore! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:52'!
receiveAvailableData
	"Receive all available data (if any). Do not wait."
 
	| buffer bytesRead |
	buffer _ String new: 2000.
	bytesRead _ self receiveAvailableDataInto: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:52'!
receiveAvailableDataInto: buffer
	"Receive all available data into the given buffer and return the number of bytes received.
	Note the given buffer may be only partially filled by the received data.
	Do not wait for data."

	^self receiveAvailableDataInto: buffer startingAt: 1! !
!Socket methodsFor: 'receiving' stamp: 'mu 8/9/2003 18:04'!
receiveAvailableDataInto: buffer startingAt: startIndex
	"Receive all available data into the given buffer and return the number of bytes received.
	Note the given buffer may be only partially filled by the received data.
	Do not wait for data."

	| bufferPos bytesRead |
	bufferPos := startIndex.
	[self dataAvailable
		and: [bufferPos-1 < buffer size]] 
		whileTrue: [
			bytesRead := self receiveSomeDataInto: buffer startingAt: bufferPos.
			bufferPos := bufferPos + bytesRead].
	^bufferPos - startIndex! !
!Socket methodsFor: 'receiving' stamp: 'yo 10/10/2005 18:47'!
receiveAvailableDataIntoBuffer: buffer
	"Receive all available data (if any). Do not wait."
 
	| bytesRead |
	bytesRead := self receiveAvailableDataInto: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:05'!
receiveData
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once.
	Either returns data or signals a time out or connection close."

	| buffer bytesRead |
	buffer _ String new: 2000.
	bytesRead _ self receiveDataInto: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:05'!
receiveDataInto: aStringOrByteArray
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once.
	Either returns data or signals a time out or connection close."

	^self receiveDataInto: aStringOrByteArray startingAt: 1! !
!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:55'!
receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber
	| datagram |
	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."

	[
		datagram := self receiveUDPDataInto: aStringOrByteArray.
		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 
			ifTrue: [^datagram at: 1]
			ifFalse: [^0]] repeat! !
!Socket methodsFor: 'receiving' stamp: 'jmv 2/28/2010 22:35'!
receiveDataInto: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once.  The answer may be zero (indicating that no data was 
	available before the socket closed)."

	| bytesRead closed |
	bytesRead := 0.
	closed := false.
	[closed not and: [bytesRead = 0]]
		whileTrue: [
			self waitForDataIfClosed: [closed := true].
			bytesRead := self primSocket: socketHandle
				receiveDataInto: aStringOrByteArray
				startingAt: aNumber
				count: aStringOrByteArray size-aNumber+1].
	^bytesRead
! !
!Socket methodsFor: 'receiving' stamp: 'jmv 2/28/2010 22:35'!
receiveDataSignallingClosedInto: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data until something is read or the socket is closed, upon which
	we signal."

	| bytesRead |
	bytesRead := 0.
	[bytesRead = 0]
		whileTrue: [
			self waitForData.
			bytesRead := self primSocket: socketHandle
				receiveDataInto: aStringOrByteArray
				startingAt: aNumber
				count: aStringOrByteArray size-aNumber+1].
	^bytesRead
! !
!Socket methodsFor: 'receiving' stamp: 'gk 2/9/2005 12:24'!
receiveDataSignallingTimeout: timeout into: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Wait for data once for the specified nr of seconds.  This method will
	throw exceptions on timeout or the socket closing."

	self waitForDataFor: timeout.
	^self primSocket: socketHandle
		receiveDataInto: aStringOrByteArray
		startingAt: aNumber
		count: aStringOrByteArray size-aNumber+1
! !
!Socket methodsFor: 'receiving' stamp: 'svp 9/23/2003 00:03'!
receiveDataTimeout: timeout
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once."

	| buffer bytesRead |
	buffer _ String new: 2000.
	bytesRead _ self receiveDataTimeout: timeout into: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'svp 9/23/2003 00:01'!
receiveDataTimeout: timeout into: aStringOrByteArray 
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once."

	^self receiveDataTimeout: timeout into: aStringOrByteArray startingAt: 1! !
!Socket methodsFor: 'receiving' stamp: 'jmv 3/2/2010 10:09'!
receiveDataTimeout: timeout into: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Wait for data once for the specified nr of seconds.  The answer may be 
	zero (indicating that there was no data available within the given timeout)."

	self waitForDataFor: timeout ifClosed: nil ifTimedOut: nil.
	^self primSocket: socketHandle
		receiveDataInto: aStringOrByteArray
		startingAt: aNumber
		count: aStringOrByteArray size-aNumber+1! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:18'!
receiveDataWithTimeout
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once.
	Either returns data or signals a time out or connection close."

	| buffer bytesRead |
	buffer _ String new: 2000.
	bytesRead _ self receiveDataWithTimeoutInto: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:18'!
receiveDataWithTimeoutInto: aStringOrByteArray
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once.
	Either returns data or signals a time out or connection close."

	^self receiveDataWithTimeoutInto: aStringOrByteArray startingAt: 1! !
!Socket methodsFor: 'receiving' stamp: 'svp 9/23/2003 00:01'!
receiveDataWithTimeoutInto: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. 
	Note the given buffer may be only partially filled by the received data.
	Waits for data once."

	^self receiveDataTimeout: Socket standardTimeout into: aStringOrByteArray startingAt: aNumber 
! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!
receiveSomeData
	"Receive currently available data (if any). Do not wait."
 
	| buffer bytesRead |
	buffer _ String new: 2000.
	bytesRead _ self receiveSomeDataInto: buffer.
	^buffer copyFrom: 1 to: bytesRead! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!
receiveSomeDataInto: aStringOrByteArray
	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."

	^self receiveSomeDataInto: aStringOrByteArray startingAt: 1! !
!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!
receiveSomeDataInto: aStringOrByteArray startingAt: aNumber
	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."

	^ self primSocket: socketHandle
		receiveDataInto: aStringOrByteArray
		startingAt: aNumber
		count: aStringOrByteArray size-aNumber+1
! !
!Socket methodsFor: 'datagrams' stamp: 'JMM 6/3/2000 21:54'!
receiveUDPDataInto: aStringOrByteArray
	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"

	^ self primSocket: socketHandle
		receiveUDPDataInto: aStringOrByteArray
		startingAt: 1
		count: aStringOrByteArray size
! !
!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:40'!
register
	^self class register: self! !
!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!
remoteAddress

	^ self primSocketRemoteAddress: socketHandle
! !
!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!
remotePort

	^ self primSocketRemotePort: socketHandle
! !
!Socket methodsFor: 'accessing' stamp: 'JMM 5/9/2000 15:32'!
semaphore
	^semaphore! !
!Socket methodsFor: 'sending' stamp: 'mir 5/15/2003 18:33'!
sendData: aStringOrByteArray
	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."

	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."

	| bytesSent bytesToSend count |
	bytesToSend _ aStringOrByteArray size.
	bytesSent _ 0.
	[bytesSent < bytesToSend] whileTrue: [
		(self waitForSendDoneFor: 60)
			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].
		count _ self primSocket: socketHandle
			sendData: aStringOrByteArray
			startIndex: bytesSent + 1
			count: (bytesToSend - bytesSent min: 5000).
		bytesSent _ bytesSent + count].

	^ bytesSent
! !
!Socket methodsFor: 'sending' stamp: 'ar 7/20/1999 17:23'!
sendData: buffer count: n
	"Send the amount of data from the given buffer"
	| sent |
	sent _ 0.
	[sent < n] whileTrue:[
		sent _ sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !
!Socket methodsFor: 'datagrams' stamp: 'ul 4/20/2011 01:53'!
sendData: aStringOrByteArray toHost: hostAddress port: portNumber
	"Send a UDP packet containing the given data to the specified host/port."

	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:33'!
sendDone
	"Return true if the most recent send operation on this socket has completed."

	socketHandle ifNil: [^ false].
	^ self primSocketSendDone: socketHandle
! !
!Socket methodsFor: 'sending' stamp: 'ls 1/5/1999 15:05'!
sendSomeData: aStringOrByteArray
	"Send as much of the given data as possible and answer the number of bytes actually sent."
	"Note: This operation may have to be repeated multiple times to send a large amount of data."

	^ self
		sendSomeData: aStringOrByteArray
		startIndex: 1
		count: aStringOrByteArray size! !
!Socket methodsFor: 'sending' stamp: 'ls 3/3/1999 18:59'!
sendSomeData: aStringOrByteArray startIndex: startIndex
	"Send as much of the given data as possible starting at the given index. Answer the number of bytes actually sent."
	"Note: This operation may have to be repeated multiple times to send a large amount of data."

	^ self
		sendSomeData: aStringOrByteArray
		startIndex: startIndex
		count: (aStringOrByteArray size - startIndex + 1)! !
!Socket methodsFor: 'sending' stamp: 'jmv 8/5/2011 17:38'!
sendSomeData: aStringOrByteArray startIndex: startIndex count: count
	^ self sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: Socket standardTimeout! !
!Socket methodsFor: 'sending' stamp: 'fbs 2/18/2011 08:58'!
sendSomeData: aStringOrByteArray startIndex: startIndex count: count for: aTimeoutInSeconds
	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."
	"Note: This operation may have to be repeated multiple times to send a large amount of data."

	| bytesSent |
	(self waitForSendDoneFor: aTimeoutInSeconds)
		ifTrue: [
			bytesSent := self primSocket: socketHandle
				sendData: aStringOrByteArray
				startIndex: startIndex
				count: count]
		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].
	^ bytesSent
! !
!Socket methodsFor: 'sending' stamp: 'mir 2/19/2002 18:33'!
sendStreamContents: stream
	"Send the data in the stream. Close the stream.
	Usefull for directly sending contents of a file without reading into memory first."

	self sendStreamContents: stream checkBlock: [true]! !
!Socket methodsFor: 'sending' stamp: 'nice 12/26/2009 21:50'!
sendStreamContents: stream checkBlock: checkBlock
	"Send the data in the stream. Close the stream after you are done. After each block of data evaluate checkBlock and abort if it returns false.
	Usefull for directly sending contents of a file without reading into memory first."
	[
	| chunkSize buffer |
	chunkSize := 5000.
	buffer := ByteArray new: chunkSize.
	stream binary.
	[stream atEnd and: [checkBlock value]]
		whileFalse: [
			buffer := stream next: chunkSize into: buffer.
			self sendData: buffer]]
		ensure: [stream close]! !
!Socket methodsFor: 'datagrams' stamp: 'mir 5/15/2003 18:34'!
sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber
	"Send a UDP packet containing the given data to the specified host/port."
	| bytesToSend bytesSent count |

	bytesToSend _ aStringOrByteArray size.
	bytesSent _ 0.
	[bytesSent < bytesToSend] whileTrue: [
		(self waitForSendDoneFor: 20)
			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].
		count _ self primSocket: socketHandle
			sendUDPData: aStringOrByteArray
			toHost: hostAddress
			port: portNumber
			startIndex: bytesSent + 1
			count: bytesToSend - bytesSent.
		bytesSent _ bytesSent + count].

	^ bytesSent
! !
!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:30'!
setOption: aName value: aValue 
	| value |
	"setup options on this socket, see Unix man pages for values for 
	sockets, IP, TCP, UDP. IE SO_KEEPALIVE
	returns an array, element one is the error number
	element two is the resulting of the negotiated value.
	See getOption for list of keys"

	(socketHandle == nil or: [self isValid not])
		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before setting an option'].
	value _ aValue asString.
	aValue == true ifTrue: [value _ '1'].
	aValue == false ifTrue: [value _ '0'].
	^ self primSocket: socketHandle setOption: aName value: value! !
!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!
setPeer: hostAddress port: port
	"Set the default send/recv address."

	self primSocket: socketHandle connectTo: hostAddress port: port.
! !
!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!
setPort: port
	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."

	self primSocket: socketHandle setPort: port.
! !
!Socket methodsFor: 'queries' stamp: 'JMM 5/8/2000 23:24'!
socketError
	^self primSocketError: socketHandle! !
!Socket methodsFor: 'accessing' stamp: 'ar 7/16/1999 17:22'!
socketHandle
	^socketHandle! !
!Socket methodsFor: 'queries' stamp: 'jmv 3/1/2010 13:33'!
statusString
	"Return a string describing the status of this socket."

	| status |
	socketHandle ifNil: [^ 'destroyed'].
	status _ self primSocketConnectionStatus: socketHandle.
	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].
	status = Unconnected ifTrue: [^ 'unconnected'].
	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].
	status = Connected ifTrue: [^ 'connected'].
	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].
	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].
	^ 'unknown socket status'
! !
!Socket methodsFor: 'registry' stamp: 'ar 3/21/98 17:41'!
unregister
	^self class unregister: self! !
!Socket methodsFor: 'waiting' stamp: 'dc 10/21/2008 08:19'!
waitForAcceptFor: timeout
	"Wait and accept an incoming connection. Return nil if it falis"
	self waitForConnectionFor: timeout ifTimedOut: [^ nil].
	^ self isConnected
		ifTrue:[self accept]
		! !
!Socket methodsFor: 'waiting' stamp: 'svp 7/27/2003 00:23'!
waitForAcceptFor: timeout ifTimedOut: timeoutBlock
	"Wait and accept an incoming connection"
	self waitForConnectionFor: timeout ifTimedOut: [^timeoutBlock value].
	^self accept! !
!Socket methodsFor: 'waiting' stamp: 'mu 8/19/2003 02:57'!
waitForConnectionFor: timeout
	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."

	^self 
		waitForConnectionFor: timeout 
		ifTimedOut: [ConnectionTimedOut signal: 'Failed to connect in ', timeout asString, ' seconds']
! !
!Socket methodsFor: 'waiting' stamp: 'jmv 6/11/2014 19:35'!
waitForConnectionFor: timeout ifTimedOut: timeoutBlock
	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."

	| startTime msecsDelta msecsEllapsed status |
	startTime := Time localMillisecondClock.
	msecsDelta := (timeout * 1000) truncated.
	status := self primSocketConnectionStatus: socketHandle.
	[(status = WaitingForConnection) and: [(msecsEllapsed := Time localMillisecondClock - startTime) < msecsDelta]]
		whileTrue: [
			semaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed.
			status := self primSocketConnectionStatus: socketHandle].

	status = Connected ifFalse: [^timeoutBlock value].
	^ true! !
!Socket methodsFor: 'waiting' stamp: 'svp 9/23/2003 00:09'!
waitForData
	"Wait for data to arrive.  This method will block until
	data is available or the socket is closed.  If the socket is closed
	a ConnectionClosed exception will be signaled."

	^self waitForDataIfClosed:
		[ConnectionClosed signal: 'Connection close while waiting for data.']! !
!Socket methodsFor: 'waiting' stamp: 'svp 7/27/2003 00:18'!
waitForDataFor: timeout
	"Wait for the given nr of seconds for data to arrive.
	Signal a time out or connection close exception if either happens before data becomes available."

	^self
		waitForDataFor: timeout
		ifClosed: [ConnectionClosed signal: 'Connection closed while waiting for data.']
		ifTimedOut: [ConnectionTimedOut signal: 'Data receive timed out.']
! !
!Socket methodsFor: 'waiting' stamp: 'jmv 6/11/2014 19:35'!
waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock
	"Wait for the given nr of seconds for data to arrive."
	
	| startTime msecsDelta |
	startTime := Time localMillisecondClock.
	msecsDelta := (timeout * 1000) truncated.
	[(Time localMillisecondClock - startTime) < msecsDelta] whileTrue: [
		(self primSocketReceiveDataAvailable: socketHandle)
			ifTrue: [^self].
		self isConnected
			ifFalse: [^closedBlock value].
		self readSemaphore waitTimeoutMSecs: 
			(msecsDelta - (Time localMillisecondClock - startTime) max: 0).
	].

	(self primSocketReceiveDataAvailable: socketHandle)
		ifFalse: [
			self isConnected
				ifTrue: [^timedOutBlock value]
				ifFalse: [^closedBlock value]].! !
!Socket methodsFor: 'waiting' stamp: 'ul 6/17/2011 12:43'!
waitForDataIfClosed: closedBlock
	"Wait indefinitely for data to arrive.  This method will block until
	data is available or the socket is closed."

	[
		(self primSocketReceiveDataAvailable: socketHandle)
			ifTrue: [^self].
		self isConnected
			ifFalse: [^closedBlock value].
		self readSemaphore wait ] repeat
! !
!Socket methodsFor: 'waiting' stamp: 'jmv 6/11/2014 19:36'!
waitForDisconnectionFor: timeout
	"Wait for the given nr of seconds for the connection to be broken.
	Return true if it is broken by the deadline, false if not.
	The client should know the connection is really going to be closed
	(e.g., because he has called 'close' to send a close request to the other end)
	before calling this method."

	| startTime msecsDelta status |
	startTime := Time localMillisecondClock.
	msecsDelta := (timeout * 1000) truncated.
	status := self primSocketConnectionStatus: socketHandle.
	[((status == Connected) or: [(status == ThisEndClosed)]) and:
	 [(Time localMillisecondClock - startTime) < msecsDelta]] whileTrue: [
		self discardReceivedData.
		self readSemaphore waitTimeoutMSecs: 
			(msecsDelta - (Time localMillisecondClock - startTime) max: 0).
		status := self primSocketConnectionStatus: socketHandle].
	^ status ~= Connected! !
!Socket methodsFor: 'waiting' stamp: 'jmv 6/11/2014 19:36'!
waitForSendDoneFor: timeout
	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."

	| startTime msecsDelta msecsEllapsed sendDone |
	startTime := Time localMillisecondClock.
	msecsDelta := (timeout * 1000) truncated.
	[(sendDone := self primSocketSendDone: socketHandle) not and: [ self isConnected
			"Connection end and final data can happen fast, so test in this order"
		and: [(msecsEllapsed := Time localMillisecondClock - startTime) < msecsDelta]]] whileTrue: [
			self writeSemaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed].

	^ sendDone! !
!Socket methodsFor: 'accessing' stamp: 'ul 4/20/2011 01:56'!
writeSemaphore
	
	^writeSemaphore! !
!Socket class methodsFor: 'instance creation' stamp: 'ls 9/24/1999 09:45'!
acceptFrom: aSocket
	^[ super new acceptFrom: aSocket ]
		repeatWithGCIf: [ :sock | sock isValid not ]! !
!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:15'!
createIfFail: failBlock
	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."
	"Note: The default creates a TCP socket"
	^self tcpCreateIfFail: failBlock! !
!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:54'!
deadServer

	^ DeadServer! !
!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:56'!
deadServer: aStringOrNil
	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."

	DeadServer _ aStringOrNil! !
!Socket class methodsFor: 'class initialization' stamp: 'ar 12/12/2001 19:12' overrides: 16904184!
initialize
	"Socket initialize"

	"Socket Types"
	TCPSocketType _ 0.
	UDPSocketType _ 1.

	"Socket Status Values"
	InvalidSocket _ -1.
	Unconnected _ 0.
	WaitingForConnection _ 1.
	Connected _ 2.
	OtherEndClosed _ 3.
	ThisEndClosed _ 4.

	RegistryThreshold _ 100. "# of sockets"! !
!Socket class methodsFor: 'network initialization' stamp: 'jm 9/15/97 09:30'!
initializeNetwork
	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."
	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "

	NetNameResolver initializeNetwork.
! !
!Socket class methodsFor: 'tests' stamp: 'jmv 3/13/2012 12:51'!
loopbackTest
	"Send data from one socket to another on the local machine.
	Tests most of the socket primitives."

	"100 timesRepeat: [Socket loopbackTest]"

	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |
	Transcript
		newLine;
		show: 'starting loopback test';
		newLine.
	Transcript
		show: '---------- Connecting ----------';
		newLine.
	self initializeNetwork.
	sock1 := self new.
	sock2 := self new.
	sock1 listenOn: 54321.
	sock2 connectTo: NetNameResolver localHostAddress port: 54321.
	sock1 waitForConnectionFor: self standardTimeout.
	sock2 waitForConnectionFor: self standardTimeout.
	sock1 isConnected ifFalse: [self error: 'sock1 not connected'].
	sock2 isConnected ifFalse: [self error: 'sock2 not connected'].
	Transcript
		show: 'connection established';
		newLine.
	bytesToSend := 5000000.
	sendBuf := String new: 5000 withAll: $x.
	receiveBuf := String new: 50000.
	done := false.
	packetsSent := packetsRead := bytesSent := bytesReceived := 0.
	t := Time millisecondsToRun: 
					[[done] whileFalse: 
							[(sock1 sendDone and: [bytesSent < bytesToSend]) 
								ifTrue: 
									[packetsSent := packetsSent + 1.
									bytesSent := bytesSent + (sock1 sendSomeData: sendBuf)].
							sock2 dataAvailable 
								ifTrue: 
									[packetsRead := packetsRead + 1.
									bytesReceived := bytesReceived + (sock2 receiveDataInto: receiveBuf)].
							done := bytesSent >= bytesToSend and: [bytesReceived = bytesSent]]].
	Transcript
		show: 'closing connection';
		newLine.
	sock1 waitForSendDoneFor: self standardTimeout.
	sock1 close.
	sock2 waitForDisconnectionFor: self standardTimeout.
	extraBytes := sock2 discardReceivedData.
	extraBytes > 0 
		ifTrue: [
			Transcript
				show: ' *** received ' , extraBytes size printString , ' extra bytes ***';
				newLine].
	sock2 close.
	sock1 waitForDisconnectionFor: self standardTimeout.
	sock1 isUnconnectedOrInvalid ifFalse: [self error: 'sock1 not closed'].
	sock2 isUnconnectedOrInvalid ifFalse: [self error: 'sock2 not closed'].
	Transcript
		show: '---------- Connection Closed ----------';
		newLine.
	sock1 destroy.
	sock2 destroy.
	Transcript
		show: 'loopback test done; time = ' , t printString;
		newLine.
	Transcript
		show: (bytesToSend asFloat / t roundTo: 0.01) printString 
					, '* 1000 bytes/sec';
		newLine.
	Transcript endEntry! !
!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!
nameForWellKnownTCPPort: portNum
	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."

	| portList entry |
	portList _ #(
		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')
		(21 'ftp') (23 'telnet') (25 'smtp')
		(80 'http') (110 'pop3') (119 'nntp')).
	entry _ portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].
	^ entry last
! !
!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13' overrides: 16785646!
new
	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."
	"Note: The default creates a TCP socket - this is also backward compatibility."
	^self newTCP! !
!Socket class methodsFor: 'tests' stamp: 'gk 12/15/2005 01:03'!
newAcceptCheck
	"Check if the platform has support for the BSD style accept()."

	"Socket newAcceptCheck"
	
	| socket |
	self initializeNetwork.
	socket := self newTCP.
	socket listenOn: 44444 backlogSize: 4.
	socket isValid ifTrue: [
		self inform: 'Everything looks OK for the BSD style accept()'
	] ifFalse: [
		self inform: 'It appears that you DO NOT have support for the BSD style accept()'].
	socket destroy! !
!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:48'!
newTCP
	"Create a socket and initialise it for TCP"
	self initializeNetwork.
	^[ super new initialize: TCPSocketType ]
		repeatWithGCIf: [ :socket | socket isValid not ]! !
!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!
newUDP
	"Create a socket and initialise it for UDP"
	self initializeNetwork.
	^[ super new initialize: UDPSocketType ]
		repeatWithGCIf: [ :socket | socket isValid not ]! !
!Socket class methodsFor: 'utilities' stamp: 'jmv 6/11/2014 19:36'!
ping: hostName
	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."
	"Socket ping: 'squeak.cs.uiuc.edu'"

	| tcpPort sock serverAddr startTime echoTime |
	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"

	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.
	serverAddr ifNil: [
		^ self inform: 'Could not find an address for ', hostName].

	sock _ Socket new.
	sock connectNonBlockingTo: serverAddr port: tcpPort.
	[sock waitForConnectionFor: 10]
		on: ConnectionTimedOut
		do: [:ex |
			(self confirm: 'Continue to wait for connection to ', hostName, '?')
				ifTrue: [ex retry]
				ifFalse: [
					sock destroy.
					^ self]].

	sock sendData: 'echo!!'.
	startTime _ Time localMillisecondClock.
	[sock waitForDataFor: 15]
		on: ConnectionTimedOut
		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')
			ifTrue: [ex retry]].
	echoTime _ Time localMillisecondClock - startTime.

	sock destroy.
	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.
! !
!Socket class methodsFor: 'utilities' stamp: 'jmv 6/11/2014 19:37'!
pingPorts: portList on: hostName timeOutSecs: timeOutSecs
	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."

	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.org' timeOutSecs: 15"

	| serverAddr sockets startTime timeoutMsecs done result unconnectedCount connectedCount waitingCount |
	serverAddr := NetNameResolver addressForName: hostName timeout: 10.
	serverAddr ifNil: [ 
			self inform: 'Could not find an address for ' , hostName.
			^ #() ].
	sockets := portList
		collect: [ :portNum | 
			| sock |
			sock := Socket new.
			[ sock connectTo: serverAddr port: portNum ] 
				on: ConnectionTimedOut
				do: [ ].
			sock ].
	startTime := Time localMillisecondClock.
	timeoutMsecs := (1000 * timeOutSecs) truncated.
	done := false.
	[ done ]
		whileFalse: [ 
			unconnectedCount := 0.
			connectedCount := 0.
			waitingCount := 0.
			sockets
				do: [ :s | 
					s isUnconnectedOrInvalid
						ifTrue: [ unconnectedCount := unconnectedCount + 1 ]
						ifFalse: [ 
							s isConnected
								ifTrue: [ connectedCount := connectedCount + 1 ].
							s isWaitingForConnection
								ifTrue: [ waitingCount := waitingCount + 1 ] ] ].
			waitingCount = 0
				ifTrue: [ done := true ].
			connectedCount = sockets size
				ifTrue: [ done := true ].
			(Time localMillisecondClock - startTime) >= timeoutMsecs
				ifTrue: [ done := true ] ].
	result := (sockets select: [ :s | s isConnected ]) collect: [ :s | self nameForWellKnownTCPPort: s remotePort ].
	sockets do: [ :s | s destroy ].
	^ result! !
!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:25'!
pingPortsOn: hostName
	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."
	"Socket pingPortsOn: 'www.disney.com'"

	^ Socket
		pingPorts: #(7 13 19 21 23 25 80 110 119)
		on: hostName
		timeOutSecs: 20
! !
!Socket class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 14:59'!
primInitializeNetwork: resolverSemaIndex
	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the receiver if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."
	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."

	<primitive: 'primitiveInitializeNetwork' module: 'SocketPlugin'>
	^ nil  "return nil if primitive fails"
! !
!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!
register: anObject
	
	^self registry add: anObject! !
!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!
registry

	^Registry ifNil: [ Registry := WeakRegistry new ]! !
!Socket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!
registryThreshold
	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."
	^RegistryThreshold! !
!Socket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!
registryThreshold: aNumber
	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."
	RegistryThreshold _ aNumber! !
!Socket class methodsFor: 'tests' stamp: 'jmv 9/24/2012 19:47'!
sendTest
	"Send data to the 'discard' socket of the given host.
	Tests the speed of one-way data transfers across the
	network to the given host. Note that most hosts
	do not run a discard server."

	"Socket sendTest"

	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |
	Transcript newLine; show: 'starting send test'; newLine.
	self initializeNetwork.
	serverName := FillInTheBlankMorph request: 'What is the destination server?' initialAnswer: 'create.ucsb.edu'.
	serverAddr := NetNameResolver addressForName: serverName timeout: 10.
	serverAddr ifNil: [
		^self inform: 'Could not find an address for ' , serverName].
	sock := self new.
	Transcript show: '---------- Connecting ----------';newLine.
	sock connectTo: serverAddr port: 9.
	sock isConnected ifFalse: [
		sock destroy.
		^self inform: 'could not connect'].
	Transcript show: 'connection established; sending data'; newLine.
	bytesToSend := 1000000.
	sendBuf := String new: 64 * 1024 withAll: $x.
	bytesSent := 0.
	t := Time millisecondsToRun: 
					[[bytesSent < bytesToSend] whileTrue: 
							[sock sendDone 
								ifTrue: [bytesSent := bytesSent + (sock sendSomeData: sendBuf)]]].
	sock waitForSendDoneFor: self standardTimeout.
	sock destroy.
	Transcript show: '---------- Connection Closed ----------'; newLine;
		show: 'send test done; time = ' , t printString; newLine;
		show: (bytesToSend asFloat / t roundTo: 0.01) printString, ' * 1000 bytes/sec'; newLine; endEntry! !
!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 16:17'!
standardDeadline
	"Return a default deadline time some seconds into the future."

	^ self deadlineSecs: self standardTimeout
! !
!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 16:16'!
standardTimeout

	^45
! !
!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!
tcpCreateIfFail: failBlock
	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."

	| sock |
	self initializeNetwork.
	sock _ super new initialize: TCPSocketType.
	sock isValid ifFalse: [^ failBlock value].
	^ sock
! !
!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!
udpCreateIfFail: failBlock
	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."

	| sock |
	self initializeNetwork.
	sock _ super new initialize: UDPSocketType.
	sock isValid ifFalse: [^ failBlock value].
	^ sock
! !
!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24'!
unregister: anObject
	
	^self registry remove: anObject ifAbsent: nil! !
!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!
wildcardAddress
	"Answer a don't-care address for use with UDP sockets."

	^ByteArray new: 4		"0.0.0.0"! !
!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!
wildcardPort
	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an
	unused port number to the socket.)"

	^0! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:44'!
adjustInBuffer: bytesRead
	"Adjust markers and possibly grow inBuffer or move data down.
	Currently grows through doubling when less than 1024 bytes are left.
	Never shrinks. Returns the position in the buffer where any new
	data can be found."

	| old |
	bytesRead = 0 ifTrue: [^inNextToWrite].
	old := inNextToWrite.
	inNextToWrite := inNextToWrite + bytesRead.
	(inBuffer size - inNextToWrite) < 1024
		ifTrue: [
			"Hit the roof, move data down (if enough has been read) or do we grow?"
			(lastRead > 512)
				ifTrue: [^old - self moveInBufferDown]
				ifFalse: [self growInBuffer]].
	^old! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:42'!
adjustOutBuffer: bytesToWrite
	"Possibly grow outBuffer to accommodate the new data.
	Currently grows through doubling when less
	than 1024 bytes are left. If bytesToWrite is even
	larger we double that instead. Never shrinks."

	(outBuffer size - outNextToWrite - bytesToWrite) < 1024 ifTrue: [
		outBuffer := (self streamBuffer: ((outBuffer size max: bytesToWrite) * 2))
						replaceFrom: 1 to: outBuffer size with: outBuffer startingAt: 1]! !
!SocketStream methodsFor: 'configuration' stamp: 'nice 3/16/2010 22:34'!
ascii
	"Tell the SocketStream to send data
	as Strings instead of ByteArrays.
	This is default."

	binary := false.
	inBuffer
		ifNil: [self resetBuffers]
		ifNotNil:
			[inBuffer := inBuffer asString.
			outBuffer := outBuffer asString]! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/25/2005 14:23'!
atEnd
	"There is nothing more to read when
	there is no more data in our inBuffer, the socket
	is disconnected and there is none available on the socket.
	Note that we need to check isConnected before isDataAvailable,
	otherwise data may sneak in in the meantime. But we check the
	buffer first, because it is faster."

	self isInBufferEmpty ifFalse: [^false].
	^self isConnected not
		and: [self isDataAvailable not]! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/9/2005 22:26'!
autoFlush
	"If autoFlush is enabled data will be sent through
	the socket (flushed) when the bufferSize is reached
	or the SocketStream is closed. Otherwise the user
	will have to send #flush manually.
	Close will always flush. Default is false."

	^autoFlush! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/9/2005 22:27'!
autoFlush: aBoolean
	"If autoFlush is enabled data will be sent through
	the socket (flushed) when the bufferSize is reached
	or the SocketStream is closed. Otherwise the user
	will have to send #flush manually.
	Close will always flush. Default is false."

	autoFlush := aBoolean! !
!SocketStream methodsFor: 'private' stamp: 'ar 11/22/2010 23:48'!
beSignalingWhile: aBlock
	"Temporarily turn a non-signaling SocketStream into a signaling one.
	Required for some of operations that will catch ConnectionClosed in 
	order to find out that an operation completed"

	| signaling |
	signaling := shouldSignal.
	shouldSignal := true.
	^aBlock ensure:[shouldSignal := signaling]
! !
!SocketStream methodsFor: 'configuration' stamp: 'nice 3/16/2010 22:35'!
binary
	"Tell the SocketStream to send data
	as ByteArrays instead of Strings.
	Default is ascii."

	binary := true.
	inBuffer
		ifNil: [self resetBuffers]
		ifNotNil:
			[inBuffer := inBuffer asByteArray.
			outBuffer := outBuffer asByteArray]! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/9/2005 22:28'!
bufferSize
	"Default buffer size is 4kb.
	increased from earlier 2000 bytes."
	
	^bufferSize! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/9/2005 22:28'!
bufferSize: anInt
	"Default buffer size is 4kb.
	increased from earlier 2000 bytes."

	bufferSize := anInt! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/7/2005 13:09'!
checkFlush
	"If autoFlush is true we flush if
	we have reached the bufferSize
	of data in the outBuffer."

	(autoFlush and: [outNextToWrite > bufferSize])
		ifTrue: [self flush]! !
!SocketStream methodsFor: 'control' stamp: 'gk 2/24/2005 11:55'!
close
	"Flush any data still not sent
	and take care of the socket."

	self flush.
	socket closeAndDestroy: 30! !
!SocketStream methodsFor: 'stream out' stamp: 'jmv 5/27/2013 11:02'!
crlf
	self nextPutAll: String crlfString! !
!SocketStream methodsFor: 'printing' stamp: 'jmv 3/13/2012 12:47'!
debug
	"Display debug info."

	| data |
	data := self inBufferSize.
	^String streamContents: [:s |
		s
			nextPutAll: 'Buffer size: ', inBuffer size asString; newLine;
			nextPutAll: 'InBuffer data size: ', data asString; newLine;
			nextPutAll: 'In data (20):', (inBuffer copyFrom: lastRead + 1 to: lastRead + (data min: 20)); newLine;
			nextPutAll: 'OutBuffer data size: ', (outNextToWrite - 1) asString; newLine;
			nextPutAll: 'Out data (20):', (outBuffer copyFrom: 1 to: ((outNextToWrite - 1) min: 20)); newLine]! !
!SocketStream methodsFor: 'initialization' stamp: 'ar 7/24/2010 15:13'!
destroy
	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."

	socket ifNotNil:[socket destroy]! !
!SocketStream methodsFor: 'control' stamp: 'cmm 1/28/2011 15:15'!
flush
	"If the other end is connected and we have something
	to send, then we send it and reset the outBuffer."
	(outNextToWrite > 1 and: [ socket isOtherEndClosed not ]) ifTrue:
		[ [ self
			sendData: outBuffer
			count: outNextToWrite - 1 ]
			on: ConnectionTimedOut
			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ].
		outNextToWrite := 1 ]! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/7/2005 23:05'!
growInBuffer
	"Grows through doubling."

	self resizeInBuffer: inBuffer size * 2! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 17:58'!
inBufferSize
	"Answers the current size of data in the inBuffer."

	^inNextToWrite - lastRead - 1! !
!SocketStream methodsFor: 'initialization' stamp: 'gk 2/25/2005 14:20' overrides: 16920235!
initialize
	autoFlush := true.
	shouldSignal := true.
	recentlyRead := 0.
	bufferSize := 4096.
	self ascii! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/3/2005 20:35'!
isBinary
	^binary! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/7/2005 12:24'!
isConnected
	"The stream is connected if the socket is."

	^socket isConnected! !
!SocketStream methodsFor: 'testing' stamp: 'ar 11/23/2010 00:04'!
isDataAvailable
	"Answer if more data can be read. It the inbuffer is empty, we read more data.

	Note: It is important not to rely on 'socket dataAvailable' here since this will
	not work for subclasses such as SecureSocketStream (which can contain
	undecrypted contents that has been read from the socket)."
 
	self isInBufferEmpty ifFalse: [^true].
	^self receiveAvailableData < inNextToWrite
! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/7/2005 13:02'!
isEmpty
	"Test if there are more data to read."

	^self isInBufferEmpty and: [self isDataAvailable not]! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/7/2005 13:02'!
isInBufferEmpty
	"Any data in the buffer?"
 
	^lastRead + 1 = inNextToWrite! !
!SocketStream methodsFor: 'testing' stamp: 'gk 2/7/2005 08:59'!
isOtherEndConnected
	^socket isOtherEndClosed not! !
!SocketStream methodsFor: 'private' stamp: 'jmv 8/18/2009 10:30'!
moveInBufferDown
	"Move down contents of inBuffer to the start.
	Return distance moved."
	"
	jmv - Horrible hack.
	To support the nasty #pushBack: as needed by the silly XMLTokenizer, do not go to the start, but leave
	slack bytes of already read stuff.
	"

	| sz distanceMoved slack |
	
	slack _ 16.
	
	sz := inNextToWrite - lastRead - 1.
	inBuffer replaceFrom: 1+slack to: sz+slack with: inBuffer startingAt: lastRead + 1.
	distanceMoved := lastRead.
	lastRead := 0+slack.
	inNextToWrite := sz + 1+slack.
	^distanceMoved
! !
!SocketStream methodsFor: 'stream out' stamp: 'jmv 3/14/2012 09:13'!
newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPutAll: String newLineString! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 13:33'!
next
	"Return next byte, if inBuffer is empty
	we recieve some more data and try again."

	self atEnd ifTrue: [^nil].
	self isInBufferEmpty ifTrue:
		[self receiveData.
		self atEnd ifTrue: [^nil]].
	lastRead := lastRead + 1.
	^inBuffer at: lastRead! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:17'!
next: anInteger
	"Answer anInteger bytes of data.

	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"

	| start |
	self receiveData: anInteger.
	start := lastRead + 1.
	lastRead := (lastRead + anInteger) min: inNextToWrite - 1.
	^inBuffer copyFrom: start to: lastRead! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 2/23/2010 13:06'!
next: n into: aCollection
	"Read n objects into the given collection.
	Return aCollection or a partial copy if less than
	n elements have been read."
	^self next: n into: aCollection startingAt: 1! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:50'!
next: anInteger into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."

	"Implementation note: This method DOES signal timeout if not 
	enough elements are received. It does NOT signal
	ConnectionClosed as closing the connection is the only way by
	which partial data can be read."

	| start amount |

	[self beSignalingWhile:[self receiveData: anInteger]] 
		on: ConnectionClosed do:[:ex| ex return].

	"Inlined version of nextInBuffer: to avoid copying the contents"
	amount := anInteger min: (inNextToWrite - lastRead - 1).
	start := lastRead + 1.
	lastRead := lastRead + amount.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex + amount-1 
		with: inBuffer 
		startingAt: start.
	^amount < anInteger 
		ifTrue:[aCollection copyFrom: 1 to:  startIndex + amount-1]
		ifFalse:[aCollection]! !
!SocketStream methodsFor: 'stream out' stamp: 'nice 3/17/2010 20:27'!
next: n putAll: aCollection startingAt: startIndex
	"Put a String or a ByteArray onto the stream.
	Currently a large collection will allocate a large buffer.
	Warning: this does not work with WideString: they have to be converted first."

	self adjustOutBuffer: n.
	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + n - 1 with: aCollection startingAt: startIndex.
	outNextToWrite := outNextToWrite + n.
	self checkFlush.
	^aCollection! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 21:26'!
nextAllInBuffer
	"Return all data currently in the inBuffer,"

	^self nextInBuffer: inNextToWrite - lastRead - 1! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 13:47'!
nextAvailable
	"Answer all the data currently available,
	in buffer or in socket."

	self isInBufferEmpty ifFalse: [^self nextAllInBuffer].
	self isDataAvailable ifTrue: [self receiveData].
	^self nextAllInBuffer! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 13:02'!
nextAvailable: howMany
	"Answer all the data currently available,
	in buffer or in socket - but limited to <howMany>."

	self isInBufferEmpty ifFalse: [^self nextInBuffer: howMany].
	self isDataAvailable ifTrue: [self receiveData].
	^self nextInBuffer: howMany! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 12:51'!
nextInBuffer: anInteger
	"Answer anInteger bytes of data at most,
	but only from the inBuffer."

	| start amount |
	amount := anInteger min: (inNextToWrite - lastRead - 1).
	start := lastRead + 1.
	lastRead := lastRead + amount.
	^inBuffer copyFrom: start to: lastRead! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 2/23/2010 13:06'!
nextInto: aCollection
	"Read the next elements of the receiver into aCollection.
	Return aCollection or a partial copy if less than aCollection
	size elements have been read."
	^self next: aCollection size into: aCollection startingAt: 1.! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 2/23/2010 13:06'!
nextInto: aCollection startingAt: startIndex
	"Read the next elements of the receiver into aCollection.
	Return aCollection or a partial copy if less than aCollection
	size elements have been read."
	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !
!SocketStream methodsFor: 'stream in' stamp: 'mir 2/21/2002 18:46'!
nextLine
	^self nextLineCrLf! !
!SocketStream methodsFor: 'stream in' stamp: 'jmv 3/13/2012 11:46'!
nextLineCrLf
	^self upToAll: String crlfString! !
!SocketStream methodsFor: 'stream in' stamp: 'jmv 3/13/2012 11:55'!
nextLineLf

	^self upToAll: String lfString! !
!SocketStream methodsFor: 'stream out' stamp: 'md 2/24/2006 19:51'!
nextPut: char
	"Put a single Character or byte onto the stream."

	| toPut |
	toPut := binary ifTrue: [char asInteger] ifFalse: [char asCharacter].
	self adjustOutBuffer: 1.
	outBuffer at: outNextToWrite put: toPut.
	outNextToWrite := outNextToWrite + 1.
	self checkFlush.
	"return the argument - added by kwl"
	^ char! !
!SocketStream methodsFor: 'stream out' stamp: 'nice 3/19/2010 19:14'!
nextPutAll: aCollection
	"Put a String or a ByteArray onto the stream.
	Currently a large collection will allocate a large buffer."

	| toPut |
	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].
	self adjustOutBuffer: toPut size.
	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + toPut size - 1 with: toPut startingAt: 1.
	outNextToWrite := outNextToWrite + toPut size.
	self checkFlush.
	^aCollection! !
!SocketStream methodsFor: 'stream out' stamp: 'cmm 1/28/2011 15:15'!
nextPutAllFlush: aCollection 
	"Put a String or a ByteArray onto the stream.
	You can use this if you have very large data - it avoids
	copying into the buffer (and avoids buffer growing)
	and also flushes any other pending data first."
	| toPut |
	toPut := binary
		ifTrue: [ aCollection asByteArray ]
		ifFalse: [ aCollection asString ].
	self flush.
	"first flush pending stuff, then directly send"
	socket isOtherEndClosed ifFalse:
		[ [ self
			sendData: toPut
			count: toPut size ]
			on: ConnectionTimedOut
			do: [ : ex | shouldSignal ifTrue: [ ex pass ] ] ]! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 17:59'!
noTimeout
	"Do not use timeout."

	timeout := 0! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 17:59'!
outBufferSize
	"Answers the current size of data in the outBuffer."

	^outNextToWrite - 1! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 1/13/2010 22:30'!
peek
	"Return next byte, if inBuffer is empty
	we recieve some more data and try again.
	Do not consume the byte."

	self atEnd ifTrue: [^nil].
	self isInBufferEmpty ifTrue:
		[self receiveData.
		self atEnd ifTrue: [^nil]].
	^inBuffer at: lastRead+1! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:16'!
peek: anInteger
	"Answer anInteger bytes of data.
	Do not consume data.

	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"

	| start |
	self receiveData: anInteger.
	start := lastRead + 1.
	^inBuffer copyFrom: start to: ((lastRead + anInteger) min: inNextToWrite - 1).! !
!SocketStream methodsFor: 'stream in' stamp: 'jmv 2/9/2010 10:42'!
peekFor: aCharacterOrByte
	"Read and return next character or byte
	if it is equal to the argument.
	Otherwise return false."

	| nextObject |
	self atEnd ifTrue: [^false].
	self isInBufferEmpty ifTrue: 
		[self receiveData.
		self atEnd ifTrue: [^false]].
	nextObject := inBuffer at: lastRead + 1.
	nextObject = aCharacterOrByte ifTrue: [
		lastRead := lastRead + 1.
		^true].
	^false
! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:16'!
peekForAll: aString
	"Answer whether or not the next string of characters in the receiver
	matches aString. If a match is made, advance over that string in the receiver and
	answer true. If no match, then leave the receiver alone and answer false.
	We use findString:startingAt: to avoid copying.

	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"

	| sz start |
	sz := aString size.
	self receiveData: sz.
	(inNextToWrite - lastRead - 1) < sz ifTrue: [^false].
	start := lastRead + 1.
	(inBuffer findString: aString startingAt: start) = start
		ifFalse: [^false].
	lastRead := lastRead + sz.
	^true! !
!SocketStream methodsFor: 'printing' stamp: 'md 7/14/2006 12:28'!
print: anObject
	anObject printOn: self! !
!SocketStream methodsFor: 'printing' stamp: 'gk 2/10/2005 11:44' overrides: 16902975!
printOn: aStream
	"Display buffer sizes."

	aStream nextPutAll: self class name.
	inBuffer ifNotNil: [
		aStream nextPutAll: '[inbuf:',
		(inBuffer size / 1024) rounded asString, 'kb/outbuf:',
		(outBuffer size / 1024) rounded asString, 'kb]']! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:52'!
readInto: aCollection startingAt: startIndex count: anInteger
	"Read n objects into the given collection starting at startIndex. 
	Return number of elements that have been read."

	"Implementation note: This method DOES signal timeout if not 
	enough elements are received. It does NOT signal
	ConnectionClosed as closing the connection is the only way by
	which partial data can be read."

	| start amount |

	[self beSignalingWhile:[self receiveData: anInteger]]
		on: ConnectionClosed do:[:ex| ex return].

	"Inlined version of nextInBuffer: to avoid copying the contents"
	amount := anInteger min: (inNextToWrite - lastRead - 1).
	start := lastRead + 1.
	lastRead := lastRead + amount.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex + amount-1 
		with: inBuffer 
		startingAt: start.
	^amount! !
!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!
receiveAvailableData
	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."
	
	recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.
	^self adjustInBuffer: recentlyRead! !
!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:15'!
receiveData
	self waitForData.
	^self receiveAvailableData! !
!SocketStream methodsFor: 'control' stamp: 'gk 4/14/2005 09:49'!
receiveData: nBytes
	"Keep reading the socket until we have nBytes
	in the inBuffer or we reach the end. This method
	does not return data, but can be used to make sure
	data has been read into the buffer from the Socket
	before actually reading it from the FastSocketStream.
	Mainly used internally. We could also adjust the buffer
	to the expected amount of data and avoiding several
	incremental grow operations.

	NOTE: This method doesn't honor timeouts if shouldSignal
	is false!! And frankly, I am not sure how to handle that
	case or if I care - I think we should always signal."

	[self atEnd not and: [nBytes > self inBufferSize]]
		whileTrue: [self receiveData]! !
!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!
receiveDataIfAvailable
	"Deprecated. Use #receiveAvailableData instead"

	^self receiveAvailableData! !
!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!
receiveDataInto: buffer startingAt: index.
	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."

	^socket  receiveAvailableDataInto: buffer startingAt: index.! !
!SocketStream methodsFor: 'control' stamp: 'gk 2/9/2005 23:08'!
recentlyRead
	"Return the number of bytes read
	during the last socket operation."
	
	^recentlyRead! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:36'!
resetBuffers
	"Recreate the buffers with default start sizes."

	inBuffer := self streamBuffer: bufferSize.
	lastRead := 0.
	inNextToWrite := 1.
	outBuffer := self streamBuffer: bufferSize.
	outNextToWrite := 1! !
!SocketStream methodsFor: 'private' stamp: 'gk 9/9/2005 02:29'!
resizeInBuffer: newSize
	"Resize the inBuffer by recreating it.
	This also has the effect of getting rid of
	dead data above inNextToWrite.
	<newSize> must >= inBuffer size!!"

	inBuffer := (self streamBuffer: newSize)
					replaceFrom: 1 to: inNextToWrite - 1 with: inBuffer startingAt: 1! !
!SocketStream methodsFor: 'stream out' stamp: 'jmv 3/13/2012 11:46'!
sendCommand: aString
	"Sends a String ending it with CR LF and then flush
	causing it to block until sent."

	self nextPutAll: aString, String crlfString; flush! !
!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!
sendData: buffer count: n
	"Sends outgoing data directly on the underlying socket."

	^socket sendData: buffer count: n! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 18:00'!
shouldSignal
	"If shouldSignal is enabled the Socket Exceptions
	ConnectionClosed and ConnectionTimedOut
	will not be swallowed. Default is true.
	For more info, see #shouldSignal:"

	^shouldSignal! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 18:03'!
shouldSignal: aBoolean
	"If shouldSignal is enabled the Socket Exceptions
	ConnectionClosed and ConnectionTimedOut will not be swallowed.
	Default is true. And please - don't set it to false - it is better to
	use an exception handler (see below)  and several methods
	in this class will not honour timeouts (says so in their method comments).
	Also, it is quite hard to understand what for example #upToEnd
	should return to indicate a timeout.
	
	Wrap your use of SocketStream with a handler like:
	
	[stuff := mySocketStream next: 10]
		on: ConnectionClosed, ConnectionTimedOut
		do: [:ex |
			Transcript show: 'Oops!! Did not get my ten bytes!!;cr]
	"

	shouldSignal := aBoolean! !
!SocketStream methodsFor: 'testing' stamp: 'dvf 6/11/2003 18:21'!
shouldTimeout
	^self timeout > 0! !
!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:09'!
signalClosed
	self shouldSignal ifFalse: [^ self]. 
	ConnectionClosed signal: 'Connection closed while waiting for data.'! !
!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:10'!
signalTimeout
	self shouldSignal ifFalse: [^ self]. 
	ConnectionTimedOut signal: 'Data receive timed out.'! !
!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:15'!
skip: anInteger
	"Skip a number of bytes.
	This is faster than #next: since it does not
	have to copy and return a new String or ByteArray.

	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"

	self receiveData: anInteger.
	lastRead := (lastRead + anInteger) min: inNextToWrite - 1! !
!SocketStream methodsFor: 'accessing' stamp: 'mir 10/31/2000 12:50'!
socket
	^socket! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/3/2005 20:35'!
socket: aSocket
	socket := aSocket! !
!SocketStream methodsFor: 'stream out' stamp: 'mir 5/8/2003 18:23'!
space
	self nextPut: Character space! !
!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:35'!
streamBuffer: size
	"Create a buffer of the correct class and given size."

	^(self isBinary
		ifTrue: [ByteArray]
		ifFalse: [String]) new: size! !
!SocketStream methodsFor: 'configuration' stamp: 'gk 2/7/2005 08:41'!
timeout
	"Lazily initialized unless it has been set explicitly."

	timeout ifNil: [timeout := Socket standardTimeout].
	^timeout! !
!SocketStream methodsFor: 'accessing' stamp: 'mir 5/15/2003 20:50'!
timeout: seconds
	timeout := seconds! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!
upTo: aCharacterOrByte
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If  anObject is not in the collection, answer the entire rest of the receiver."

	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"

	^self upTo: aCharacterOrByte limit: 100000! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:27'!
upTo: aCharacterOrByte limit: nBytes
	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"

	| target index result searchedSoFar |
	"Deal with ascii vs. binary"
	self isBinary 
		ifTrue:[target := aCharacterOrByte asInteger] 
		ifFalse:[target := aCharacterOrByte asCharacter].

	"Look in the current inBuffer first"
	index := inBuffer indexOf: target startingAt: lastRead + 1 ifAbsent:[0].

	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"
		result := self nextInBuffer: index - lastRead - 1.
		self skip: 1.
		^ result
	].

	[searchedSoFar :=  self inBufferSize.
	"Receive more data"
	self receiveData.
	"We only get recentlyRead = 0 in the case of a non-signaling socket close."
	recentlyRead > 0] whileTrue:[
		"Data begins at lastRead + 1, we add searchedSoFar as offset."

		index := inBuffer indexOf: target
						startingAt: (lastRead + searchedSoFar + 1)
						ifAbsent:[0].
		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"
			result := self nextInBuffer: index - lastRead - 1.
			self skip: 1.
			^ result
		].

		"Check if we've exceeded the max. amount"
		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 
			ifTrue:[^self nextAllInBuffer].
	].

	"not found and (non-signaling) connection was closed"
	^self nextAllInBuffer! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48'!
upToAll: aStringOrByteArray
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."

	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"

	^self upToAll: aStringOrByteArray limit: 100000! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:32'!
upToAll: aStringOrByteArray limit: nBytes
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"

	| index sz result searchedSoFar target |
	"Deal with ascii vs. binary"
	self isBinary
		ifTrue:[target := aStringOrByteArray asByteArray]
		ifFalse:[target := aStringOrByteArray asString].

	sz := target size.
	"Look in the current inBuffer first"
	index := inBuffer indexOfSubCollection: target
						startingAt: lastRead - sz + 2.
	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
		result := self nextInBuffer: index - lastRead - 1.
		self skip: sz.
		^ result
	].

	[searchedSoFar :=  self inBufferSize.
	"Receive more data"
	self receiveData.
	recentlyRead > 0] whileTrue:[

		"Data begins at lastRead + 1, we add searchedSoFar as offset and 
		backs up sz - 1 so that we can catch any borderline hits."

		index := inBuffer indexOfSubCollection: target
						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).
		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
			result := self nextInBuffer: index - lastRead - 1.
			self skip: sz.
			^ result
		].
		"Check if we've exceeded the max. amount"
		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 
			ifTrue:[^self nextAllInBuffer].
	].

	"not found and (non-signaling) connection was closed"
	^self nextAllInBuffer! !
!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:49'!
upToEnd
	"Answer all data coming in on the socket until the socket
	is closed by the other end, or we get a timeout.
	This means this method catches ConnectionClosed by itself."

	[[self atEnd] whileFalse: [self beSignalingWhile:[self receiveData]]]
		on: ConnectionClosed
		do: [:ex | "swallow it"]. 
	^self nextAllInBuffer! !
!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:16'!
waitForData
	"Wait for data. If shouldTimeout, we will time out if nothing arrives, otherwise we wait indefinitely"

	self shouldTimeout
		ifTrue: [socket waitForDataFor: self timeout
			ifClosed: [self signalClosed]
			ifTimedOut: [self signalTimeout]]
		ifFalse: [socket waitForDataIfClosed: [self signalClosed]]! !
!SocketStream class methodsFor: 'example' stamp: 'jmv 3/13/2012 12:47'!
finger: userName
	"SocketStream finger: 'stp'"

	| addr s |
	addr := NetNameResolver promptUserForHostAddress.
	s := SocketStream openConnectionToHost: addr port: 79.  "finger port number"
	Transcript show: '---------- Connecting ----------'; newLine.
	s sendCommand: userName.
	Transcript show: s nextLine.
	s close.
	Transcript show: '---------- Connection Closed ----------'; newLine; endEntry.
! !
!SocketStream class methodsFor: 'instance creation' stamp: 'gk 2/3/2005 22:19'!
on: socket
	"Create a socket stream on a connected server socket."

	^self basicNew initialize socket: socket! !
!SocketStream class methodsFor: 'instance creation' stamp: 'jmv 8/5/2011 17:26'!
openConnectionToHost: hostIP port: portNumber
	^ self openConnectionToHost: hostIP port: portNumber timeout: Socket standardTimeout! !
!SocketStream class methodsFor: 'instance creation' stamp: 'jmv 8/5/2011 17:26'!
openConnectionToHost: hostIP port: portNumber timeout: timeout
	| socket |
	socket := Socket new.
	socket connectTo: hostIP port: portNumber waitForConnectionFor: timeout.
	^self on: socket! !
!SocketStream class methodsFor: 'instance creation' stamp: 'gk 2/3/2005 20:35'!
openConnectionToHostNamed: hostName port: portNumber
	| hostIP |
	hostIP := NetNameResolver addressForName: hostName timeout: 20.
	^self openConnectionToHost: hostIP port: portNumber! !

!classDefinition: #WebChunkedStream category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
ReadStream subclass: #WebChunkedStream
	instanceVariableNames: 'sourceStream chunkSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebChunkedStream category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
ReadStream subclass: #WebChunkedStream
	instanceVariableNames: 'sourceStream chunkSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebChunkedStream class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebChunkedStream class
	instanceVariableNames: ''!

!classDefinition: 'WebChunkedStream class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebChunkedStream class
	instanceVariableNames: ''!

!classDefinition: #SqueakSSLCertificateError category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
Error subclass: #SqueakSSLCertificateError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SqueakSSLCertificateError category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
Error subclass: #SqueakSSLCertificateError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: 'SqueakSSLCertificateError class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SqueakSSLCertificateError class
	instanceVariableNames: ''!

!classDefinition: 'SqueakSSLCertificateError class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SqueakSSLCertificateError class
	instanceVariableNames: ''!

!classDefinition: #WebAuthRequired category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Exception subclass: #WebAuthRequired
	instanceVariableNames: 'client request response authParams message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebAuthRequired category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Exception subclass: #WebAuthRequired
	instanceVariableNames: 'client request response authParams message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebAuthRequired class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebAuthRequired class
	instanceVariableNames: ''!

!classDefinition: 'WebAuthRequired class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebAuthRequired class
	instanceVariableNames: ''!

!classDefinition: #SecureSocket category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
Socket subclass: #SecureSocket
	instanceVariableNames: 'ssl decoded readBuf sendBuf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SecureSocket category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
Socket subclass: #SecureSocket
	instanceVariableNames: 'ssl decoded readBuf sendBuf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: 'SecureSocket class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SecureSocket class
	instanceVariableNames: ''!

!classDefinition: 'SecureSocket class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SecureSocket class
	instanceVariableNames: ''!

!classDefinition: #SecureSocketStream category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SocketStream subclass: #SecureSocketStream
	instanceVariableNames: 'ssl sendBuf readBuf decoded certIssues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SecureSocketStream category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SocketStream subclass: #SecureSocketStream
	instanceVariableNames: 'ssl sendBuf readBuf decoded certIssues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: 'SecureSocketStream class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SecureSocketStream class
	instanceVariableNames: ''!

!classDefinition: 'SecureSocketStream class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:31'!
SecureSocketStream class
	instanceVariableNames: ''!

!classDefinition: #WebClient category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebClient
	instanceVariableNames: 'flags server scheme timeout stream cookies proxyServer lastScheme lastServer lastPort maxRedirect redirections userAgent authParams proxyParams accessLog debugLog'
	classVariableNames: 'DebugLog FlagAcceptCookies FlagAllowAuth FlagAllowRedirect ProxyHandler'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebClient category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebClient
	instanceVariableNames: 'flags server scheme timeout stream cookies proxyServer lastScheme lastServer lastPort maxRedirect redirections userAgent authParams proxyParams accessLog debugLog'
	classVariableNames: 'DebugLog FlagAcceptCookies FlagAllowAuth FlagAllowRedirect ProxyHandler'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebClient class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebClient class
	instanceVariableNames: ''!

!classDefinition: 'WebClient class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebClient class
	instanceVariableNames: ''!

!classDefinition: #WebCookie category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebCookie
	instanceVariableNames: 'name value path domain expiry version secure httpOnly comment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebCookie category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebCookie
	instanceVariableNames: 'name value path domain expiry version secure httpOnly comment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebCookie class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebCookie class
	instanceVariableNames: ''!

!classDefinition: 'WebCookie class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebCookie class
	instanceVariableNames: ''!

!classDefinition: #WebMessage category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebMessage
	instanceVariableNames: 'stream protocol headers content'
	classVariableNames: 'StatusCodes'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebMessage category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebMessage
	instanceVariableNames: 'stream protocol headers content'
	classVariableNames: 'StatusCodes'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebMessage class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage class
	instanceVariableNames: ''!

!classDefinition: 'WebMessage class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage class
	instanceVariableNames: ''!

!classDefinition: #WebRequest category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage subclass: #WebRequest
	instanceVariableNames: 'method request rawUrl server'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebRequest category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage subclass: #WebRequest
	instanceVariableNames: 'method request rawUrl server'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebRequest class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebRequest class
	instanceVariableNames: ''!

!classDefinition: 'WebRequest class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebRequest class
	instanceVariableNames: ''!

!classDefinition: #WebResponse category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage subclass: #WebResponse
	instanceVariableNames: 'request status code url'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebResponse category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebMessage subclass: #WebResponse
	instanceVariableNames: 'request status code url'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebResponse class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebResponse class
	instanceVariableNames: ''!

!classDefinition: 'WebResponse class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
WebResponse class
	instanceVariableNames: ''!

!classDefinition: #WebServer category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:31'!
Object subclass: #WebServer
	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'
	classVariableNames: 'Default Registry'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebServer category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #WebServer
	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'
	classVariableNames: 'Default Registry'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebServer class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebServer class
	instanceVariableNames: ''!

!classDefinition: 'WebServer class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebServer class
	instanceVariableNames: ''!

!classDefinition: #WebSocket category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #WebSocket
	instanceVariableNames: 'name process stream handlers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #WebSocket
	instanceVariableNames: 'name process stream handlers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebSocket class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket class
	instanceVariableNames: ''!

!classDefinition: #WebSocket00 category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket subclass: #WebSocket00
	instanceVariableNames: 'frameType frameData'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket00 category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket subclass: #WebSocket00
	instanceVariableNames: 'frameType frameData'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebSocket00 class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket00 class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket00 class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket00 class
	instanceVariableNames: ''!

!classDefinition: #WebSocket07 category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket subclass: #WebSocket07
	instanceVariableNames: 'frameType frameData closing masking'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket07 category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket subclass: #WebSocket07
	instanceVariableNames: 'frameType frameData closing masking'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebSocket07 class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket07 class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket07 class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebSocket07 class
	instanceVariableNames: ''!

!classDefinition: #WebUtils category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #WebUtils
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebUtils category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #WebUtils
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: 'WebUtils class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebUtils class
	instanceVariableNames: 'currentProxyServer'!

!classDefinition: 'WebUtils class' category: 'WebClient-Core' stamp: 'VV 11/10/2022 00:44:32'!
WebUtils class
	instanceVariableNames: 'currentProxyServer'!

!classDefinition: #SqueakSSL category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #SqueakSSL
	instanceVariableNames: 'handle readBlock writeBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SqueakSSL category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:32'!
Object subclass: #SqueakSSL
	instanceVariableNames: 'handle readBlock writeBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: 'SqueakSSL class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:32'!
SqueakSSL class
	instanceVariableNames: ''!

!classDefinition: 'SqueakSSL class' category: 'WebClient-SqueakSSL-Core' stamp: 'VV 11/10/2022 00:44:32'!
SqueakSSL class
	instanceVariableNames: ''!
!WebChunkedStream commentStamp: 'ar 1/31/2012 14:00' prior: 0!
Can process chunked data.!
!WebAuthRequired commentStamp: 'ar 2/10/2012 12:39' prior: 0!
Exception signaled when authentication is required.!
!SecureSocketStream commentStamp: 'ar 7/25/2010 14:19' prior: 0!
A variant on SocketStream supporting SSL/TLS encryption via SqueakSSL.
!
!WebClient commentStamp: 'jmv 6/25/2017 22:23:28' prior: 0!
WebClient provides a simple yet complete HTTP client implementation.

To retrieve the contents of a web page:
(WebClient httpGet: 'http://www.cuis-smalltalk.org/') content

INTRO
-------

The simplest form to use WebClient is by one of its convenience APIs:

	WebClient httpGet: 'http://www.squeak.org/'.
	WebClient httpPost: 'http://www.squeak.org/' content:'Hello Squeak' type: 'text/plain'.

For more elaborate use of headers and some other options in the request, a client can utilize modified variants:

	WebClient new httpGet: 'http://www.squeak.org/' do: [ :req|
		"Set an if-modified-since header"
		req headerAt: 'If-Modified-Since' put: 'Sat, 29 Oct 1994 19:43:31 GMT'.
		"Add several accept headers"
		req addHeader: 'Accept' value: 'text/plain'.
		req addHeader: 'Accept' value: 'application/x-foo-bar'.
		req addHeader: 'Accept' value: 'image/jpg'.
	].

The set of utility methods is limited to a few useful ones but it is easy to do the setup on your own:

	| url client request data |
	data := 'Hello Squeak'.								"POST data"
	url := 'http://www.squeak.org/'.						"POST url"
	client := WebClient new initializeFromUrl: url. 		"sets host etc"
	request := client requestWithUrl: url. 				"sets path etc"
	request method: 'POST'.							"sets method"
	request headerAt: 'Content-Length' put: data size.
	request headerAt: 'Content-Type' put: 'text/plain'.
	"... any other headers required ..."
	^client sendRequest: request 
		content: data readStream
		size: data size.

The utility methods like httpGet: etc. are similarly simple requests.

RESPONSES
--------------

The WebClient request methods return a WebResponse that the client can process:

	| resp |
	resp := WebClient httpGet: 'http://www.squeak.org/'.
	resp isSuccess ifFalse: [^self error: resp status].
	"Process the content from the response"
	^resp content

In addition, content can be streamed from the response so that it does not need to be downloaded all at once:

	| client resp |
	client := WebClient new.
	[
		resp := client httpGet: 'http://www.squeak.org/'.
		resp isSuccess ifFalse:[^self error: resp status].
		"Stream the content from the response"
		'page.html' asFileEntry forceWriteStreamDo: [ :file |
			resp streamTo: file 
				size: resp contentLength
				progress: [ :total :amount ]].
	] ensure: [ client close].

The progress block in the above can be omitted but has been included in this example to illustrate its usage. The block takes a total length (which can be nil if the length is not known) and the amount that has been loaded.

MULTIPLE REQUESTS
-------------------------

WebClient can and should be used for multiple requests to the same host. This will ensure persistent connections as well as having cookies processed properly within one session:

	| client resp |
	client := WebClient new.
	resp := client httpGet: 'http://www.squeak.org/'.
	resp := client httpGet: 'http://www.squeak.org/Download'.
	resp := client httpGet: 'http://www.squeak.org/Features'.
	client close.

One important issue to keep in mind is that because WebClient is optimized for persistent connections, you need to close it when you are done. That is not true for WebClient's class-side convenience APIs, which prefetch the response and close the socket. Generally speaking, whenever you say 'WebClient new' you need to close the client when you're done (however, you can do so by sending #close to a response you've received). For example:

	"Convenience API. Don't need to close, but prefetches result."
	WebClient httpGet: 'http://www.squeak.org'.

	| client resp |
	"Regular use. Create WebClient, return after header is read ..."
	client := WebClient new.
	[response := client httpGet: 'http://www.squeak.org/'.
	"... then fetch (or stream) the content ..."
	response content.
	] ensure:[
		"... and close the client when done."
		client close.
	].

AUTHENTICATION
---------------------

WebClient supports basic and digest authentication by default. WebClient delegates the retrieval of username/password to WebUtils which prompts the user for credentials. 

WebClient can either be supplied with specific credentials to be used or custom credentials handlers, for example:

	| client |
	client := WebClient new.
	client username: 'squeak'.
	client password: 'squeak'.
	client httpGet: 'http://www.squeak.org/protected'.

Proxy authentication works the same way as authentication but operates on a different authentication context to allow different sets of credentials to work.
!
!WebCookie commentStamp: 'jmv 6/25/2017 19:47:45' prior: 0!
WebCookie represents an http cookie for use by WebClient.!
!WebMessage commentStamp: 'ar 2/23/2010 10:37' prior: 0!
A common base class for WebRequest and WebResponse.!
!WebRequest commentStamp: 'ar 2/23/2010 10:38' prior: 0!
Represents an HTTP request for WebClient/WebServer.!
!WebResponse commentStamp: 'ar 2/23/2010 10:39' prior: 0!
Represents an HTTP response for WebClient/WebServer.!
!WebServer commentStamp: '<historical>' prior: 0!
WebServer provides a simple yet complete HTTP server implementation.

Example:
(WebServer new listenOn: 8080) addService: '/hello' action: [ :req | req send200Response: 'Hello World!!']!
!WebSocket commentStamp: '<historical>' prior: 0!
A wrapper object for the WebSocket API.!
!WebSocket00 commentStamp: 'ar 7/8/2010 18:21' prior: 0!
A wrapper object for the WebSocket API.!
!WebSocket07 commentStamp: '<historical>' prior: 0!
A wrapper object for the WebSocket API.!
!WebUtils commentStamp: 'ar 2/23/2010 10:39' prior: 0!
WebUtils contains a number of utility methods used by WebClient/WebServer.!
!SqueakSSL commentStamp: 'ar 7/16/2010 23:14' prior: 0!
SqueakSSL provides an interface to the platforms SSL/TLS facilities.
!
!WebChunkedStream methodsFor: 'testing' stamp: 'ar 1/31/2012 14:26' overrides: 16914201!
atEnd
	^chunkSize = 0 and:[super atEnd]! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:09' overrides: 16922435!
next
	"Answer the next decompressed object in the Stream represented by the
	receiver."

	<primitive: 65>
	position >= readLimit
		ifTrue: [^self pastEndRead]
		ifFalse: [^collection at: (position := position + 1)]! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:25' overrides: 16922442!
next: anInteger 
	"Answer the next anInteger elements of my collection.  overriden for simplicity"

	[(position + anInteger >= readLimit) and:[chunkSize ~= 0]] 
		whileTrue:[self nextChunk].

	^super next: anInteger
! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'DSG 5/29/2012 13:40' overrides: 50364831!
nextChunk
	"Answer the next chunk from a message using chunked transfer encoding."

	| chunk |
	chunkSize = 0 ifTrue:[^'']. "read last chunk"
	chunkSize := Integer readFrom: (sourceStream upToAll: String crlfString) asString base: 16.
	chunkSize = 0 ifFalse:[chunk := sourceStream next: chunkSize].
	sourceStream skip: 2. "CrLf"
	(chunkSize + readLimit - position) <= collection size ifTrue:[
		collection replaceFrom: 1 to: (readLimit-position) with: collection startingAt: position+1.
		readLimit := readLimit - position.
		position := 0.
		collection replaceFrom: readLimit+1 to: readLimit + chunkSize with: chunk startingAt: 1.
		readLimit := readLimit + chunkSize.
	] ifFalse:[
		collection := collection, chunk.
		readLimit := readLimit + chunkSize.
	].
	^chunk
! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:11'!
pastEndRead
	"Need more data"

	self nextChunk.
	^self next! !
!WebChunkedStream methodsFor: 'initialize' stamp: 'ar 1/31/2012 14:24' overrides: 50361502!
on: aStream

	sourceStream := aStream.
	collection := (aStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new.
	position := readLimit := 0.! !
!SqueakSSLCertificateError methodsFor: 'testing' stamp: 'ar 8/16/2011 19:18' overrides: 16848974!
isResumable
	"Determine whether an exception is resumable."

	^true! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:14'!
client
	"The client causing the exception"

	^client! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:49'!
message
	"Answer a default message for the user to ask for input"

	self isProxyAuth ifTrue:[
		^'The proxy server at "', client proxyServerName, '" requires authentication.'.
	].

	^'The server at "', client serverName, '" requires authentication.'.! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:04'!
request
	"The request object causing the exception"

	^request! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:05'!
response
	"The response object causing the exception"

	^response! !
!WebAuthRequired methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:06'!
client: aWebClient request: aWebRequest response: aWebResponse
	"Initializes the exception"

	client := aWebClient.
	request := aWebRequest.
	response := aWebResponse.
! !
!WebAuthRequired methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:13'!
username: username password: password
	"Use the given username/password as credentials"

	| params retry |
	params := self isProxyAuth ifTrue:[client proxyParams] ifFalse:[client authParams].
	retry := false.
	(params at: #username ifAbsent:[nil]) = username ifFalse:[
		params at: #username put: username.
		retry := true.
	].
	(params at: #password ifAbsent:[nil]) = password ifFalse:[
		params at: #password put: password.
		retry := true.
	].
	retry ifTrue:[self resume: true].
! !
!WebAuthRequired methodsFor: 'defaults' stamp: 'ar 2/10/2012 13:14' overrides: 16849776!
defaultAction

	self resume: false.! !
!WebAuthRequired methodsFor: 'defaults' stamp: 'ar 2/10/2012 13:07' overrides: 16849755!
defaultResumeValue
	"Resume with false by default"

	^false! !
!WebAuthRequired methodsFor: 'testing' stamp: 'ar 2/10/2012 13:09'!
isProxyAuth
	"Return true if proxy authorization is required"

	^response code = 407! !
!WebAuthRequired methodsFor: 'testing' stamp: 'ar 2/10/2012 13:09'!
isUnauthorized
	"Return true if authorization is required"

	^response code = 401! !
!WebAuthRequired class methodsFor: 'instance creation' stamp: 'ar 2/10/2012 13:16'!
client: aWebClient request: aWebRequest response: aWebResponse
	"Creates a new exception"

	^(self new)
		client: aWebClient 
		request: aWebRequest 
		response: aWebResponse! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:07'!
certState
	^ssl ifNotNil:[ssl certState]! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:07' overrides: 50619305!
peerName
	^ssl ifNotNil:[ssl peerName]! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:05'!
ssl
	"Answer the SqueakSSL instance"
	^ssl! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:00'!
decodeData
	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."
	| total bytesRead |
	decoded atEnd ifFalse:[^self].

	"Decrypt more data if available"
	bytesRead := 0.
	[total := ssl decrypt: readBuf from: 1 to: bytesRead into: decoded originalContents.
	total < 0 ifTrue:[^self error: 'SSL error, code: ', total].
	bytesRead := 0.
	total = 0 ifTrue:[
		bytesRead := super primSocket: socketHandle receiveDataInto: readBuf startingAt: 1 count: readBuf size.
	].
	bytesRead = 0] whileFalse.

	"Update for number of bytes decoded"
	decoded setFrom: 1 to: total.
! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/19/2012 21:12' overrides: 50619177!
isConnected
	"Return true if this socket is connected."
	"We mustn't return false if there is data available"

	^super isConnected or:[self dataAvailable]! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:00' overrides: 50619415!
primSocket: socketID receiveDataInto: buffer startingAt: index count: count
	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."
	| total |

	ssl ifNil:[^super primSocket: socketID receiveDataInto: buffer startingAt: index count: count].

	self decodeData.

	"Push data from decoded into the result buffer"
	total := (decoded size - decoded position) min: (buffer size - index + 1).
	(decoded readInto: buffer startingAt: index count: total) = total 
		ifFalse:[self error: 'Unexpected read failure'].
	^total
! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 11:00' overrides: 50619443!
primSocket: socketID sendData: buffer startIndex: start count: amount
	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."
	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."

	| count |
	ssl ifNil:[^super primSocket: socketID sendData: buffer startIndex: start count: amount].

	count := ssl encrypt: buffer from: start to: start+amount-1 into: sendBuf.
	count < 0 ifTrue:[self error: 'SSL Error: ', count].
	^super primSocket: socketID sendData: sendBuf startIndex: 1 count: count! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:01' overrides: 50619698!
primSocketReceiveDataAvailable: socketID
	"Return true if data may be available for reading from the current socket."

	ssl ifNil:[^super primSocketReceiveDataAvailable: socketID].
	self decodeData.
	^decoded atEnd not! !
!SecureSocket methodsFor: 'initialize' stamp: 'ar 6/17/2012 11:08' overrides: 50619039!
destroy
	ssl ifNotNil:[
		ssl destroy.
		ssl := nil
	].
	super destroy.! !
!SecureSocket methodsFor: 'initialize' stamp: 'ar 6/17/2012 11:11' overrides: 16920235!
initialize

	super initialize.
	decoded := ReadStream on: (ByteArray new: 20000) from: 1 to: 0.
	sendBuf := ByteArray new: 4096.
	readBuf := ByteArray new: 4096.
! !
!SecureSocket methodsFor: 'connect' stamp: 'ar 6/17/2012 11:05'!
sslAccept: certName
	"Perform the SSL server handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	| squeakSSL result inbuf |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	squeakSSL certName: certName.

	"Perform the server handshake"
	[[squeakSSL isConnected] whileFalse:[
		"Read input"
		inbuf := self receiveData.
		result := squeakSSL accept: inbuf from: 1 to: inbuf size into: sendBuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].
	].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27'!
sslConnect
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	self sslConnectTo: nil! !
!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27'!
sslConnectTo: serverName
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."

	| inbuf squeakSSL result |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	serverName ifNotNil: [ squeakSSL serverName: serverName ].
	"Perform the SSL handshake"
	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].

		"Read more input and repeat"
		inbuf := self receiveData.
	].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocket class methodsFor: 'examples' stamp: 'jmv 6/26/2017 18:57:14'!
google: query
	"An example HTTPS query to encrypted.google.com.
	Example:
		SecureSocket google: 'squeak'.
		SecureSocket google: 'SqueakSSL'.
	"

	| hostName address socket |

	"Change the host name to try an https request to some other host"
	hostName := 'encrypted.google.com'.

	address := NetNameResolver addressForName: hostName.
	socket := SecureSocket newTCP.

	"Connect the TCP socket"
	socket connectTo: address port: 443.
	socket waitForConnectionFor: 10.

	["Handle the client handshake"
	socket sslConnectTo: hostName.

	"Verify that the cert is valid"
	socket certState = 0 ifFalse:[
		self error: 'The certificate is invalid (code: ', socket certState,')'.
	].

	"If the certificate is valid, make sure we're were we wanted to go"
	(socket peerName match: hostName) ifFalse:[
		self error: 'Host name mismatch: ', socket peerName.
	].

	"Send encrypted data"
	socket sendData:
		'GET /search?q=', query,' HTTP/1.0', String crlfString,
		'Host: ', hostName, String crlfString,
		'Connection: close', String crlfString,
		String crlfString.

	"Wait for the response"
	^String streamContents:[:s|
		[[true] whileTrue:[s nextPutAll: socket receiveData]]
			on: ConnectionClosed, ConnectionTimedOut do:[:ex| ex return].
	]] ensure:[socket destroy].
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31' overrides: 50620961!
ascii
	"Switch to ASCII"

	super ascii.
	decoded := (ReadStream 
		on: decoded originalContents asString 
		from: 1 to: decoded size)
			position: decoded position;
			yourself.
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 11/9/2010 11:09' overrides: 50621022!
binary
	"Switch to binary"

	super binary.
	decoded := (ReadStream 
		on: decoded originalContents asByteArray 
		from: 1 to: decoded size)
			position: decoded position;
			yourself.
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31'!
certState
	"Returns the certificate verification bits. The returned value indicates
	whether the certificate is valid. The two standard values are:

		0 - The certificate is valid.
		-1 - No certificate has been provided by the peer.

	Otherwise, the result is a bit mask of the following values:

		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.

	"

	^ssl ifNotNil:[ssl certState]! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31'!
ignoredCertIssues
	"Answer the mask of 'acceptable issues' with certs. To completely ignore all cert issues use -1 which still ensures privacy (encryption) to the remote host, but does not guard against a man-in-the-middle attack (i.e., you cannot be sure that the remote host is what he says he is). The reasons are a bit mask consisting of the following values:
		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.
	"

	^certIssues! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31'!
ignoredCertIssues: reasonsMask
	"Set the mask of 'acceptable issues' with certs. To completely ignore all cert issues use -1 which still ensures privacy (encryption) to the remote host, but does not guard against a man-in-the-middle attack (i.e., you cannot be sure that the remote host is what he says he is). The reasons are a bit mask consisting of the following values:
		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.
	"

	certIssues := reasonsMask! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 14:45'!
peerName
	"Returns the certificate name of the remote peer.
	The method only returns a name if the certificate has been verified."

	^ssl ifNotNil:[ssl peerName]! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:32'!
ssl
	"The SqueakSSL instance"

	^ssl! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' overrides: 50620971!
atEnd
	"Pre Squeak 4.2 compatibility"

	self receiveAvailableData.
	^super atEnd! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:33' overrides: 50621090!
flush
	"Pre-Squeak 4.2 compatibility"

	((outNextToWrite > 1) and: [socket isOtherEndClosed not])
		ifTrue: [
			[self sendData: outBuffer count: outNextToWrite - 1]
				on: ConnectionTimedOut
				do: [:ex | shouldSignal ifFalse: ["swallow"]].
			outNextToWrite := 1]
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' overrides: 50621129!
isDataAvailable
	"Pre Squeak 4.2 compatibility"
 
	self isInBufferEmpty ifFalse: [^true].
	^self receiveAvailableData < inNextToWrite
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:35' overrides: 50621365!
nextPutAllFlush: aCollection
	"Pre Squeak 4.2 compatibility"

	| toPut |
	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].
	self flush. "first flush pending stuff, then directly send"
	socket isOtherEndClosed ifFalse: [
		[self sendData: toPut count: toPut size]
			on: ConnectionTimedOut
			do: [:ex | shouldSignal ifFalse: ["swallow"]]]
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:32' overrides: 50621498!
receiveAvailableData
	"Pre Squeak 4.2 compatibility"
	
	recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.
	^self adjustInBuffer: recentlyRead
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' overrides: 50621516!
receiveData: nBytes
	"Pre Squeak 4.2 compatibility"

	self receiveAvailableData.
	^super receiveData: nBytes.! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:32' overrides: 50621540!
receiveDataIfAvailable
	"Pre Squeak 4.2 compatibility"

	^self receiveAvailableData
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' overrides: 50621756!
upToAll: aStringOrByteArray
	"Pre Squeak 4.2 compatibility"

	^self upToAll: aStringOrByteArray limit: 100000! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' overrides: 50621774!
upToAll: aStringOrByteArray limit: nBytes
	"Pre Squeak 4.2 compatibility"

	| index sz result searchedSoFar target |
	"Deal with ascii vs. binary"
	self isBinary
		ifTrue:[target := aStringOrByteArray asByteArray]
		ifFalse:[target := aStringOrByteArray asString].

	sz := target size.
	"Look in the current inBuffer first"
	index := inBuffer indexOfSubCollection: target
						startingAt: lastRead - sz + 2.
	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
		result := self nextInBuffer: index - lastRead - 1.
		self skip: sz.
		^ result
	].

	[searchedSoFar :=  self inBufferSize.
	"Receive more data"
	self receiveData.
	recentlyRead > 0] whileTrue:[

		"Data begins at lastRead + 1, we add searchedSoFar as offset and 
		backs up sz - 1 so that we can catch any borderline hits."

		index := inBuffer indexOfSubCollection: target
						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).
		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
			result := self nextInBuffer: index - lastRead - 1.
			self skip: sz.
			^ result
		].
		"Check if we've exceeded the max. amount"
		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 
			ifTrue:[^self nextAllInBuffer].
	].

	"not found and (non-signaling) connection was closed"
	^self nextAllInBuffer! !
!SecureSocketStream methodsFor: 'errors' stamp: 'ar 8/16/2011 10:21'!
certError: errorString code: reason
	"Signal an issue with a certificate. If the reason code matches the acceptable cert issues, continue, otherwise signal an error."

	(certIssues allMask: reason) ifTrue:[^self].
	^SqueakSSLCertificateError signal: errorString, '(code: ', reason, ')'.
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 17:30' overrides: 50621052!
close
	"Flush any data still not sent and take care of the socket."

	super close.
	ssl ifNotNil:[
		ssl destroy.
		ssl := nil.
	].! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 17:34' overrides: 50621081!
destroy
	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."

	"Pre-4.2 compatibility. Should be 'super destroy' instead of 'socket destroy'"
	socket ifNotNil:[
		socket destroy.
		socket := nil.
	].

	ssl ifNotNil:[
		ssl destroy.
		ssl := nil.
	].! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 15:58' overrides: 50621115!
initialize
	"Initialize the receiver"
	
	"I think 16k is the max for SSL frames so use a tad more"
	decoded := ReadStream on: (ByteArray new: 20000) from: 1 to: 0.

	super initialize.

	sendBuf := ByteArray new: 4096.
	readBuf := ByteArray new: 4096.
	certIssues := 0.
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 11/17/2011 17:10'!
sslAccept: certName
	"Perform the SSL server handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	| squeakSSL result inbuf |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	squeakSSL certName: certName.

	"Perform the server handshake"
	[[squeakSSL isConnected] whileFalse:[
		"Read input"
		self receiveData.
		inbuf := self nextAvailable.
		result := squeakSSL accept: inbuf from: 1 to: inbuf size into: sendBuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[
			self nextPutAll: (sendBuf copyFrom: 1 to: result).
			self flush.
		].
	].
	"There should be no pending data at this point, ensure it is so.
	XXXX: If you ever see this problem, please inform me."
	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ul 10/15/2014 19:20'!
sslConnect
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	self sslConnectTo: nil! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'jmv 6/26/2017 18:55:27'!
sslConnectTo: serverName
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."

	| inbuf squeakSSL result |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	serverName ifNotNil: [ squeakSSL serverName: serverName ].
	"Perform the SSL handshake"
	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result printString].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[
			self nextPutAll: (sendBuf copyFrom: 1 to: result).
			self flush.
		].

		"Read more input and repeat"
		self receiveData.
		inbuf := self nextAvailable.
	].
	"There should be no pending data at this point, ensure it is so.
	XXXX: If you ever see this problem, please inform me."
	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/27/2010 21:09'!
verifyCert: hostName
	"Verifies the cert state and host name"

	| certFlags |
	certFlags := self certState.
	certFlags = -1 
		ifTrue:[^self certError: 'No certificate was provided' code: -1].
	certFlags = 0 
		ifFalse:[self certError: 'Invalid certificate' code: certFlags].
	(ssl peerName match: hostName) 
		ifFalse:[self certError: 'Host name mismatch' code: -1].! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 11/15/2010 11:39' overrides: 50621512!
receiveData
	"This method drains the available decryption data before waiting for the socket"

	| pos |

	"Note: The loop here is necessary to catch cases where a TLS packet is
	split among TCP packets. In this case we would pull the first portion of
	the TLS packet here but receiveAvailableData would return nothing since
	the contents of the packet can't be decoded until the rest has come in."

	[pos := inNextToWrite.
	self receiveAvailableData.
	pos = inNextToWrite ifFalse:[^pos].

	"Pre-4.2 compatibility; should be 'super receiveData' instead."
	socket
		waitForDataFor: self timeout
		ifClosed: [self shouldSignal 
			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]
		ifTimedOut: [self shouldTimeout
			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].
	self isConnected] whileTrue.

	"Final attempt to read data if a non-signaling connection closes"
	^self receiveAvailableData.
! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 11/17/2011 13:19' overrides: 50621546!
receiveDataInto: buffer startingAt: index
	"Read and decrypt the data from the underlying socket. "

	| count bytesRead |
	"While in handshake, use the superclass version"
	ssl ifNil:[
		"Pre-4.2 compatibility; should be 'super receiveDataInto: buffer startingAt: index'"
		^socket  receiveAvailableDataInto: buffer startingAt: index.
	].

	"Only decode more data if all the decoded contents has been drained"
	decoded atEnd ifTrue:[
		"Decrypt more data if available"
		bytesRead := 0.
		[count := ssl decrypt: readBuf from: 1 to: bytesRead into: decoded originalContents.
		count < 0 ifTrue:[^self error: 'SSL error, code: ', count].
		bytesRead := 0.
		count = 0 ifTrue:[
			bytesRead := socket receiveAvailableDataInto: readBuf startingAt: 1.
		].
		bytesRead = 0] whileFalse.
		"Update for number of bytes decoded"
		decoded setFrom: 1 to: count.
	].

	"Push data from decoded into the result buffer"
	count := (decoded size - decoded position) min: (buffer size - index + 1).
	(decoded next: count into: buffer startingAt: index) size < count
		ifTrue:[^self error: 'Unexpected read failure'].
	^count
! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 7/25/2010 17:37' overrides: 50621592!
sendData: buffer count: n
	"Encrypts the data before sending it on the underlying socket.
	Breaks large chunks into 2k components to fit safely into ssl frame."

	| remain start amount count |
	"While in handshake, use the superclass version"
	ssl ifNil:[
		"Pre-4.2 compatibility; should be 'super sendData: buffer count: n' instead"
		^socket sendData: buffer count: n
	].

	"Break the input into reasonable chunks and send them"
	remain := n. start := 1.
	[remain > 0] whileTrue:[
		amount := remain min: 2048.
		count := ssl encrypt: buffer from: start to: start+amount-1 into: sendBuf.
		socket sendData: sendBuf count: count.
		remain := remain - amount.
		start := start + amount.
	].! !
!WebClient methodsFor: 'printing' stamp: 'ar 8/9/2010 08:50' overrides: 16902975!
printOn: aStream
	"Print the receiver on aStream"

	aStream nextPutAll: self class name.
	aStream nextPut: $(.
	(stream notNil and:[stream isConnected]) ifTrue:[
		aStream nextPutAll: 'Connected: '.
	].
	scheme ifNotNil:[aStream nextPutAll: scheme, '://'].
	server ifNotNil:[aStream nextPutAll: server].
	aStream nextPut:$).
! !
!WebClient methodsFor: 'cookies' stamp: 'ar 8/12/2010 21:40'!
acceptCookie: aCookie host: reqHost path: path
	"Accept a cookie from a prior response"

	self acceptCookies ifTrue:[
		"Set the defaults per RFC 2109 section 4.3.1 "
	
		"Ensure the cookie domain is set"
		aCookie domain ifNil:[aCookie domain: reqHost].

		"Ensure the cookie path is set"
		aCookie path ifNil:[aCookie path: path].

		"Reject the cookie per RFC 2109 section 4.3.2"
		(path beginsWith: aCookie path) ifFalse:[^false].

		aCookie domain = reqHost ifFalse:[ | domain |
			domain := aCookie domain.
			"For misconfigured servers, insert the leading dot into the domain"
			domain first = $. ifFalse:[aCookie domain: (domain := '.', domain)].
			((domain count:[:ch| ch = $.]) >= 2) ifFalse:[^false].
			(reqHost endsWith: domain) ifFalse:[^false].
			((reqHost allButLast: domain size) includes: $.) ifTrue:[^false].
		].
	
		"Remove any old cookies"
		cookies := cookies reject:[:any| any = aCookie].
		
		"Remember the cookie if not expired"
		(aCookie expiry == nil or:[aCookie expiry > DateAndTime now])  ifTrue:[
			cookies add: aCookie.
			^true
		].
	].
	^false! !
!WebClient methodsFor: 'cookies' stamp: 'ar 4/1/2010 18:04'!
acceptCookies
	"Whether we should accept cookies"

	^flags anyMask: FlagAcceptCookies! !
!WebClient methodsFor: 'cookies' stamp: 'ar 4/1/2010 18:05'!
acceptCookies: aBool
	"Whether we should accept cookies"

	flags := aBool ifTrue:[flags bitOr: FlagAcceptCookies] ifFalse:[flags bitClear: FlagAcceptCookies].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:49'!
accessLog
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	^accessLog! !
!WebClient methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:49'!
accessLog: aStreamOrFilename
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	accessLog := aStreamOrFilename! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:03'!
allowAuth
	"If true, WebClient will attempt to handle authorization requests"

	^flags anyMask: FlagAllowAuth! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:02'!
allowAuth: aBool
	"If true, WebClient will attempt to handle authorization requests"

	flags := aBool ifTrue:[flags bitOr: FlagAllowAuth] ifFalse:[flags bitClear: FlagAllowAuth].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:01'!
allowRedirect
	"If true, WebClient will attempt to handle redirect responses"

	^flags anyMask: FlagAllowRedirect! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:02'!
allowRedirect: aBool
	"If true, WebClient will attempt to handle redirect responses"

	flags := aBool ifTrue:[flags bitOr: FlagAllowRedirect] ifFalse:[flags bitClear: FlagAllowRedirect].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:13'!
authParams
	"The authentication parameters"

	^authParams! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:13'!
authParams: aDictionary
	"The authentication parameters"

	authParams := aDictionary! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/23/2010 10:31'!
cookies
	"The cookies that have been set for this session"

	^cookies! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/23/2010 10:31'!
cookies: aCollection
	"The cookies that have been set for this session"

	cookies := aCollection.! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:16'!
debugLog
	"If provided, WebClient will print all requests and responses to the debugLog,
	except from the content of the message. The debug log must be a stream of
	some sort; file names (like for the accessLog are not supported)."

	^debugLog! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:17'!
debugLog: aStream
	"If provided, WebClient will print all requests and responses to the debugLog,
	except from the content of the message. The debug log must be a stream of
	some sort; file names (like for the accessLog are not supported)."

	debugLog := aStream! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:12'!
maxRedirect
	"The max. number of redirects we allow for the SAME SITE before giving up.
	Redirects can happen for any number of reasons between any number of sites
	and we give up if we have seen the SAME SITE maxRedirect number of times."

	^maxRedirect! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:12'!
maxRedirect: aNumber
	"The max. number of redirects we allow for the SAME SITE before giving up.
	Redirects can happen for any number of reasons between any number of sites
	and we give up if we have seen the SAME SITE maxRedirect number of times."

	maxRedirect := aNumber! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/27/2010 12:01'!
password
	"The password for remote authentication.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^authParams at: #password ifAbsent:[nil]! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/27/2010 01:32'!
password: aStringOrValuable
	"The password for remote authentication.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^authParams at: #password put: aStringOrValuable! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/5/2010 19:50'!
scheme
	"The scheme used for the request (usually http or https)"

	^scheme! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/5/2010 19:50'!
scheme: aString
	"The scheme used for the request (usually http or https)"

	scheme := aString! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/21/2010 09:50'!
server
	"The server to use for connections.
	The server is specified as server:port if needed"

	^server! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/21/2010 09:50'!
server: aString
	"The server to use for connections.
	The server should be specified as server:port if needed"

	server := aString
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 19:22'!
serverName
	"Returns the name part of the server:port description"

	^server copyUpTo: $:! !
!WebClient methodsFor: 'accessing' stamp: 'NR 6/23/2021 07:02:22'!
serverPort
	"Returns the port of the server:port description"

	^(server copyAfter: $:) 
		ifEmpty:[self defaultPort]
		ifNotEmpty:[:portString| portString asNumber].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:12'!
timeout
	"Timeout for the http operations"

	^timeout! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:12'!
timeout: aNumber
	"Timeout for the http operations"

	timeout := aNumber! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:16'!
userAgent
	"The User-Agent string sent to the server"

	^userAgent! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:17'!
userAgent: aString
	"The User-Agent string sent to the server. 
	If no user agent should be sent, this value can be set to nil"

	userAgent := aString! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/24/2010 16:05'!
username
	"The username for remote authentication"

	^authParams at: #username ifAbsent:[nil]! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/24/2010 16:05'!
username: aString
	"The username for remote authentication"

	authParams at: #username put: aString! !
!WebClient methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:45'!
authDispatch: request from: response header: authHeader params: params
	"Dispatch on an authentication method. 
	Subclasses can extend this method to support more auth methods."

	(authHeader copyUpTo: Character space) caseOf: {
		['Basic'] -> [self basicAuth: request from: response 
							header: authHeader params: params].
		['Digest'] -> [self digestAuth: request from: response 
							header: authHeader  params: params].
	} otherwise:["ignore"].
! !
!WebClient methodsFor: 'authentication' stamp: 'NR 11/4/2022 18:48:29'!
basicAuth: request from: response header: header params: params
	"Provide basic authentication for the request"

	| user pass args |
	authParams at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	authParams at: #authMethod put: 'Basic'.

	args := WebUtils parseAuthParams: header.
	args at: 'realm' ifPresent:[:realm| authParams at: #authRealm put: realm].
	
	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].
	authParams at: #authResponse put: (user, ':', pass value) asUtf8Bytes base64Encoded! !
!WebClient methodsFor: 'authentication' stamp: 'ar 8/26/2010 07:48'!
digestAuth: request from: response header: authHeader params: params
	"Perform digest authentication"

	| realm nonce ha1 ha2 nc cnonce qop header uri md5 key args user pass |
	params at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	params at: #authMethod put: 'Digest'.

	args := WebUtils parseAuthParams: authHeader.
	realm := args at: 'realm'.
	authParams at: #authRealm put: realm.

	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].

	nonce := args at: 'nonce'.
	uri := request rawUrl.

	"VERY IMPORTANT NOTE: Some servers fail horribly if the nonce count
	isn't precisely eight digits and without quotes."
	nc := args at: 'nc' put: (args at: 'nc' ifAbsent:[0]) + 1.
	nc := nc asString padded: #left to: 8 with: $0.
	
	key := user, ':', realm, ':', pass value.
	ha1 := WebUtils md5Digest: key.
	ha2 := WebUtils md5Digest: request method, ':', uri.
	cnonce := UUID new hex.

	(args includesKey: 'qop') ifTrue:["use qop"
		qop := 'auth'. "the only qop we support"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"',
			', qop="', qop,'"',
			', nc="', nc, '"',
			', cnonce="', cnonce, '"'.
	] ifFalse:["ignore qop"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"'.
	].
	args at: 'opaque' ifPresent: [:opaque | 
		header := header, ', opaque="', opaque, '"'
	].
	params at: #authResponse put: header.! !
!WebClient methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:46'!
flushAuthState: params
	"Fliush authentication state that should not been preserved 
	inbetween failed attempts to authenticate. 
	Subclasses can extend this method to support more auth methods."

	params removeKey: #authMethod ifAbsent:[].
! !
!WebClient methodsFor: 'sending' stamp: 'ar 2/10/2012 13:12'!
authenticate: request from: response
	"Authenticate after having received a 401/407 response.
	Returns true if we should retry, false if we fail here."

	"NOTE: The first time through we do NOT ask for credentials right away.
	Some authentication mechanisms (NTLM/Negotiate) can use the credentials
	of the currently logged on user. Consequently we only ask for credentials
	if we're unable to do so without asking. Methods that require credentials
	(basic, digest) test for their existence explicitly."

	| headers authHeader params |

	"Pick the right set of parameters"
	response code = 401 ifTrue:[
		params := authParams.
		headers := response headersAt: 'WWW-Authenticate'.
		"If the connection was closed, we need to flush the
		proxy params or we won't pick up prior credentials."
		self isConnected 
			ifFalse:[self flushAuthState: proxyParams].
	] ifFalse:[
		params := proxyParams.
		headers := response headersAt: 'Proxy-Authenticate'.
	].

	"Remove any old response"
	params removeKey: #authResponse ifAbsent:[].

	"Process the authentication header(s)"
	1 to: headers size do:[:i|
		authHeader := headers at: i.
		self authDispatch: request from: response header: authHeader params: params.
		"If we generated an authentication response for the header use it"
		params at: #authResponse ifPresent:[:resp|
			request headerAt: (response code = 401 
								ifTrue:['Authorization'] 
								ifFalse:['Proxy-Authorization'])
					put: (params at: #authMethod), ' ', resp.
			^true].
	].

	"If we fall through here this can have two reasons: One is that we don't have
	a suitable authentication method. Check for that first."
	params at: #authMethod ifAbsent:[^false].

	"The other possibility is that the credentials are wrong. 
	Clean out the previous auth state and go ask for credentials."
	self flushAuthState: params.

	"Clean out old authentication headers"
	response code = 401 
		ifTrue:[request removeHeader: 'Authorization'].
	"Always clean out the proxy auth header since we don't support pre-authentication"
	request removeHeader: 'Proxy-Authorization'.

	"Signal WebAuthRequired"
	(WebAuthRequired client: self request: request response: response)
		signal == true ifFalse:[^false].

	"And retry with the new credentials"
	^self authenticate: request from: response! !
!WebClient methodsFor: 'sending' stamp: 'ar 9/4/2010 11:10'!
redirect: request from: response
	"Handle a 3xx redirect response"

	| location max |
	
	"Check if we handle the specific type of redirect here"
	(#(	301 
		302 "Found" 
		303 "See Other" 
		307 "Temporary Redirect")
			includes: response code) ifFalse:[^false].

	"RFC 2616 states that requests other than HEAD and GET MUST NOT be auto
	redirected for 302 and 307 responses"
	(request method = 'GET' or:[request method = 'HEAD']) ifFalse:[
		(response code = 302 or:[response code = 307]) ifTrue:[^false].
	].

	"Find the new location"
	location := response headerAt: 'location'.

	"Check if we've exceeded max redirections"
	max := redirections at: location ifAbsent:[0].
	max > self maxRedirect ifTrue:[^false].
	redirections at: location put: max+1.

	"Do the actual redirect, i.e., set us up for the new url"
	(location findString: '://') > 0 "do we have a scheme:// url?"
		ifTrue:[self initializeFromUrl: location].

	request initializeFromUrl: location.

	^true! !
!WebClient methodsFor: 'sending' stamp: 'ar 2/25/2010 22:16'!
sendRequest: request
	"Send an http request"

	^self sendRequest: request content: nil size: 0! !
!WebClient methodsFor: 'sending' stamp: 'DSG 5/25/2012 23:35'!
sendRequest: request content: contentStream size: streamSize
	"Send an http request"

	^self sendRequest: request contentBlock:[:aStream|
		contentStream ifNotNil:[
			"Upload content if provided"
			contentStream position: 0.
			request streamFrom: contentStream to: aStream size: streamSize 
				progress:[:total :amount|
					(ProgressBarMorph new) 
						progressValue: amount / total.
						]]].
! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:32:10'!
sendRequest: request contentBlock: contentBlock
	"Send an http request"

	|  response repeatRedirect repeatAuth |

	"XXXX: Fixme. Pre-authenticate the request if we have valid auth credentials"

	redirections := Dictionary new.

	["The outer loop handles redirections"
	repeatRedirect := false.

	"Always update the host header due to redirect"
	request headerAt: 'Host' put: server.

		["The inner loop handles authentication"
		repeatAuth := false.

		"Connect can fail if SSL proxy CONNECT is involved"
		self connect ifNotNil:[:resp| ^resp].
		
		"Write the request to the debugLog if present"
		debugLog ifNotNil:[self writeRequest: request on: debugLog].

		"Send the request itself"
		self writeRequest: request on: stream.
		contentBlock value: stream.

		response := request newResponse readFrom: stream.
		response url: (scheme, '://', server, request rawUrl).

		debugLog ifNotNil:[
			response writeOn: debugLog.
			debugLog flush.
		].
		response setCookiesDo:[:cookie| 
			self acceptCookie: cookie host: self serverName path: request url.
		].
		accessLog ifNotNil:[
			WebUtils logRequest: request response: response on: accessLog
		].
		"Handle authentication if needed"
		(self allowAuth and:[response code = 401 or:[response code = 407]]) ifTrue:[
			"Eat up the content of the previous response"
			response content.
			repeatAuth := self authenticate: request from: response.
		].

		repeatAuth] whileTrue.

	"Flush previous authState.
	XXXX: Fixme. authState must be preserved for pre-authentication of requests."
	self flushAuthState.

	"Handle redirect if needed"
	(self allowRedirect and:[response isRedirect]) ifTrue:[
		"Eat up the content of the previous response"
		response content.
		repeatRedirect := self redirect: request from: response.
	].
	repeatRedirect] whileTrue:[
		"When redirecting, remove authentication headers"
		request removeHeader: 'Authorization'.
		request removeHeader: 'Proxy-Authorization'.
	].

	"If the response is not a success, eat up its content"
	(response isSuccess or:[response isInformational]) ifFalse:[response content].

	^response! !
!WebClient methodsFor: 'sending' stamp: 'ar 8/12/2010 21:37'!
writeCookiesFor: request on: aStream
	"Write the cookies for a particular request"

	(cookies select:[:ck| (request acceptsCookie: ck from: self )]) ifNotEmpty:[:ckset|
		aStream nextPutAll: 'Cookie: '.
		ckset 
			do:[:ck| aStream nextPutAll: ck name,'=', ck value]
			separatedBy:[aStream  nextPutAll:'; '].
		aStream crlf.
	].
! !
!WebClient methodsFor: 'sending' stamp: 'DSG 5/24/2012 17:24'!
writeHeadersFor: request on: aStream
	"Write all the headers for the given request on aStream"

	request headersDo:[:key :value| aStream nextPutAll: key, ': ', value asString; nextPutAll: String crlfString].
! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:43:55'!
writeRequest: request on: aStream
	"Write all the request headers on the given stream"

	self retryOnce: [
		self writeRequestLine: request on: aStream.
		self writeHeadersFor: request on: aStream.
		self writeCookiesFor: request on: aStream.
		aStream crlf.
		aStream flush].! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:37:08'!
writeRequestLine: request on: aStream
	"Write the HTTP request line on the given stream"

	aStream nextPutAll: request method; space.

	"https proxy support is transparent via CONNECT"
	(proxyServer notNil and:[scheme ~= 'https']) ifTrue:[
		"http://www.ietf.org/rfc/rfc2616.txt 
		5.1.2 Request-URI:
			...
		The absoluteURI form is REQUIRED when the request is being made to a
		proxy. The proxy is requested to forward the request or service it
		from a valid cache, and return the response. Note that the proxy MAY
		forward the request on to another proxy or directly to the server"
		aStream nextPutAll: scheme, '://', self server.

		"XXXX: This is a hack. Indicate that we want the proxy connection 
		to be persistent. This should NOT be necessary; the proxy should
		know that from the HTTP/1.1 request but apparently, squid will fail 
		NTLM and Negotiate authentication unless explicitly instructed to 
		keep the proxy connection alive."
		request headerAt: 'Proxy-Connection' put: 'keep-alive'.
	].

	aStream nextPutAll: request rawUrl; space; nextPutAll: request protocol; nextPutAll: String crlfString.! !
!WebClient methodsFor: 'initialize' stamp: 'topa 6/17/2016 20:59'!
close
	"Close the client's stream"

	stream ifNotNil:[
		stream isConnected ifTrue: [stream close].
		stream := nil].
! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:24:01'!
connect
	"Connect the client to a web server. Returns nil if successful,
	a WebResponse if a proxy CONNECT request fails."

	| actualServer actualPort |

	"Determine which server to connect to (proxy or real)"
	proxyServer ifNil:[
		actualServer := self serverName.
		actualPort := self serverPort.
	] ifNotNil:[
		actualServer := self proxyServerName.
		actualPort := self proxyServerPort.
	].

	"Check if we can use the same stream or if we need to reconnect"
	(stream notNil
		and:[stream isConnected
		and:[lastServer = actualServer
		and:[lastPort = actualPort
		and:[lastScheme = scheme]]]]) ifTrue:[^nil].

	self close.
	lastServer := actualServer.
	lastPort := actualPort.
	lastScheme := scheme.
	stream := SocketStream openConnectionToHostNamed: lastServer port: lastPort.
	stream timeout: timeout.
	"Perform ssl initialization if necessary"
	scheme = 'https' ifTrue:[self retryOnce: [^self sslConnect]].
	^nil! !
!WebClient methodsFor: 'initialize' stamp: 'ar 7/21/2010 21:12'!
defaultPort
	"Return the default port to use if no port was specified.
	Since we only support https and http, default to port 80 unless https."

	^scheme = 'https' 
		ifTrue:[443]
		ifFalse:[80]! !
!WebClient methodsFor: 'initialize' stamp: 'ar 2/12/2012 21:03'!
defaultUserAgent
	"Answer the default User-Agent string to use for WebClient"

	^'WebClient/1.5 (', 
		WebUtils mcVersion, '; ', 
		SystemVersion current version,'-', 
		SystemVersion current highestUpdate printString, '; ', 
		WebUtils platformName,')'.
! !
!WebClient methodsFor: 'initialize' stamp: 'ul 7/28/2016 18:09'!
destroy
	"Destroys the client"

	stream ifNotNil:[
		stream destroy.
		stream := nil.
	].
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 3/27/2010 11:59'!
detectProxyServer
	"Automatically detect the proxy server to use"

	proxyServer := ProxyHandler proxyServerFor: self server.
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 4/1/2010 18:51'!
flushAuthState
	"Flush all the auth state"

	self flushAuthState: authParams.
	self flushAuthState: proxyParams.! !
!WebClient methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:33' overrides: 16920235!
initialize
	"Initializes the receiver"
	flags := 0.
	super initialize.

	self allowAuth: true.
	self allowRedirect: true.
	self acceptCookies: true.

	timeout := Socket standardTimeout.
	cookies := OrderedCollection new.
	redirections := Dictionary new.
	maxRedirect := 10.
	userAgent := self defaultUserAgent.
	authParams := IdentityDictionary new.
	proxyParams := IdentityDictionary new.

	"Use the default debug log"
	debugLog := DebugLog.
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 7/25/2010 15:36'!
initializeFromUrl: urlString
	"Initialize the client from a url string"

	| urlStream serverAndPort userAndPass |
	urlStream := urlString readStream.
	scheme := (urlStream upToAll: '://') asLowercase.
	(scheme = 'http' or:[scheme = 'https'])
		ifFalse:[self error: 'Unsupported scheme: ', scheme].
	serverAndPort := urlStream upTo: $/.

	userAndPass := serverAndPort copyUpTo: $@.
	userAndPass = serverAndPort ifFalse:[
		serverAndPort := serverAndPort copyAfter: $@.
		self username: (userAndPass copyUpTo: $:).
		self password: (userAndPass copyAfter: $:).
	].

	self server: serverAndPort.
	self detectProxyServer.! !
!WebClient methodsFor: 'initialize' stamp: 'ar 8/9/2010 08:30'!
newRequest
	"Create an return a new WebRequest.
	Subclasses can use this method to override the default request class."

	^WebRequest new! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:59:44'!
proxyConnect
	"Send a proxy CONNECT request to connect to a remote host via the chosen proxy server"

	| uri request repeatAuth response |
	uri := self serverName,':', self serverPort asString.
	request := self newRequest.
	request method: 'CONNECT'.
	request rawUrl: uri.

	[repeatAuth := false.

	"The proxy response may use Connection: Close; reconnect when that happens"
	self isConnected ifFalse:[
		stream := SocketStream openConnectionToHostNamed: lastServer port: lastPort.
		stream timeout: timeout.
	].

	debugLog ifNotNil:[
		request writeOn: debugLog.
		debugLog flush.
	].

	"Don't use 'self writeRequestOn:' since this will insert both cookies
	as well as modify the url target when a proxy is present"
	request writeOn: stream.
	
	stream flush.

	response := request newResponse readFrom: stream.

	debugLog ifNotNil:[
		response writeOn: debugLog.
		debugLog flush.
	].

	"Handle authentication if needed"
	(self allowAuth and:[response code = 407]) ifTrue:[
		"Eat up the content of the previous response"
		response content.
		repeatAuth := self authenticate: request from: response.
	].
	repeatAuth] whileTrue.

	^response! !
!WebClient methodsFor: 'initialize' stamp: 'ar 9/4/2010 11:10'!
requestWithUrl: urlString
	"Create and return a new WebRequest initialized with the given url."

	^self  newRequest initializeFromUrl: urlString! !
!WebClient methodsFor: 'initialize' stamp: 'topa 11/4/2014 00:13'!
retryOnce: aTryBlock
	" Retry the block once if it failes,
	except for direct network errors.
	This can help in cases like temporary failing
	SqueakSSL primitives"
	| again |
	again := true.
	[^ aTryBlock value.
	] on: Error do: [:e |
		((e isKindOf: NetworkError) or: [again not])
			ifTrue: [e pass]
			ifFalse: [again := false. e retry]].! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:25:04'!
sslConnect
	"Do the SSL handshake"
	"Connect the client to a web server"

	| sqSSL |
	proxyServer ifNotNil:[ | resp |
		"If we have a proxy server, do the proxy connect"
		resp := self proxyConnect.
		resp isSuccess ifFalse:[^resp].
	].

	sqSSL := Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL is missing'].
	"Convert the stream to a secure stream"
	stream := sqSSL secureSocketStream on: stream socket.
	stream timeout: timeout.
	self sslConnect: stream to: lastServer.
	"And cert verification
	(unless on OSX, where this does not work yet)"
	WebUtils platformName = 'Mac OS'
		ifFalse: [stream verifyCert: self serverName].
	^ nil"indicating success"
! !
!WebClient methodsFor: 'initialize' stamp: 'jmv 3/18/2019 13:15:39'!
sslConnect: aStream to: aLastServer
	"Do the SSL handshake, use SNI if available"
	(aStream respondsTo: #sslConnectTo:)
		ifTrue: [aStream sslConnectTo: aLastServer]
		ifFalse: [aStream sslConnect].! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:04'!
httpDelete: urlString
	"Sends an DELETE request"

	^self httpDelete: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06'!
httpDelete: urlString do: aBlock
	"Sends a DELETE request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'DELETE'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request.! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:57'!
httpGet: urlString
	"GET the response from the given url"
	"(WebClient httpGet: 'http://www.squeak.org') content"

	^self httpGet: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'CK 11/24/2017 14:46:24'!
httpGet: urlString do: aBlock
	"GET the response from the given url
	(WebClient httpGet: 'http://www.cuis-smalltalk.org/') content
	"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'GET'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	request headerAt: 'Accept-Encoding' put: 'gzip'.
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05'!
httpHead: urlString
	"Sends a HEAD request"

	^self httpHead: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06'!
httpHead: urlString do: aBlock
	"Sends a HEAD request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'HEAD'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request.! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05'!
httpOptions: urlString
	"Sends an OPTIONS request"

	^self httpOptions: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06'!
httpOptions: urlString do: aBlock
	"Sends an OPTIONS request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'OPTIONS'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:56'!
httpPost: urlString content: postData type: contentType
	"POST the data to the given url"

	^self httpPost: urlString content: postData type: contentType do:[:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07'!
httpPost: urlString content: postData type: contentType do: aBlock
	"POST the data to the given url"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'POST'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Content-Length' put: postData size.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request content: postData readStream size: postData size! !
!WebClient methodsFor: 'methods' stamp: 'ar 8/31/2010 22:54'!
httpPostChunked: urlString content: chunkBlock type: contentType
	"POST the data to the given url using chunked transfer-encoding.
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent.

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	^self httpPostChunked: urlString content: chunkBlock type: contentType do: [:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07'!
httpPostChunked: urlString content: chunkBlock type: contentType do: aBlock
	"POST the data to the given url using chunked transfer-encoding. 
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent. 

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'POST'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Transfer-Encoding' put: 'chunked'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	"Send the chunked data"
	^self sendRequest: request contentBlock:[:aStream| 
		"Set the stream in the request and pass it in the chunk block"
		request stream: aStream.
		chunkBlock value: request.
		"send termination chunk"
		aStream nextPutAll: '0'; crlf; crlf; flush.
	].
! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:57'!
httpPut: urlString content: postData type: contentType
	"PUT the data to the given url"

	^self httpPut: urlString content: postData type: contentType do:[:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07'!
httpPut: urlString content: postData type: contentType do: aBlock
	"PUT the data to the given url"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'PUT'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Content-Length' put: postData size.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request content: postData readStream size: postData size! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05'!
httpTrace: urlString
	"Sends a TRACE request"

	^self httpTrace: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:08'!
httpTrace: urlString do: aBlock
	"Sends a TRACE request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'TRACE'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'testing' stamp: 'ar 3/30/2010 19:18'!
isConnected
	"Returns true if the client is still connected"

	^stream notNil and:[stream isConnected]! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/10/2012 13:12'!
proxyParams
	"The proxy authentication parameters"

	^proxyParams! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/10/2012 13:12'!
proxyParams: aDictionary
	"The proxy authentication parameters"

	proxyParams := aDictionary! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:04'!
proxyPass
	"The password for an authenticating proxy.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^proxyParams at: #password! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:04'!
proxyPass: aStringOrValuable
	"The password for an authenticating proxy.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	proxyParams at: #password put: aStringOrValuable! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:17'!
proxyServer
	"The proxy server to use for connections.
	The server should be specified as server:port if the proxy
	port to be used is different from the desitation port."

	^proxyServer! !
!WebClient methodsFor: 'proxy' stamp: 'CK 11/24/2017 14:01:01'!
proxyServer: aString
	"The proxy server to use for connections.
	The server should be specified as server:port if the proxy
	port to be used is different from the desitation port."

	proxyServer := aString.
	ProxyHandler defaultProxyServer: aString.! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:22'!
proxyServerName
	"Returns the name part of the server:port description"

	^proxyServer copyUpTo: $:! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:21'!
proxyServerPort
	"Returns the port of the proxyServer:port description"

	^(proxyServer copyAfter: $:) 
		ifEmpty:[self serverPort]
		ifNotEmpty:[:portString| portString asInteger].
! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:02'!
proxyUser
	"The user name for an authenticating proxy"

	^proxyParams at: #username ifAbsent:[nil]! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:02'!
proxyUser: aString
	"The user name for an authenticating proxy"

	proxyParams at: #username put: aString! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:20'!
debugLog
	"The default debugLog, if any:
		WebClient debugLog: Transcript.
		WebClient debugLog: nil.
	"

	^DebugLog! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:20'!
debugLog: aStream
	"The default debugLog, if any:
		WebClient debugLog: Transcript.
		WebClient debugLog: nil.
	"

	DebugLog := aStream.! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 2/23/2010 22:26'!
proxyHandler
	"The currently registered proxy handler"

	^ProxyHandler! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 2/23/2010 22:26'!
proxyHandler: anObject
	"The currently registered proxy handler"

	ProxyHandler := anObject! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 6/1/2010 20:24'!
htmlSubmit: urlString fields: fieldMap
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			}
	"
	^self htmlSubmit: urlString 
			fields: fieldMap
			method: 'GET'
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 6/1/2010 20:24'!
htmlSubmit: urlString fields: fieldMap method: method
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			} method: 'GET'
	"
	^self htmlSubmit: urlString 
			fields: fieldMap
			method: method
			encoding: 'application/x-www-form-urlencoded'
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 7/20/2010 20:10'!
htmlSubmit: urlString fields: fields method: method encoding: encoding
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			} method: 'GET'
			encoding: 'application/x-www-form-urlencoded'
	"

	method = 'GET' ifTrue:[
		"GET only supports url encoded requests"
		encoding = 'application/x-www-form-urlencoded' 
			ifFalse:[^self error: 'Unsupported encoding: ', encoding].
		^self httpGet: urlString, '?', (WebUtils encodeUrlEncodedForm: fields).
	].

	method = 'POST' ifTrue:[
		"Dispatch on encoding type"
		encoding caseOf: {
			[ 'application/x-www-form-urlencoded'] -> [
				^self httpPost: urlString
					content: (WebUtils encodeUrlEncodedForm: fields)
					type: encoding.
			].
			['multipart/form-data'] -> [
				^self httpPost: urlString multipartFields: fields
			].
		} otherwise:[]
	].

	self error: 'Unsupported method: ', method.
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 7/20/2010 20:09'!
httpPost: url multipartFields: fieldMap
	"Make a form submission using multipart/form-data POST.

	The fieldMap may contain MIMEDocument instances to indicate the presence
	of a file to upload to the server. If the MIMEDocument is present, its
	content type and file name will be used for the upload.

	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	| boundary |
	boundary := WebUtils multipartBoundary.

	^self httpPost: url 
		content: (WebUtils encodeMultipartForm: fieldMap boundary: boundary) 
		type: 'multipart/form-data; boundary=', boundary! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:30'!
httpDelete: urlString
	"Sends a DELETE request"
	"WebClient httpDelete: 'http://ftp.squeak.org/trunk'"

	^self httpDo:[:client| client httpDelete: urlString].
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:29'!
httpDo: aBlock
	"Simplified wrapper for running various methods"

	| client response |
	client := self new.
	response := WebUtils handleAuth: [aBlock value: client].
	response content; close.
	^response! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:30'!
httpGet: urlString
	"Get the response from the given url"
	"(WebClient httpGet: 'http://www.squeak.org') content"

	^self httpDo:[:client| client httpGet: urlString].! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31'!
httpHead: urlString
	"Sends a HEAD request"
	"WebClient httpHead: 'http://ftp.squeak.org/trunk'"

	^self httpDo:[:client| client httpHead: urlString].
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31'!
httpOptions: urlString
	"Sends an OPTIONS request"
	"WebClient httpOptions: 'http://ftp.squeak.org/*'"
	"WebClient httpOptions: 'http://ftp.squeak.org/4.1/Squeak4.1.zip'"

	^self httpDo:[:client| client httpOptions: urlString]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31'!
httpPost: urlString content: postData type: contentType
	"Fire off an HTTP post request"

	^self httpDo:[:client| client httpPost: urlString content: postData type: contentType]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31'!
httpPostChunked: urlString content: chunkBlock type: contentType
	"POST the data to the given url using chunked transfer-encoding.
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent.

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	^self httpDo:[:client| 
		client httpPostChunked: urlString content: chunkBlock type: contentType]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:32'!
httpPut: urlString content: postData type: contentType
	"Fire off an HTTP PUT request"

	^self httpDo:[:client| client httpPut: urlString content: postData type: contentType]! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:32'!
httpTrace: urlString
	"Sends a TRACE request"
	"(WebClient httpTrace: 'http://lists.squeakfoundation.org') content"
	"(WebClient httpTrace: 'http://ftp.squeak.org/trunk') content"

	^self httpDo:[:client| client httpTrace: urlString]! !
!WebClient class methodsFor: 'class initialization' stamp: 'jmv 6/26/2017 19:16:36' overrides: 16904184!
initialize
	"WebClient initialize"

	FlagAcceptCookies := 1.
	FlagAllowAuth := 2.
	FlagAllowRedirect := 4.

	"Default proxy handler"
	ProxyHandler := WebUtils! !
!WebClient class methodsFor: 'benchmark' stamp: 'jmv 6/25/2017 20:07:19'!
requestBenchmark: url persistent: aBool
	"Run a WebClient benchmark to measure request handling speed.
	Try using a persistent connection if requested.

	1) Launch WebServer  (or Seaside, or whatever):
	
		(WebServer reset default)
			listenOn: 8888;
			addService: '/' action:[:r| r send200Response: ''].

	2) Run the benchmark:

		MessageTally spyOn:[
			WebClient requestBenchmark: 'http://localhost:8888/' persistent: true.
		]
	"

	| time resp startTime endTime count client |
	count := 0.
	client := WebClient new.
	startTime := Time localMillisecondClock.
	[endTime := Time localMillisecondClock.
	(time := endTime - startTime) < 5000] whileTrue:[
		resp := client httpGet: url.
		resp isSuccess ifFalse:[self error: resp status].
		resp content.
		aBool ifFalse:[resp close].
		count := count + 1.
	].
	^(count  * 1000 // time) printStringWithCommas, ' requests/sec'! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39'!
webSocket00: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	| key1 key2 bytes hash client req resp |
	"Fixed keys from spec"
	key1 := 155712099.
	key2 := 173347027.
	bytes := ByteArray new: 8.
	(1 to: bytes size) do:[:i| bytes at: i put: (256 atRandom - 1)].
	hash := WebUtils webSocketHandshake: key1 with: key2 with: bytes.

	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'Sec-WebSocket-Protocol' put: protocol].
	req headerAt: 'Sec-WebSocket-Key1' put: '18x 6]8vM;54 *(5:  {   U1]8  z [  8'.
	req headerAt: 'Sec-WebSocket-Key2' put: '1_ tx7X d  <  nw  334J702) 7]o}` 0'.
	resp := client sendRequest: req content: bytes readStream size: bytes size.
	resp code = 101 ifFalse:[client close. ^nil].
	(resp stream next: 16) asByteArray = hash ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket00 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39'!
webSocket07: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"
	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07"

	| hash client req resp nonce |
	nonce := ByteArray new: 16.
	(1 to: nonce size) collect:[:i| nonce at: i put: (256 atRandom - 1)].
	nonce := nonce base64Encoded.

	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Sec-WebSocket-Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'Sec-WebSocket-Protocol' put: protocol].
	req headerAt: 'Sec-WebSocket-Key' put: nonce.
	req headerAt: 'Sec-WebSocket-Version' put: '7'.

	resp := client sendRequest: req.
	resp code = 101 ifFalse:[client close. ^nil].

	"Verify WebSocket hash"
	hash := WebUtils webSocketHash07: nonce.
	hash = (resp headerAt: 'Sec-WebSocket-Accept') ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket07 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39'!
webSocket68: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	| client req resp |
	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'WebSocket-Protocol' put: protocol].
	resp := client sendRequest: req.
	resp code = 101 ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket00 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 7/9/2010 00:37'!
webSocketTo: serverUrl
	"Attempt to connect to the given server url using the WebSocket api"

	"Testing:

		1) Launch WebSocket example.
		2) Run the following code:
		
		| ws |
		ws := WebClient webSocketTo: 'http://localhost:8080/broadcast'.
		ws onMessage:[:data| Transcript cr; show: data].
		ws fork.
		ws send: 'This is the first message'.
		ws send: 'This is the last message'.
		ws close.

	"

	^self webSocketTo: serverUrl protocol: nil! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 7/9/2010 00:31'!
webSocketTo: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	^self webSocket00: serverUrl protocol: protocol! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:22'!
comment
	"Cookie comment"

	^comment! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:22'!
comment: aString
	"Cookie comment"

	comment := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
domain
	"Cookie domain"

	^domain! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
domain: aString
	"Cookie domain"

	domain := aString.! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:06'!
expiry
	"The expiry DateAndTime"

	^expiry! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:06'!
expiry: aDateAndTime
	"The expiry DateAndTime"

	expiry := aDateAndTime ifNotNil:[:dt| dt asUTC].! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:21'!
expirySeconds: maxAge
	"Compute the cookie's expiry age from the given number of seconds"

	maxAge = 0 ifTrue:[self expiry: DateAndTime new].
	self expiry: DateAndTime now + maxAge seconds.! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 3/31/2010 08:38'!
httpOnly
	"If the cookie should be httpOnly (not scriptable).
	See http://msdn2.microsoft.com/en-us/library/ms533046.aspx"

	^httpOnly! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 3/31/2010 08:38'!
httpOnly: aBool
	"If the cookie should be httpOnly (not scriptable).
	See http://msdn2.microsoft.com/en-us/library/ms533046.aspx"

	httpOnly := aBool! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' overrides: 16903442!
name
	"The name of the cookie"

	^name! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
name: aString
	"The name of the cookie"

	name := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
path
	"Cookie path"

	^path! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
path: aString
	"Cookie path"

	path := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
secure
	"Secure cookie flag"

	^secure! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05'!
secure: aBool
	"Secure cookie flag"

	secure := aBool! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' overrides: 16902254!
value
	"The value of the cookie"

	^value! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06'!
value: aString
	"The value of the cookie"

	value := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06'!
version
	"Cookie version"

	^version! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06'!
version: aString
	"Cookie version"

	version := aString! !
!WebCookie methodsFor: 'printing' stamp: 'jmv 6/25/2017 19:15:34' overrides: 16902975!
printOn: aStream
	"Creates the string representation for this cookie"

	aStream nextPutAll: name, '=', value asString.
	expiry ifNotNil:[ 
		aStream nextPutAll:'; expires='.
		aStream nextPutAll: expiry dayOfWeekName ,  ', '.
		expiry date printOn: aStream format: #(1 2 3 $- 2 2 2 ).
		aStream nextPutAll: ' ', expiry time print24,' GMT'.
	].
	path ifNotNil:[
		aStream nextPutAll:'; path=', (WebUtils quote: path).
	].
	domain ifNotNil:[
		aStream nextPutAll:'; domain=', (WebUtils quote: domain).
	].
	version ifNotNil:[
		aStream nextPutAll:'; version=', version asString.
	].
	secure ifTrue:[
		aStream nextPutAll: '; secure'.
	].
	httpOnly ifTrue:[
		aStream nextPutAll: '; HttpOnly'.
	].
! !
!WebCookie methodsFor: 'comparing' stamp: 'ar 5/11/2010 08:58' overrides: 16901772!
= aCookie
	"Compare the receiver with aCookie"

	^aCookie class == self class 
		and:[aCookie name = self name
		and:[aCookie domain = self domain
		and:[aCookie path = self path]]].! !
!WebCookie methodsFor: 'comparing' stamp: 'ar 5/11/2010 08:59' overrides: 16901788!
hash
	"Hash is re-implemented because #= is re-implemented"

	^name hash + domain hash + path hash.! !
!WebCookie methodsFor: 'converting' stamp: 'ar 2/20/2010 11:06' overrides: 16901837!
asString
	"Create the string representation for this cookie"

	^String streamContents:[:s| self printOn: s].! !
!WebCookie methodsFor: 'initialize' stamp: 'ar 3/31/2010 08:40' overrides: 16920235!
initialize
	"Initializes the receiver"
	super initialize.
	secure := false.
	httpOnly := false.
! !
!WebCookie methodsFor: 'initialize' stamp: 'DSG 3/28/2015 16:36'!
readExpiryFrom: aString
	"Read a cookie expiry date from the given string.
	The expiration date is specified in the 'Wdy, DD-Mon-YYYY HH:MM:SS GMT' format."
	
	| tokens |
	^[
		tokens := aString withBlanksTrimmed.
		(tokens copyAfterLast: Character space) = 'GMT'
			ifFalse:[^DateAndTime new].
		tokens := (tokens copyAfter: Character space) copyUpToLast: Character space.
		(DateAndTime readFrom: tokens readStream) utcOffset: Duration zero.
	] on: Error do:[:ex| ex return: DateAndTime new].! !
!WebCookie methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:38'!
readFrom: aStream
	"Read a cookie from the given stream"

	| keyval key val |
	aStream skipSeparators.
	name := (aStream upTo: $=) withBlanksTrimmed.
	value := (aStream upTo: $;) withBlanksTrimmed.
	[aStream atEnd] whileFalse:[
		keyval := aStream upTo: $;.
		key := (keyval copyUpTo: $=) withBlanksTrimmed.
		val := (keyval copyAfter: $=) withBlanksTrimmed.
		key asLowercase caseOf: {
			['expires'] 	-> [self expiry: (self readExpiryFrom: val)].
			['path']		-> [self path: (WebUtils unquote: val)].
			['domain'] 	-> [self domain: (WebUtils unquote: val)].
			['secure'] 	-> [self secure: true].
			['version'] 	-> [self version: val].
			['httponly'] 	-> [self httpOnly: true].
			['comment']	 ->[self comment: val].
			['max-age']	->[self expirySeconds: val asNumber].
		} otherwise:[Transcript log: 'Unknown cookie field: ', key].
	].! !
!WebCookie methodsFor: 'testing' stamp: 'ar 5/11/2010 20:06'!
isExpired
	"Return true if this cookie is expired"
	
	expiry ifNil:[^false].
	^expiry asUTC < DateAndTime now asUTC! !
!WebMessage methodsFor: 'printing' stamp: 'ar 2/20/2010 11:05' overrides: 16902975!
printOn: aStream
	"Prints the receiver"

	aStream nextPutAll: self class name.
	aStream nextPut: $(.
	self writeOn: aStream.
	aStream nextPut: $).! !
!WebMessage methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:38'!
writeHeadersOn: aStream
	"Write the request"

	self headersDo:[:key :value| aStream nextPutAll: key, ': ', value asString; nextPutAll: String crlfString].
! !
!WebMessage methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:38'!
writeOn: aStream
	"Write the request"

	self writeHeadersOn: aStream.
	aStream nextPutAll: String crlfString.
! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 16:31'!
addHeader: key value: value
	"Adds an ADDITIONAL header for the given key"

	headers add: key -> value.! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:02'!
headerAt: key
	"Answers a single value for the given http header. 
	Do not use for headers that may appear multiple times, such at www-authenticate."

	^self headerAt: key ifAbsent:[''].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03'!
headerAt: key ifAbsent: aBlock
	"Answers a single value for the given http header. 
	Do not use for headers that may appear multiple times, such at www-authenticate."

	self headersAt: key do:[:value| ^value].
	^aBlock value! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 12:18'!
headerAt: key put: value
	"Sets the value of a header, adding if necessary"

	headers do:[:assoc|
		(assoc key sameAs: key) ifTrue:[
			assoc value: value.
			^self
		].
	].
	self addHeader: key value: value.! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03'!
headersAt: key
	"Answers a collection of values for the given http header. 
	Use for headers that may appear multiple times, such at www-authenticate."

	^self headersAt: key ifAbsent:[#()].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03'!
headersAt: aKey do: aBlock
	"Evaluate aBlock with all the headers matching aKey"

	self headersDo:[:key :value|
		(aKey sameAs: key) ifTrue:[ aBlock value: value].
	].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03'!
headersAt: key ifAbsent: aBlock
	"Answers a collection of values for the given http header. 
	Use for headers that may appear multiple times, such at www-authenticate."

	| hdrs |
	hdrs := OrderedCollection new.
	self headersAt: key do:[:value| hdrs add: value].
	^hdrs asArray ifEmpty:[aBlock value]
! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03'!
headersDo: aBlock
	"Evaluate aBlock with all of the headers key-value pairs"

	headers do:[:assoc|
		aBlock value: assoc key value: assoc value.
	].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 3/26/2010 19:02'!
removeHeader: key
	"Removes ALL headers with the given key"

	headers := headers reject:[:assoc| assoc key sameAs: key].
! !
!WebMessage methodsFor: 'converting' stamp: 'ar 2/23/2010 09:02' overrides: 16901837!
asString
	"Prints the receiver"

	^String streamContents:[:s| self writeOn: s].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 2/2/2012 15:55'!
chunkFrom: srcStream to: dstStream progress: progressBlock
	"Stream the content of srcStream to dstStream.
	Use chunked transfer-encoding."

	| chunkSize firstLine buffer totalRead |
	totalRead := 0.
	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new.
	[firstLine := srcStream nextLine asString.
	chunkSize := ('16r',firstLine asUppercase) asNumber.
	chunkSize = 0] whileFalse:[
		progressBlock ifNotNil:[progressBlock value: nil value: totalRead].
		buffer size = chunkSize ifFalse:[buffer := buffer class new: chunkSize].
		buffer := srcStream next: chunkSize into: buffer startingAt: 1.
		dstStream nextPutAll: buffer.
		srcStream skip: 2. "CRLF"
		totalRead := totalRead + chunkSize.
	].
	srcStream skip: 2. "CRLF"
	dstStream flush.
	progressBlock ifNotNil:[progressBlock value: nil value: totalRead].! !
!WebMessage methodsFor: 'streaming' stamp: 'DSG 3/29/2015 09:10'!
nextChunk
	"Answer the next chunk from a message using chunked transfer encoding."

	| chunkSize chunk |
	chunkSize := Integer readFrom: (stream upToAll: String crlfString) readStream base: 16.
	chunkSize = 0 ifFalse:[chunk := stream next: chunkSize].
	stream skip: 2. "CrLf"
	^chunk! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 8/31/2010 22:57'!
nextChunkPut: chunk
	"Send the next chunk of a message using chunked transfer encoding.

	Note: This method does not allow to send empty chunks to avoid accidentally
	terminating the chunked transfer. Ending the transfer is part of the chunked
	request/response protocol (see #httpPostChunked:encoded:content:type:do:
	as well as #sendResponse:chunked:do:)"

	chunk ifNotEmpty:[
		stream nextPutAll: (chunk size printStringBase: 16); crlf.
		stream nextPutAll: chunk; crlf; flush.
	].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 5/4/2010 15:44'!
streamFrom: srcStream size: size progress: aBlock
	"Stream the given source stream to the message's socket stream.
	Outbound. Can be used on both request/response depending on
	whether it is utilized by WebClient or WebServer."

	^self streamFrom: srcStream to: stream size: size progress: aBlock! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 7/10/2010 13:51'!
streamFrom: srcStream to: dstStream size: sizeOrNil progress: progressBlock
	"Stream the content of srcStream to dstStream.
	If a size is given, stream that many elements, otherwise stream up to the end."

	| buffer totalRead remaining size |
	(self headerAt: 'transfer-encoding') ifNotEmpty:[:encoding|
		encoding = 'chunked' 
			ifTrue:[^self chunkFrom: srcStream to: dstStream progress: progressBlock]
			ifFalse:[self error: 'Unknown transfer-encoding: ', encoding]].

	sizeOrNil = 0 ifTrue:[^self].

	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new: 4096.
	totalRead := 0.
	size := sizeOrNil ifNil:[0].
	[(sizeOrNil == nil and:[stream atEnd not]) or:[totalRead < size]] whileTrue:[
		progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].
		remaining := sizeOrNil ifNil:[99999] ifNotNil:[sizeOrNil - totalRead].
		remaining > buffer size ifTrue:[remaining := buffer size].
		buffer := srcStream next: remaining into: buffer startingAt: 1.
		dstStream nextPutAll: (remaining < buffer size  
			ifTrue:[(buffer copyFrom: 1 to: remaining)]
			ifFalse:[buffer]).
		totalRead := totalRead + buffer size.
	].
	dstStream flush.
	progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 5/4/2010 15:46'!
streamTo: dstStream size: size progress: aBlock
	"Stream from the receiver's socket stream to the given destination stream.
	Inbound. Can be used on both request/response depending on
	whether it is utilized by WebClient or WebServer."
	content ifNil:[
		self streamFrom: stream to: dstStream size: size progress: aBlock
	] ifNotNil:[
		self streamFrom: content readStream to: dstStream size: size progress: aBlock
	].! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/4/2010 20:02'!
close
	"Always closes regardless of connection header"

	stream ifNotNil:[stream close].! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/6/2010 20:47'!
closeIfTransient
	"Close the underlying connection if it's not persistent"

	self isPersistent ifFalse:[self close].
! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/4/2010 20:02'!
destroy
	"Destroys the underlying stream"

	stream ifNotNil:[stream destroy].! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 6/18/2010 23:52'!
content
	"Reads and caches available content and returns it."

	^content ifNil:[content := self getContent].
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 3/30/2010 22:05'!
content: aString
	"Sets content for a response"

	content := aString.! !
!WebMessage methodsFor: 'accessing' stamp: 'tsl 1/18/2021 11:17:47'!
contentLength
	"Answers the numeric value of the Content-Length header, or nil if no header exist"

	^(self headerAt: 'Content-Length' ifAbsent:[^nil]) asNumber! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 5/4/2010 21:04'!
contentLength: aNumber
	"Sets the numeric value of the Content-Length header"

	^self headerAt: 'Content-Length' put: aNumber! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01'!
contentStream
	"Answers a stream for the conent."

	^stream! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:02'!
contentType
	"Answer the content type for the receiver"

	^self headerAt: 'Content-Type' ifAbsent:['application/octet-stream']
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 3/30/2010 21:58'!
contentType: aString
	"Sets the content type for the receiver"

	^self headerAt: 'Content-Type' put: aString! !
!WebMessage methodsFor: 'accessing' stamp: 'ul 4/21/2015 06:40'!
contentWithProgress: progressBlock
	"Reads and caches available content and returns it."

	^content ifNil: [ content := self getContentWithProgress: progressBlock ]! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 7/20/2010 20:09'!
multipartBoundary
	"Answer the boundary of a multipart/form-data message"

	| header |
	header := self headerAt: 'Content-Type' ifAbsent:[^nil].
	(header beginsWith: 'multipart/form-data') ifFalse:[^nil].
	^(header copyFrom: (header findString: 'boundary=') + 9 to: header size)! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 16:31'!
protocol
	"Returns the requested protocol"

	^protocol! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 16:31'!
protocol: aString
	"Returns the requested protocol"

	protocol := aString! !
!WebMessage methodsFor: 'accessing' stamp: 'dtl 7/17/2012 18:59'!
remoteHost
	"Return the name of the remote host"

	| remote |
	(stream isKindOf: SocketStream) ifFalse:[^nil]. "don't have it"
	remote := stream socket remoteAddress.
	^ NetNameResolver stringFromAddress: remote.
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01'!
stream
	"Answers the underlying TCP stream"

	^stream! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01'!
stream: aStream
	"Sets the underlying TCP stream"

	stream := aStream! !
!WebMessage methodsFor: 'private' stamp: 'ul 4/21/2015 06:31'!
getContent
	"Reads available content and returns it."

	^self getContentWithProgress: nil! !
!WebMessage methodsFor: 'private' stamp: 'jmv 6/25/2017 19:43:27'!
getContentWithProgress: progressBlockOrNil
	"Reads available content and returns it."

	| length result |
	length := self contentLength.
	result := (stream isBinary ifTrue:[ ByteArray ] ifFalse: [ String ])
		streamContents: [ :outputStream | 
			self 
				streamFrom: stream
				to: outputStream
				size: length
				progress: progressBlockOrNil ]
		estimatedSize: (length ifNil: [ 1000 ]).
	(self headerAt: 'content-encoding') = 'gzip' ifFalse: [ ^result ].
	^(GZipReadStream on: result) upToEnd! !
!WebMessage methodsFor: 'testing' stamp: 'pmm 6/19/2010 08:05'!
isPersistent
	"Return true if this is a persistent connection"

	"Check for explicit connection headers"
	((self headerAt:'Connection') sameAs: 'close') ifTrue:[^false].
	((self headerAt:'Connection') sameAs: 'keep-alive') ifTrue:[^true].

	"Defaults for various versions"
	(self protocol = 'HTTP/1.0') ifTrue:[^false].
	(self protocol = 'HTTP/1.1') ifTrue:[^true].

	"Assume that later HTTP versions are compatible with 1.1"
	^true! !
!WebMessage class methodsFor: 'class initialization' stamp: 'ar 2/21/2010 09:55' overrides: 16904184!
initialize
	"self initialize"

	StatusCodes := Dictionary newFromPairs:{
		"1xx: Meta status codes"
		100. 	'Continue'.
		101. 	'Switching Protocols'.
		102.	'Processing'.
		"2xx: Success status codes"
		200.	'OK'.
		201.	'Created'.
		202.	'Accepted'.
		203. 	'Non-Authoritative Information'.
		204.	'No Content'.
		205. 	'Reset Content'.
		206.	'Partial Content'.
		207.	'Multi-Status'. 				"WebDav RFC: 2518"
		"3xx: Redirection status codes"
		300.	'Multiple Choices'.
		301.	'Moved Permanently'.
		302.	'Moved Temporarily'.
		303.	'See Other'.
		304.	'Not Modified'.
		305.	'Use Proxy'.
		307.	'Temporary Redirect'.
		"4xx: Client-Side Error status code"
		400.	'Bad Request'.
		401.	'Unauthorized'.
		402.	'Payment Required'.
		403.	'Forbidden'.
		404.	'Not Found'.
		405.	'Method Not Allowed'.
		406.	'Not Acceptable'.
		407.	'Proxy Authentication Required'.
		408.	'Request Timeout'.
		409.	'Conflict'.
		410.	'Gone'.
		411.	'Lenght Required'.
		412.	'Precondition Failed'.
		413.	'Request Entity Too Large'.
		414.	'Request-URI Too Long'.
		415.	'Unsupported Media Type'.
		416.	'Requested Range Not Satisfiable'.
		417.	'Expectation Failed'.
		422.	'Unprocessable Entity'. 		"WebDav RFC: 2518"
		423.	'Locked'. 					"WebDav RFC: 2518"
		424.	'Failed Dependency'. 		"WebDav RFC: 2518"
		"5xx: Server-Side Error status codes"
		500.	'Internal Server Error'.
		501.	'Not Implemented'.
		502.	'Bad Gateway'.
		503.	'Service Unavailable'.
		504.	'Gateway Timeout'.
		505.	'HTTP Version Not Supported'.
		507.	'Insufficient Storage'. 		"WebDav RFC: 2518"
	}.! !
!WebMessage class methodsFor: 'utilities' stamp: 'klub 1/14/2014 22:09'!
statusCodeAt: code
	"Return the textual description of a status code"

	^StatusCodes at: code ifAbsent: [ 'Unknown error' ]! !
!WebRequest methodsFor: 'testing' stamp: 'ar 8/5/2010 19:51'!
acceptsCookie: aCookie from: webClient
	"Returns true if this cookie is applicable to this request"

	aCookie domain ifNotNil:[:domain|
		(webClient serverName endsWith: domain) ifFalse:[^false].
	].
	aCookie path ifNotNil:[:path|
		(self url beginsWith: path) ifFalse:[^false].
	].
	aCookie secure ifNotNil:[:secure|
		secure ifTrue:[webClient scheme = 'https' ifFalse:[^false]].
	].
	aCookie expiry ifNotNil:[:expiry|
		aCookie isExpired ifTrue:[^false].
	].
	^true! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18'!
isDeleteRequest
	"Returns true if this is an HTTP DELETE request"

	^self method = 'DELETE'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:40'!
isGetRequest
	"Returns true if this is an HTTP GET request"

	^self method = 'GET'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:41'!
isHeadRequest
	"Returns true if this is an HTTP HEAD request"

	^self method = 'HEAD'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:19'!
isOptionsRequest
	"Returns true if this is an HTTP OPTIONS request"

	^self method = 'OPTIONS'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:41'!
isPostRequest
	"Returns true if this is an HTTP POST request"

	^self method = 'POST'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18'!
isPutRequest
	"Returns true if this is an HTTP PUT request"

	^self method = 'PUT'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18'!
isTraceRequest
	"Returns true if this is an HTTP TRACE request"

	^self method = 'TRACE'! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:25'!
asWebSocket
	"Convert this request into a WebSocket"

	"Figure out the version of the protocol"
	| field version |
	version := self headerAt: 'Sec-WebSocket-Version' ifAbsent:[nil].
	version ifNil:[
		field := self headerAt: 'Sec-WebSocket-Key1' ifAbsent:[nil].
		field 
			ifNil:[^self asWebSocket68] 
			ifNotNil:[^self asWebSocket00].
	].

	"Attempt WebSocket07 conversion"
	^self asWebSocket07
! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:39'!
asWebSocket00
	"Convert this request into a WebSocket"

	| field key1 key2 bytes resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	field := self headerAt: 'Sec-WebSocket-Key1'.
	key1 := WebUtils extractWebSocketKey: field.
	field := self headerAt: 'Sec-WebSocket-Key2'.
	key2 := WebUtils extractWebSocketKey: field.
	bytes := WebUtils webSocketHandshake: key1 with: key2 with: (stream next: 8).

	resp headerAt: 'Sec-WebSocket-Origin' put: (self headerAt: 'Origin').
	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.
	].

	resp writeOn: stream.
	bytes ifNotNil:[stream nextPutAll: bytes].
	stream flush.
	^WebSocket00 on: stream.
! !
!WebRequest methodsFor: 'converting' stamp: 'klub 6/13/2012 17:00'!
asWebSocket07
	"Convert this request into a WebSocket"

	| resp hash nonce |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	nonce := self headerAt: 'Sec-WebSocket-Key'.
	hash := WebUtils webSocketHash07: nonce.

	resp headerAt: 'Sec-WebSocket-Accept' put: hash.
	(self headerAt: 'Sec-WebSocket-Origin' ifAbsent: [self headerAt: 'Origin']) 
		ifNotNil: [ :origin | resp headerAt: 'Sec-WebSocket-Origin' put: origin ].
	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.
	].

	resp writeOn: stream.
	stream flush.
	^(WebSocket07 on: stream)
		masking: false;
		yourself.
	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07#section-4.1 says:
   ''Frames sent from the server to the client are not masked.''
	http://tools.ietf.org/html/rfc6455#section-5.1 says: 
   ''A client MUST close a connection if it detects a masked
   frame.''
	So not using masking is compatible with the 07 protocol and is required by RFC 6455."! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:40'!
asWebSocket68
	"Convert this request into a WebSocket"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	resp headerAt: 'WebSocket-Origin' put: (self headerAt: 'Origin').
	resp headerAt: 'WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'WebSocket-Protocol' put: hdr.
	].
	resp writeOn: stream.
	stream flush.
	^WebSocket00 on: stream.! !
!WebRequest methodsFor: 'sending' stamp: 'klub 7/24/2011 19:25'!
closeIfTransient: resp after: aBlock
	"Evaluate aBlock. Close the connection if it is transient.
	Inserts Connection: close header if needed."

	| close |
	close := self isPersistent not.
	close 
		ifTrue: [
			"Always be explicit and insert the Connection: close header"
			resp headerAt: 'Connection' put: 'close' ]
		ifFalse: [
			"We should tell the client that we keep this connection alive."
			resp headerAt: 'Connection' put: 'Keep-Alive' ].
	aBlock value.
	stream flush.
	close  ifTrue:[self close].
! !
!WebRequest methodsFor: 'sending' stamp: 'ar 2/23/2010 22:04'!
sendResponse: resp content: aString
	"Send a WebResponse with content."

	^self sendResponse: resp contentStream: aString readStream size: aString size! !
!WebRequest methodsFor: 'sending' stamp: 'ar 8/31/2010 22:11'!
sendResponse: resp contentBlock: contentBlock
	"Sends a WebResponse, streaming its contents from aStream.
	If a size is provided, insert a Content-Length header, otherwise
	ensure that the connection is transient."

	"Add Date and Server headers"
	resp headerAt: 'Date' put: (server ifNil:[WebServer]) serverDate.
	resp headerAt: 'Server' put: (server ifNil:[WebServer]) serverString.

	self closeIfTransient: resp after:[
		"Ignore all network errors while sending the response"
		[resp writeOn: stream.
		stream flush.
		self isHeadRequest ifFalse:[contentBlock value: stream].
		] on: NetworkError do:["ignore"].

		"Make sure we log before closing the connection"
		server ifNotNil:[server logRequest: self response: resp].
	].! !
!WebRequest methodsFor: 'sending' stamp: 'ar 8/31/2010 22:12'!
sendResponse: resp contentStream: aStream size: streamSize
	"Sends a WebResponse, streaming its contents from aStream.
	If a size is provided, insert a Content-Length header, otherwise
	ensure that the connection is transient."

	streamSize 
		ifNil:[self headerAt: 'Connection' put: 'close'] "mark transient"
		ifNotNil:[resp headerAt: 'Content-Length' put: streamSize].

	^self sendResponse: resp contentBlock:[:sockStream|
		resp streamFrom: aStream to: sockStream size: streamSize progress: nil
	]! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:34'!
cookieAt: aString
	"Answer the value for a cookie with the given name"

	^self cookieAt: aString ifAbsent:['']! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35'!
cookieAt: aString ifAbsent: aBlock
	"Answer the value for a cookie with the given name"

	self cookiesDo:[:name :value| name = aString ifTrue:[^value]].
	^aBlock value! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35'!
cookies
	"Answer all the cookies defined in the request"

	| cookies |
	cookies := Dictionary new.
	self cookiesDo:[:name :value| cookies at: name put: value].
	^cookies! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 8/5/2010 19:56'!
cookiesDo: aBlock
	"Parse the cookie headers and evaluate aBlock with name / value pairs"

	self headersAt: 'Cookie' do:[:hdr|
		(hdr findTokens: ';,') do:[:token|
			aBlock 
				value: (token copyUpTo: $=) withBlanksTrimmed 
				value: (token copyAfter: $=) withBlanksTrimmed]].! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/20/2010 20:08'!
fields
	"Answer the fields for the given request."

	| fields |
	fields := Dictionary new.
	self getFields associationsDo:[:a| fields add: a].
	self postFields associationsDo:[:a| fields add: a].
	self multipartFields associationsDo:[:a| fields add: a].
	^fields
! !
!WebRequest methodsFor: 'fields' stamp: 'ar 2/21/2010 09:55'!
getFields
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	| args |
	args := (rawUrl copyAfter: $?) ifEmpty:[^Dictionary new].
	^WebUtils decodeUrlEncodedForm: args multipleValues: false
! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/28/2010 21:01'!
multipartFields
	"Answers the multipart fields of a post request"

	| fields |
	fields := Dictionary new.
	self multipartFieldsDo:[:hdrs :params :cntnt|
		params at: 'name' ifPresent:[:fieldName| fields at: fieldName put: cntnt].
	].
	^fields! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/20/2010 20:08'!
multipartFieldsDo: aBlock
	"Evaluate aBlock with the multipart fields of a post request.
	The block is expected to take three arguments:
		* The headers from the part being processed
		* The parameters from the content-disposition header
		* The content from the part being processed
	"

	^(self isPostRequest and: [
		self contentType beginsWith: 'multipart/form-data'])
			ifTrue: [WebUtils decodeMultipartForm: self content readStream boundary: self multipartBoundary do: aBlock]
			ifFalse: [Dictionary new]! !
!WebRequest methodsFor: 'fields' stamp: 'jmv 6/25/2017 20:10:00'!
postFields
	"Answers the multipart fields of a post request"

	^(self isPostRequest and: [
		self contentType beginsWith: 'application/x-www-form-urlencoded'])
			ifTrue: [
				WebUtils 
					decodeUrlEncodedForm: self content 
					multipleValues: true ]
			ifFalse: [Dictionary new]! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 2/23/2010 09:02' overrides: 16920235!
initialize
	"Initialize the receiver"

	super initialize.
	method := 'GET'.
	protocol := 'HTTP/1.1'.
	headers := OrderedCollection new.! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 9/4/2010 11:09'!
initializeFromUrl: urlString
	"Initialize the client from a http url or string"

	| urlStream |
	urlStream := urlString readStream.
	"Skip past scheme if present"
	urlStream upToAll: '://'.
	urlStream atEnd 
		ifTrue:[rawUrl := urlString]
		ifFalse:[rawUrl := urlStream upTo: $/; upToEnd].
	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].
! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 4/1/2010 16:03'!
newResponse
	"Create a new response entitiy.
	Subclasses can override this method to provide a different response class"

	^(WebResponse new)
		request: self;
		yourself! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 7/8/2010 19:11'!
newWebSocketOn: aStream
	"Create a new socket entitiy.
	Subclasses can override this method to provide a different response class"

	^WebSocket on: aStream! !
!WebRequest methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:52'!
readFrom: aStream
	"Initialize the receiver initialized from an existing socket stream 
	This method will block until the headers have been parsed."

	| tokens |
	stream := aStream.
	stream isBinary ifTrue:[stream ascii].
	"Parse request header"
	request := stream upToAll: String crlfString.
	tokens := request findTokens: ' '.
	tokens size < 2 ifTrue:[^self error: 'Invalid HTTP request: ', request].
	method := tokens first.
	rawUrl := tokens second.
	tokens size > 2 
		ifTrue:[protocol := tokens third]
		ifFalse:[protocol := 'HTTP/1.0'].

	"Parse HTTP header"
	headers := WebUtils readHeadersFrom: stream.
! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40'!
method
	"The request method (GET, POST etc)"

	^method! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40'!
method: aString
	"The request method (GET, POST etc)"

	method := aString! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40'!
rawUrl
	"The raw (unparsed) url"

	^rawUrl! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:07'!
rawUrl: aString
	"The raw (unparsed) url"

	rawUrl := aString
! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 7/28/2010 19:49'!
requestLine
	"The actual request line as sent by the client"

	^request ifNil:[self method, ' ', self rawUrl, ' ', self protocol]! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:55'!
server
	"If non-nil, the WebServer instance associated with the request."

	^server! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:55'!
server: aWebServer
	"If non-nil, the WebServer instance associated with the request."

	server := aWebServer! !
!WebRequest methodsFor: 'accessing' stamp: 'DSG 5/24/2012 21:18'!
url
	"The url without fragment or arguments"

	^((rawUrl copyUpTo: $#) copyUpTo: $?) unescapePercents! !
!WebRequest methodsFor: 'responses' stamp: 'NR 11/4/2022 18:30:50'!
send200Response: aString
	"Send a 200 OK response"

	^self 
		send200Response: (aString asUtf8Bytes) 
		contentType: 'text/plain; charset=utf-8'.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/20/2010 15:42'!
send200Response: aString contentType: contentType
	"Send a 200 OK response"

	^self send200Response: aString contentType: contentType do:[:resp]! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 16:32'!
send200Response: aString contentType: contentType do: aBlock
	"Send a 200 OK response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: contentType.
	aBlock value: resp.
	^self sendResponse: resp content: aString.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26'!
send301Response: location
	"Send a 301 permanent redirect response"

	^self send301Response: location do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:27'!
send301Response: location do: aBlock
	"Send a 301 permanent redirect response"

	^self send3xxResponse: location code: 301 do: aBlock! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26'!
send302Response: location
	"Send a 302 temporary redirect response"

	^self send302Response: location do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26'!
send302Response: location do: aBlock
	"Send a 302 temporary redirect response"

	^self send3xxResponse: location code: 302 do: aBlock! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/20/2010 15:42'!
send3xxResponse: location code: statusCode
	"Send a 3xx redirect response"

	^self send3xxResponse: location code: statusCode do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/23/2010 09:33'!
send3xxResponse: location code: statusCode do: aBlock
	"Send a 3xx redirect response"

	| resp url |
	"If the redirect is not to an absolute url, prefix it with the host if we have one"
	url := location.
	(location findString: '://') > 0 ifFalse:[
		(self headerAt: 'host') ifNotEmpty:[:host| url := 'http://', host, location]].

	resp := self newResponse protocol: 'HTTP/1.1' code: statusCode.
	resp headerAt: 'Location' put: url.
	aBlock value: resp.
	^self sendResponse: resp content: ''.
! !
!WebRequest methodsFor: 'responses' stamp: 'NR 11/4/2022 18:35:55'!
send400Response
	"Send a 400 bad request response"

	| message |
	message := '<html><head><title>400 Bad Request</title></head><body>',
		'<h1>Bad Request</h1>
		<p>The server encountered a request it did not understand.
		</body></html>'.
	
	self sendResponseCode: 400 
		content: message asUtf8Bytes 
		type: 'text/html; charset=utf-8'
		close: true! !
!WebRequest methodsFor: 'responses' stamp: 'NR 11/4/2022 18:11:23'!
send400Response: errorMessageText
	"Send a 400 bad request response"

	| message |
	message := '<html><head><title>400 Bad Request</title></head><body>',
		'<h1>400 Bad Request</h1>
		<p>', errorMessageText,
		'</p></body></html>'.
	
	self sendResponseCode: 400 
		content: message asUtf8Bytes 
		type: 'text/html; charset=utf-8'
		close: true.! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:50:46'!
send404Response
	"Send a 404 not found response"
	
	^self send404Response: '<html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><p>The requested URL ',self rawUrl,' was not found on this server.</p></body></html>'.
! !
!WebRequest methodsFor: 'responses' stamp: 'NR 11/4/2022 18:48:39'!
send404Response: body
	"Send a 404 not found response"

	^self 
		send404Response: (body asUtf8Bytes) 
		do: [ :resp | resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8' ]! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:50:58'!
send404Response: body do: aBlock
	"Send a 404 not found response"

	| resp |
	
	resp := self newResponse protocol: 'HTTP/1.1' code: 404.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	aBlock value: resp.
	^self sendResponse: resp content: body.
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08'!
send405Response: allowed
	"Send a 405 method not allowed response"

	^self send405Response: allowed content: '<html><head><title>405 Method Not Allowed</title></head><body><h1>405 Method Not Allowed</h1><p>The requested method ',self method,' is not allowed for the URL', self rawUrl, '</p></body></html>'.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08'!
send405Response: allowed content: body
	"Send a 405 method not allowed response"
	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 405.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	resp headerAt: 'allow' put: (String streamContents:[:s|
		allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]
	]).
	^self sendResponse: resp content: body.! !
!WebRequest methodsFor: 'responses' stamp: 'NR 11/4/2022 18:48:44'!
send500Response: errReport
	"Send a 500 internal server error response"

	| errLog |
	errLog := '<html><head><title>500 Internal Server Error</title></head><body>',
		'<h1>Internal Server Error</h1><pre>',
		(errReport  withLineEndings: String crlfString),
		'</pre></body></html>'.

	self sendResponseCode: 500
				content: errLog asUtf8Bytes
				type: 'text/html; charset=utf-8'
				close: true.
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08'!
sendOptionsResponse: allowed
	"Send a 200 OK response for an OPTIONS request"

	^self send200Response: '' contentType: 'application/octet-stream' do:[:resp|
		resp headerAt: 'allow' put: (String streamContents:[:s|
			allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]
		]).
	].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 8/31/2010 22:16'!
sendResponse: code chunked: chunkBlock
	"Send a chunked response"

	^self sendResponse: code chunked: chunkBlock do:[:resp]! !
!WebRequest methodsFor: 'responses' stamp: 'ar 8/31/2010 22:16'!
sendResponse: code chunked: chunkBlock do: hdrBlock
	"Send a chunked response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: code.
	resp headerAt: 'Transfer-Encoding' put: 'chunked'.
	hdrBlock value: resp.
	^self sendResponse: resp contentBlock:[:aStream|
		"Set the stream in the request and pass it in the chunk block"
		resp stream: aStream.
		chunkBlock value: resp.
		"send termination chunk"
		aStream nextPutAll: '0'; crlf; crlf; flush.
	].
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/28/2010 20:22'!
sendResponseCode: code content: aString type: contentType close: aBool
	"Send a 500 Internal server error response"

	^self sendResponseCode: code content: aString type: contentType do:[:hdr|
		aBool ifTrue:[hdr headerAt: 'Connection' put: 'close'].
	].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/28/2010 20:19'!
sendResponseCode: code content: aString type: contentType do: aBlock
	"Send a 500 Internal server error response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: code.
	contentType ifNotNil:[resp headerAt: 'Content-Type' put: contentType].
	aBlock value: resp.
	^self sendResponse: resp content: aString.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 23:35'!
sendXmlResponse: xmlString
	"Send an a-ok 200 xml-ish response"

	^self send200Response: xmlString contentType: 'application/xml'! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:48'!
stream200Response: aStream
	"Stream a 200 OK response"

	^self stream200Response: aStream size: aStream size! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:53'!
stream200Response: aStream size: streamSize
	"Stream a 200 OK response"

	^self stream200Response: aStream size: streamSize type: 'application/octet-stream'! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:53'!
stream200Response: aStream size: streamSize type: contentType
	"Stream a 200 OK response"

	^self stream200Response: aStream size: streamSize type: contentType do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 18:14'!
stream200Response: aStream size: streamSize type: contentType do: aBlock
	"Stream a 200 OK response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: contentType.
	aBlock value: resp.
	^self sendResponse: resp contentStream: aStream size: streamSize.! !
!WebRequest methodsFor: 'printing' stamp: 'CK 11/24/2017 14:53:04' overrides: 50625125!
writeOn: aStream
	"Write the request"

	self writeRequestOn: aStream.
	super writeOn: aStream! !
!WebRequest methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:37'!
writeRequestOn: aStream
	"Write the request"

	aStream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: protocol; nextPutAll: String crlfString.
! !
!WebRequest class methodsFor: 'instance creation' stamp: 'ar 2/20/2010 11:23' overrides: 50368467!
readFrom: aStream
	"Create a WebRequest from a given stream"

	^self new readFrom: aStream! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39'!
code
	"The HTTP response code"

	^code! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 6/18/2010 23:51' overrides: 50625354!
content
	"Reimplemented to close the socket if the request is transient"

	content ifNil:[
		content := self getContent.
		self closeIfTransient.
	].
	^content! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:02' overrides: 50625380!
contentStream
	"Answers a stream for the conent."

	(self headerAt: 'transfer-encoding') = 'chunked' ifTrue:[
		^WebChunkedStream on: stream.
	].
	^super contentStream! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 4/1/2010 16:02'!
request
	"The original request for this response"

	^request! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 4/1/2010 16:03'!
request: aRequest
	"The original request for this response"

	request := aRequest! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39'!
status
	"The status line from the response"

	^status! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39'!
status: aString
	"The status line from the response"

	status := aString! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 8/24/2010 21:37'!
url
	"The url of the resource at which a request was terminated after a series
	of redirects. Without redirects, this will be the same as the request url."

	^url! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 8/24/2010 21:37'!
url: urlString
	"The url of the resource at which a request was terminated after a series
	of redirects. Without redirects, this will be the same as the request url."

	url := urlString! !
!WebResponse methodsFor: 'private' stamp: 'topa 4/3/2013 17:32' overrides: 50625443!
getContent
	"Do not read any content if this was a HEAD request or code is 204 (no content)"
	(request method = 'HEAD' or: [code = 204]) ifTrue:[^''].
	^super getContent! !
!WebResponse methodsFor: 'testing' stamp: 'ar 7/9/2010 00:27'!
isInformational
	"Is this a 1xx response?"

	^self code between: 100 and: 199
! !
!WebResponse methodsFor: 'testing' stamp: 'ar 8/10/2010 08:56'!
isRedirect
	"Is this a redirect response?"

	^self code between: 300 and: 399
! !
!WebResponse methodsFor: 'testing' stamp: 'ar 2/23/2010 10:13'!
isSuccess
	"Is this a successful response?"

	^self code between: 200 and: 299
! !
!WebResponse methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48'!
protocol: respProtocol code: respCode
	"Initialize a response from protocol and code"

	code := respCode.
	protocol := respProtocol.
	status := protocol, ' ', code asString, ' ', (self class statusCodeAt: code).
	headers := OrderedCollection new.! !
!WebResponse methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:56'!
readFrom: aStream
	"Parse an HTTP response from the given stream"

	| tokens |
	stream := aStream.
	status := stream upToAll: String crlfString.
	tokens := status findTokens: ' '.
	tokens size < 2 ifTrue:[^self error:'Invalid response: ', status].
	protocol := tokens first.
	code := tokens second asNumber.
	headers := WebUtils readHeadersFrom: stream.
! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35'!
setCookie: aCookie
	"Adds a Set-Cookie header"

	^self addHeader: 'Set-Cookie' value: aCookie asString! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35'!
setCookie: name value: value path: path 
	"Adds a Set-Cookie header"

	^self setCookie: ((WebCookie new)
			name: name;
			value: value;
			path: path;
		yourself)! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35'!
setCookie: name value: value path: path expires: date domain: domain secure: aBool
	"Adds a Set-Cookie header"

	^self setCookie: ((WebCookie new)
			name: name;
			value: value;
			path: path;
			expiry: date;
			domain: domain;
			secure: aBool;
		yourself)! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/25/2010 18:16'!
setCookieAt: key
	"Evaluate aBlock with all the cookies deined in the request"

	self setCookiesDo:[:cookie|
		cookie name = key ifTrue:[^cookie].
	].
	^nil! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/21/2010 09:51'!
setCookiesDo: aBlock
	"Evaluate aBlock with all the cookies deined in the request"

	self headersAt: 'Set-Cookie' do:[:hdr|
		aBlock value: (WebCookie new readFrom: hdr readStream)
	].
! !
!WebResponse methodsFor: 'printing' stamp: 'ar 2/20/2010 16:33' overrides: 50625125!
writeOn: aStream
	"Store this response on aStream"

	self writeStatusOn: aStream.
	super writeOn: aStream.
! !
!WebResponse methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:39'!
writeStatusOn: aStream
	"Store this response on aStream"

	aStream nextPutAll: status; nextPutAll: String crlfString.
! !
!WebResponse class methodsFor: 'instance creation' stamp: 'ar 2/20/2010 11:24'!
protocol: protocol code: code
	"Create a response using the given protocol / code"

	^self new protocol: protocol code: code! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 19:56'!
accessLog
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	^accessLog! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 19:56'!
accessLog: aStreamOrFilename
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	accessLog := aStreamOrFilename! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 20:02'!
logRequest: request response: response
	"Log a request after it has been successfully processed"

	accessLog ifNil:[^self].

	"Do not use the standard exception handler for errors logging; 
	it would possibly send a 500 response. Really this should be handled
	by a different process with its own error handler."

	[WebUtils logRequest: request response: response on: accessLog]
		on: Error do:[:ex| self log: 'Error in logging: ', ex description].
! !
!WebServer methodsFor: 'services' stamp: 'ar 5/11/2010 20:10'!
addService: entryPoint action: aBlockOrMessage
	"Add a service to the web server. The service is specified by an entryPoint, 
	denoting the url under which the service can be requested 
	(such as /my/great/service) and an action which is a message 
	send taking a single argument, the WebRequest."

	^self addService: entryPoint 
		action: aBlockOrMessage 
		methods: self defaultHttpMethods.! !
!WebServer methodsFor: 'services' stamp: 'ar 5/11/2010 20:10'!
addService: entryPoint action: aBlockOrMessage methods: methods
	"Add a service to the web server. The service is specified by an entryPoint, 
	denoting the url under which the service can be requested 
	(such as /my/great/service) and an action which is a message 
	send taking a single argument, the WebRequest.
	
	The list of methods describes what HTTP methods the given url supports."

	mutex critical:[
		entryPoints at: entryPoint asLowercase put: {methods. aBlockOrMessage}.
	].! !
!WebServer methodsFor: 'services' stamp: 'ar 2/22/2010 02:52'!
removeService: entryPoint 
	"Remove a service from the HTTP service provider.  See #addService:action:"

	mutex critical:[
		entryPoints removeKey: entryPoint asLowercase ifAbsent: [].
	].! !
!WebServer methodsFor: 'handling' stamp: 'ul 7/3/2014 23:56'!
asyncHandleConnectionFrom: aSocket
	"Handle an incoming connection asynchronously to avoid blocking the listener."

	| handlerProcess |
	handlerProcess := [
		[ [ self handleConnectionFrom: aSocket ] 
			on: Error do: [ :ex | aSocket destroy ] ]
			ensure: [
				aSocket destroy.
				mutex critical: [ 
					"If we get here, then handlerProcess is initialized, so it's safe to use that variable. Using Processor activeProcess is not possible, because this block may be evaluated by another process. Doing this outside the #ensure: block is not safe."
					connections remove: handlerProcess ifAbsent: [ ] ] ] ] newProcess.

	mutex critical:[connections add: handlerProcess].

	handlerProcess resume.
! !
!WebServer methodsFor: 'handling' stamp: 'ar 2/23/2010 22:34'!
dispatchRequest: request
	"Look up the handler for a given request and dispatch to it"

	^self dispatchRequest: request url: request url! !
!WebServer methodsFor: 'handling' stamp: 'HAW 5/6/2020 09:47:55'!
dispatchRequest: request url: dispatchUrl
	"Look up the handler for a given url and dispatch to it"

	| entryUrl action |
	"Handle TRACE requests right away"
	request method = 'TRACE' ifTrue:[
		^request send200Response: request asString contentType: 'message/http'.
	].

	"Look up the entry point for the request"
	action := nil.
	entryUrl := dispatchUrl asLowercase.
	(entryUrl beginsWith: '/') ifFalse:[entryUrl := '/', entryUrl].
	mutex critical:[
		[entryUrl notEmpty and:[action == nil]] whileTrue: [
			action := entryPoints at: entryUrl ifAbsent:[nil].
			entryUrl := entryUrl copyUpToLast: $/.
		].
		action ifNil:[action := entryPoints at: '/' ifAbsent:[nil]].
	].

	"Handle OPTIONS requests"
	request method = 'OPTIONS' ifTrue:[
		"HEAD, TRACE, and OPTIONS are always supported"
		request sendOptionsResponse: self builtinHttpMethods,
			(action ifNil:[self defaultHttpMethods] ifNotNil:[action first])
	].

	"Handle 404 not found"
	action ifNil:[^request send404Response].

	"Handle 405 method not allowed"
	(request method = 'HEAD' "builtin" 
		or:[(action at: 1) includes: request method]) ifFalse:[
			^request send405Response: self builtinHttpMethods, action first.
		].

	^[self invokeAction: (action at: 2) request: request] 
		on: Error 
		do:[:ex|
			errorHandler 
				ifNil:[self handleError: ex request: request]
				ifNotNil:[errorHandler value: ex value: request]].
! !
!WebServer methodsFor: 'handling' stamp: 'ar 7/29/2010 18:46'!
handleConnectionFrom: aSocket
	"Synchronously handle an incoming socket connection."

	| stream request |

	"Give the process a pretty name"
	Processor activeProcess name: (String streamContents:[:s|
		aSocket remoteAddress do:[:b| s print: b] separatedBy:[s nextPut: $.].
		s nextPut: $:; print: aSocket remotePort.
		s nextPutAll: ' - ', self class name, ' request handler'.
	]).

	"Read the request from the socket, and dispatch it.
	Since we've been forked already it's okay to block."
	[
		certName ifNil:["Regular request"
			stream := SocketStream on: aSocket.
		] ifNotNil:["SSL/TLS"
			| ssl |
			ssl := Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL not installed'].
			stream := ssl secureSocketStream on: aSocket.
			[stream sslAccept: certName] on: Error do:[^stream destroy].
		].

		[aSocket isConnected] whileTrue:[

			"Read the next request from the connection. If the connection is closed,
			or if a network error occurs, or the read times out, just close the connection
			without further ado (rather than logging an error). Any other error resulting
			from parsing the input is treated as a 400 bad request."

			stream peek ifNil:[^aSocket destroy].
			request := self newRequest.
			[request readFrom: stream] on: Error do:[:ex| 
				(ex isKindOf: NetworkError) ifFalse:[
					[request send400Response] on: Error do:[:ignore].
				].
				^aSocket destroy].

			self dispatchRequest: request.
		].
	] on: Error do:[:ex|
		(ex isKindOf: NetworkError) ifFalse:[
			self log: 'Error in request handling: ', ex description.
			self log: (self errorReportFor: ex).
		].
	].! !
!WebServer methodsFor: 'handling' stamp: 'ar 2/20/2010 14:30'!
invokeAction: action request: request
	"Invokes the given action. Subclasses can override this method to serialize
	actions if necessary. At this point, the request header has been read from
	the network, but not its content."

	^action valueWithArguments: {request}
! !
!WebServer methodsFor: 'handling' stamp: 'ar 7/28/2010 20:27'!
newRequest
	"Answer a new request.
	Subclasses should override this method to use a different request class."

	^(WebRequest new)
		server: self;
		yourself! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43'!
authAccept: method request: request realm: realm header: authHeader
	"Performs the requested authentication method. 
	Returns true if successfully authenticated.
	Subclasses can extend this method to support more auth methods."

	^method asLowercase caseOf: {
		['basic'] 	-> [self basicAuth: request realm: realm header: authHeader].
		['digest'] 	-> [self digestAuth: request realm: realm header: authHeader].
	} otherwise:[false].
! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43'!
authHeader: method request: request realm: realm
	"Answer the authentication header for the given method.
	Subclasses can extend this method to support more auth methods."

	^method asLowercase caseOf: {
		['basic'] 	-> ['Basic realm="', realm,'"'].
		['digest'] 	-> ['Digest realm="', realm,'", nonce="', self newNonce,'", qop="auth"'].
	} otherwise:[nil].
	
	! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43'!
authenticate: request realm: realm methods: accepted do: aBlock
	"Authenticates an incoming request using one of the accepted methods.

	Evaluates aBlock upon successful authentication. Responds with a 401
	(Unauthorized) if the authentication fails."

	| method resp |
	request headersAt: 'Authorization' do:[:authHeader|
		method := authHeader copyUpTo: Character space.
		(accepted anySatisfy:[:auth| auth sameAs: method]) ifTrue:[
			(self authAccept: method request: request realm: realm header: authHeader)
				ifTrue:[^aBlock value].
		].
	].

	"Send a 401 (unauthorized) response"
	resp := request newResponse protocol: 'HTTP/1.1' code: 401.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	accepted do:[:auth| | hdr |
		hdr := self authHeader: auth request: request realm: realm.
		hdr ifNotNil:[resp addHeader: 'WWW-Authenticate' value: hdr].
	].
	request sendResponse: resp content: '<html><head><title>401 Unauthorized</title></head><body><h1>401 Unauthorized</h1><p>You are not authorized to access the requested URL</p></body></html>'.
! !
!WebServer methodsFor: 'authentication' stamp: 'jmv 6/25/2017 20:42:21'!
basicAuth: request realm: realm header: authHeader
	"Perform Basic auth for the given request"

	| data user pass hash |
	data := String fromUtf8: (authHeader copyAfter: $ ) base64Decoded.
	user := data copyUpTo: $:.
	pass := data copyAfter: $:.
	data atAllPut: $*. data := nil.

	hash := self hashUser: user password: pass realm: realm.
	pass atAllPut: $*. pass := nil.

	^(self passwordHashAt: user, ':', realm) = hash
! !
!WebServer methodsFor: 'authentication' stamp: 'jmv 6/25/2017 19:16:08'!
digestAuth: request realm: realm header: authHeader
	"Authenticates an incoming request using Digest auth."

	| user nonce uri response ha1 ha2 md5 qop nc cnonce 
	  nonceData nonceCounter nonceTimeout params |

	params := WebUtils parseAuthParams: authHeader.

	"Flush the nonce cache randomly about every 100 auth attempts"
	100 atRandom = 42 ifTrue:[self flushNonceCache].

	user := params at: 'username' ifAbsent:[''].
	nonce := params at: 'nonce' ifAbsent:[''].
	uri := params at: 'uri' ifAbsent:[request url].
	response := params at: 'response' ifAbsent:[''].
	
	qop := params at: 'qop' ifAbsent:[''].
	qop = 'auth' ifFalse:[^false]. "we require qop=auth"

	nc := params at: 'nc' ifAbsent:[''].
	cnonce := params at: 'cnonce' ifAbsent:[''].
	
	"Verify that this is a nonce that we have handed out, that it isn't expired
	and that the nc counter has increased from the last use."
	mutex critical:[
		nonceData := nonceCache at: nonce ifAbsent:[^false].
	].
	nonceCounter := nonceData first.		"last used nc"
	nonceTimeout := nonceData second.	"timeout for nonce"
	nc <= nonceCounter ifTrue:[^false]. 	"nc must increase"
	Time localSecondClock > nonceTimeout ifTrue:[^false]. "nonce expired"
	nonceData at: 1 put: nc.

	ha1 := self passwordHashAt: user, ':', realm.
	ha2 := WebUtils md5Digest: request method, ':', uri.
	md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.
	^md5 = response
! !
!WebServer methodsFor: 'authentication' stamp: 'DSG 12/5/2013 17:11'!
flushNonceCache
	"Flushes expired nonces from the cache"

	| deadline |
	deadline := Time localSecondClock.
	mutex critical:[
		nonceCache := nonceCache reject:[:nonceData| deadline > nonceData second]
	].
! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:36'!
hashUser: user password: pass realm: realm
	"Creates a hash for the given username password pair.
	This method is the ha1 part of digest auth and can be used for both digest
	as well as basic auth."

	^WebUtils md5Digest: user, ':', realm, ':', pass! !
!WebServer methodsFor: 'authentication' stamp: 'DSG 12/5/2013 17:12'!
newNonce
	"Create a new nonce to be used for a client authentication session"

	| nonce |
	nonce := UUID new hex.
	mutex critical:[
		nonceCache at: nonce put: {''. Time localSecondClock + self nonceDeadline}.
	].
	^nonce! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/23/2010 09:20'!
nonceDeadline
	"Answer the number of seconds a nonce is considered valid for digest auth
	by the server. After this period, the client will have to reauthenticate.
	The default is 30 minutes."

	^30*60 ! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:54'!
passwordAt: username realm: realm put: password
	"Store the password hash for the key."

	| hash |
	hash := self hashUser: username password: password realm: realm.
	self passwordHashAt: (username,':',realm) put: hash! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:51'!
passwordHashAt: key
	"Answer the password hash for the given key"

	^vault at: key ifAbsent:['']! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:01'!
passwordHashAt: key put: hash
	"Store the password hash for the key."

	^vault at: key put: hash! !
!WebServer methodsFor: 'initialize' stamp: 'ar 5/11/2010 20:10'!
builtinHttpMethods
	"Returns the list of HTTP methods that the server handles built-in,
	i.e., without passing them to the registered service."

	^#('HEAD' 'TRACE' 'OPTIONS')! !
!WebServer methodsFor: 'initialize' stamp: 'ar 2/23/2010 12:10'!
critical: aBlock
	"Evaluate aBlock protected byt the server's mutex.
	Necessary if code needs to manipulate internal server state."

	^mutex critical: aBlock
! !
!WebServer methodsFor: 'initialize' stamp: 'ar 5/11/2010 20:10'!
defaultHttpMethods
	"Answer the list of HTTP methods that should be be supported by default.
	The methods must be implemented by the request handler."

	^#('GET' 'POST')! !
!WebServer methodsFor: 'initialize' stamp: 'ar 11/1/2010 21:07'!
destroy
	"Destroys the receiver"

	self stopListener.
	self destroyConnections.
	listenerSocket ifNotNil:[listenerSocket destroy].

	"De-register the WebServer"
	(self class forUrl: self siteUrl ifAbsent:[self]) == self 
		ifTrue:[self class removeUrl: siteUrl]
! !
!WebServer methodsFor: 'initialize' stamp: 'ul 10/16/2014 13:16'!
destroyConnections
	"Destroy all current connections."

	| copy |
	copy := mutex critical: [ connections copy ].
	" #terminate will trigger the #ensure: block in #asyncHandleConnectionFrom:, which will block if we don't release the mutex "
	copy do: [ :p | p terminate ].
	" make sure all of them were really removed "
	mutex critical: [ connections removeAll ]
! !
!WebServer methodsFor: 'initialize' stamp: 'DSG 3/28/2015 20:16' overrides: 16920235!
initialize
	"Initialize the receiver"

	mutex := Mutex new.
	entryPoints := Dictionary new.
	connections := IdentitySet new.
	vault := Dictionary new.
	nonceCache := Dictionary new.
	sessions := Dictionary new.
	self logAction:[:aString| Transcript log: aString].
! !
!WebServer methodsFor: 'initialize' stamp: 'ar 2/22/2010 05:35'!
log: aString
	"Log the given information."

	logAction ifNotNil:[logAction valueWithArguments: {aString}].
! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/29/2010 18:49'!
certName
	"The cert name to use for a secure (SSL/TLS) web server."

	^certName! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/29/2010 18:49'!
certName: aString
	"The cert name to use for a secure (SSL/TLS) web server."

	certName := aString.! !
!WebServer methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:22'!
connections
	"The active connection processes. Can only be examined after aquiring
	the WebServer's mutex."

	^connections! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:24'!
errorHandler
	"The user-supplied error handler. If present the handler takes two arguments:
		* The error being caught by WebServer
		* The request the error occurred in.
	The user-supplied error handler can do whatever it wants, including calling
	WebServer's #handleError:request: method which is the default."

	^errorHandler! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:24'!
errorHandler: aBlock
	"The user-supplied error handler. If present the handler takes two arguments:
		* The error being caught by WebServer
		* The request the error occurred in.
	The user-supplied error handler can do whatever it wants, including calling
	WebServer's #handleError:request: method which is the default."

	errorHandler := aBlock.! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:01'!
listenerInterface
	"Returns the listener interface for the server"

	^interface! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:01'!
listenerPort
	"Returns the listener port for the server"

	^port! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:00'!
listenerProcess
	"Returns the socket listener process for the server."

	^listenerProcess! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:00'!
listenerSocket
	"Returns the listener socket for the server."

	^listenerSocket! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 05:35'!
logAction
	"The current log action (a block or message)"

	^logAction! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 05:36'!
logAction: aBlockOrMessage
	"The current log action (a block or message).
	Example:
		WebServer new logAction: [:aString| Transcript show: aString].
		WebServer new logAction: (MessageSend receiver: Transcript selector: #show).
	"

	logAction := aBlockOrMessage! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:53'!
serverDate
	"Returns the date string to be used in responses"

	^self class serverDate! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:54'!
serverString
	"Returns the server string to be used in responses.
	The response is cached for efficiency."

	^serverString ifNil:[serverString := self class serverString].! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:57'!
serverString: aString
	"Set the server string to be used in responses"

	^serverString := aString! !
!WebServer methodsFor: 'accessing' stamp: 'ar 11/1/2010 21:01'!
siteUrl
	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."

	^siteUrl! !
!WebServer methodsFor: 'accessing' stamp: 'ar 11/1/2010 21:13'!
siteUrl: aString
	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."

	siteUrl := aString! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/20/2010 12:03'!
vault
	"The vault used for storing password hashes."

	^vault! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 02:51'!
vault: anObject
	"The vault used for storing password hashes.

	Clients can provide their own storage mechanism. 
	Subclasses can also override the lookup and authentication mechanism."

	vault := anObject! !
!WebServer methodsFor: 'errors' stamp: 'HAW 5/6/2020 12:06:30'!
debugErrorHandler

	^[:anException :aRequest | 
		[nil handleSignal: anException ] 
			on: UnhandledError 
			do: [ :unhandledError | nil handleSignal: unhandledError ]]! !
!WebServer methodsFor: 'errors' stamp: 'ar 2/20/2010 10:35'!
errorReportFor: anError
	"Provide a report for an error that's been caught during processing"

	^[
		String streamContents:[:s| 
			self errorReportFor: anError 
				stack: ([anError signalerContext stackOfSize: 2000] 
							on: Error do:[:ex| ex return: #()])
				on: s
		].
	] on: Error do: [:ex| ex pass. 'error reporting failed'].! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 21:55'!
errorReportFor: anError stack: preStack on: strm
	"Provide a report for an error that's been caught during processing"

	self errorStackFor: anError stack: preStack on: strm.
	strm newLine; nextPutAll: '-----------------------------------------------------------------'; newLine; newLine.
	self systemInfoOn: strm.
! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 21:55'!
errorStackFor: anError stack: preStack on: strm
	"Provide a report for an error that's been caught during processing"

	| cnt |
	cnt := 0.
	(preStack copyFrom: 1 to: (5 min: preStack size)) do:[:ctx|
		ctx printDetails: strm.	"variable values"
		strm newLine.
	].

	strm newLine; nextPutAll: '--- The full stack ---'; newLine.
	cnt := 0.

	preStack do:[:ctx|
		cnt := cnt + 1.
		cnt = 5 ifTrue: [
			strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; newLine].
		strm print: ctx; newLine.  "just class>>selector"
	].
! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 23:48'!
handleError: ex request: aRequest
	"The default error handling during processing. Sends a 500 response."

	| errLabel errReport |
	errLabel := [ex description] on: Error do:[:ex2| 
		ex2 return: ex class name
	].
	errReport := [self errorReportFor: ex] on: Error do:[:ex2|
		ex2 return: '<error report failed>'.
	].
	[self log: errLabel] on: Error do:[:ex2| ex return].
	[self log: String newLineString, errReport] on: Error do:[:ex2| ex return].
	aRequest send500Response: errReport. ! !
!WebServer methodsFor: 'errors' stamp: 'jmv 6/25/2017 19:16:01'!
systemInfoOn: strm
	"Provides system information for a server error report"
	| info |
	strm nextPutAll: 'VM: ';
		nextPutAll:  WebUtils platformName;
		nextPutAll: ' - ';
		nextPutAll: WebUtils vmVersion;
		newLine.

	strm nextPutAll: 'Image: ';
		nextPutAll:  SystemVersion current version asString;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString asString;
		nextPutAll: ']';
		newLine.

	strm newLine.

	"SecurityManager default printStateOn: strm."

	"Additional info available from the windows VM"
	WebUtils platformName = 'Win32' ifTrue:[
		10001 to: 10003 do: [ :i |
			info := (Smalltalk getSystemAttribute: i) ifNil:[''].
			info isEmpty ifFalse:[strm newLine; nextPutAll: info]]]! !
!WebServer methodsFor: 'errors' stamp: 'HAW 5/6/2020 12:06:46'!
useDebugErrorHandler

	self errorHandler: self debugErrorHandler ! !
!WebServer methodsFor: 'testing' stamp: 'ar 3/30/2010 22:09'!
isRunning
	"Is the server still running?"

	^self isStopped not! !
!WebServer methodsFor: 'testing' stamp: 'ar 3/30/2010 22:09'!
isStopped
	"Is the server still running?"

	^listenerProcess == nil or:[listenerProcess isTerminated]! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:27'!
listenOn: aPort
	"Starts the server listening on the given port"

	^self listenOn: aPort interface: nil! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:28'!
listenOn: aPort interface: anInterface
	"Starts the server listening on the given port / network interface"

	^self listenOn: aPort interface: anInterface backlogSize: 8! !
!WebServer methodsFor: 'listening' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48'!
listenOn: aPort interface: anInterface backlogSize: backlog
	"Starts the server listening on the given port / network interface"
	
	| ipString |
	interface := anInterface.
	port := aPort.
	ipString := interface ifNil:['*'] ifNotNil:[
		String streamContents:[:s| interface do:[:b| s print: b] separatedBy:[s nextPut:$.]]].
	self log: 'listener starting (interface: ', ipString, ' port: ', port asString, ')'.
	listenerSocket := Socket newTCP.
	interface 
		ifNil:[listenerSocket listenOn: port backlogSize: backlog]
		ifNotNil:[listenerSocket listenOn: port backlogSize: backlog interface: interface].
	listenerSocket isWaitingForConnection ifFalse:[
		self error: 'Failed to listen(interface: ', interface printString, ' port: ', aPort printString,' )'.
	].
	self startListener.! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:28'!
listenerProcessPriority
	"The priority at which the listener process should run"

	^Processor lowIOPriority! !
!WebServer methodsFor: 'listening' stamp: 'ar 5/4/2010 09:22'!
runListener
	"Runs the server's listener loop. 
	Accepts incoming connections and handles them asynchronously"

	| connectionSocket |
	[[[listenerSocket notNil and:[listenerSocket isValid]] whileTrue:[
		"Waiting for five seconds means that WebServer will be
		back up after roughly five seconds when the system restarts."
		connectionSocket := listenerSocket waitForAcceptFor: 5.
		"Fork this off since or else errors in acceptClient: kill the listener"
		connectionSocket ifNotNil:[self asyncHandleConnectionFrom: connectionSocket].
	]] ensure:[
		"Logging here is only for the purpose of catching sockets going randomly bad"
		self log: 'listener terminating, socket: ', (listenerSocket ifNotNil:[:s| s statusString]).

		"Try to restart the listener"
		(listenerSocket notNil and:[listenerSocket isValid not]) ifTrue:[
			listenerSocket destroy.
			listenerProcess := nil.
			"Wait a little before retrying"
			(Delay forSeconds: 2) wait.
			^self listenOn: port interface: interface
		].
	]] on: Error do:[:ex| self log: ex].
! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:29'!
startListener
	"Starts the server's listener process"

	self stopListener.
	listenerProcess := [self runListener] newProcess.
	listenerProcess priority: self listenerProcessPriority.
	listenerProcess name: self class name, '''s listener process'.
	listenerProcess resume.
! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:29'!
stopListener
	"Stops the server's listener process"

	listenerProcess ifNotNil:[listenerProcess terminate].
	listenerProcess := nil.! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:09'!
sessionAt: key
	"Answer the session associated with the given key"

	^mutex critical:[sessions at: key ifAbsent:[nil]].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:10'!
sessionAt: key ifAbsentPut: session
	"Answer the session associated with the given key"

	^mutex critical:[sessions at: key ifAbsentPut:[session]].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 5/11/2010 23:34'!
sessionAt: key put: session
	"Store the session associated with the given key"

	^mutex critical:[sessions at: key put: session].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:11'!
sessions
	"The sessions associated with the WebServer. These are not used by the server
	directly but rather provided so that client code has a convenient place to store
	session data."
	
	^sessions! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:11'!
sessions: aDictionary
	"The sessions associated with the WebServer. These are not used by the server
	directly but rather provided so that client code has a convenient place to store
	session data."
	
	sessions := aDictionary! !
!WebServer class methodsFor: 'benchmarks' stamp: 'jmv 6/26/2017 19:12:52'!
benchmark
	"Runs a WebClient/WebServer streaming benchmark to measure throughput"

	"
		WebServer benchmark
		MessageTally spyOn:[WebServer benchmark]
	"

	| amount time resp port |
	port := 8888.
	amount := 128 * 1024 * 1024.
	WebServer reset default listenOn: port.
	WebServer default addService: '/streaming' action:[:req|
		req stream200Response: DummyStream new size: amount.
	].
	time := [
		resp := WebClient httpGet: 'http://localhost:', port, '/streaming'.
		resp isSuccess ifFalse:[self error: resp status].
		resp streamTo: DummyStream new size: resp contentLength progress: nil.
		resp close.
	] timeToRun.
	WebServer reset.
	^(amount  * 1000 // time) printStringWithCommas, ' bytes/sec'
! !
!WebServer class methodsFor: 'benchmarks' stamp: 'ar 5/4/2010 21:27'!
requestBenchmark: persistent
	"Runs a WebClient/WebServer benchmark to measure request handling speed.
	Uses a persistent connection if requested."

	"
		WebServer requestBenchmark: false.
		WebServer requestBenchmark: true.
		MessageTally spyOn:[WebServer requestBenchmark: true]
	"

	| port |
	port := 8888.
	WebServer reset default listenOn: port.
	WebServer default addService: '/benchmark' action:[:req|
		req send200Response: ''.
	].
	^[WebClient 
		requestBenchmark: 'http://localhost:', port, '/benchmark'
		persistent: persistent] ensure:[WebServer reset].
! !
!WebServer class methodsFor: 'examples' stamp: 'NR 11/4/2022 18:48:48'!
browseDir: directory request: request
	"Responds with a directory listing back to the original request"

	| entries listing url |
	url := request url.
	(url endsWith: '/') ifTrue:[url := url allButLast].

	entries := directory children sort:[:e1 :e2|
		e1 isDirectory = e2 isDirectory 
			ifTrue:[e1 name <= e2 name]
			ifFalse:[e2 isDirectory]].

	listing := String streamContents:[:s|
		s nextPutAll:'<html><head><title>Index of ', request url,'</title></head><body>'.
		s nextPutAll:'<h1>Index of ', request url,'</h1>'.
		s nextPutAll:'<pre>      Name                      Last modified      Size  Description<hr>'.
		s nextPutAll: '[up]  <a href="', (url copyUpToLast: $/),'">parent</a>'; cr; lf.
		entries do:[:e|
			s nextPutAll:(e isDirectory ifTrue:['[dir] '] ifFalse:['      ']).
			s nextPutAll: '<a href="', url, '/', e name, '">'.
			s nextPutAll: (e name truncateTo: 30).
			s nextPutAll: '</a>'.
			e name size < 30 ifTrue:[s nextPutAll: (String new: 30 - e name size withAll: $ )].
			s nextPutAll: (e modificationTime asString padded: #right to: 20 with: $ ).
			s nextPutAll: (e isDirectory ifTrue: [String new: 20] ifFalse: [e fileSize asString padded: #right to: 20 with: $ ]).
			s cr; lf.
		].
 	].

	request
		send200Response: listing asUtf8Bytes
		contentType: 'text/html; charset=utf-8'.

! !
!WebServer class methodsFor: 'examples' stamp: 'jmv 5/19/2015 23:52'!
browseFile: file request: request
	"Responds with a file back to the original request"

	| fileSize mimeTypes resp |
	file binary.
	fileSize := file size.
"	mimeTypes := file mimeTypes ifNil:[#('application/octet-stream')]."
	mimeTypes := nil ifNil:[#('application/octet-stream')].
	resp := request newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: mimeTypes first.
	request sendResponse: resp contentStream: file size: fileSize.! !
!WebServer class methodsFor: 'examples' stamp: 'jmv 3/18/2019 13:16:59'!
browseRequest: request
	"Handle an HTTP request for browsing some resource"

	| path fd file directoryEntry fileEntry |

	"Extract the file path from the request"
	path := request url findTokens: '/'.
	path ifEmpty: [ ^self browseDir: DirectoryEntry currentDirectory request: request ].

	"Find the directory entry for the resource"
	fd := path allButLast inject: DirectoryEntry currentDirectory into: [ :dir :part | dir / part ].
	
	directoryEntry _ fd / path last.
	directoryEntry exists ifTrue: [
		"Send file listing. We handle this synchronously for simplicity."
		self browseDir: directoryEntry request: request.
		^ self].
	fileEntry _ fd // path last.
	fileEntry exists
	ifFalse: [^request send404Response ]
	ifTrue: [
		"Send file content. Since files can be large, we fork this off.
		However, since we forked it, we need to handle two different
		possible conditions:
			- closing the file in case of error
			- handling errors when sending it
		This makes the code below a bit ugly"
		[[
			file := fileEntry readStream.
			[ self browseFile: file request: request ]
				ensure: [ file close ] 	"close file even in case of error"
		] on: Error do: []				"ignore errors altogether"
		] fork. 							"fork it"
	]! !
!WebServer class methodsFor: 'examples' stamp: 'HAW 5/6/2020 09:45:44'!
doItFrom: req

	| data result |
	
	req isPostRequest 
		ifTrue:[
			"We fetch all of the data instead of streaming it"
			data := req content. ]
		ifFalse: [ req isGetRequest 
			ifTrue: [ data := req rawUrl unescapePercents allButFirst ]
			ifFalse: [ ^req send404Response ]].
		
	"Compute the result"
	result := [Compiler evaluate: data] on: Error do:[:ex| ex return: ex asString].
	req send200Response: result asString 
	! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/23/2010 09:30'!
exampleAuth		"WebServer exampleAuth"
	"Simple example requiring basic auth"

	| server port realm |
	port := 9999.
	server := WebServer reset default.
	
	"The realm to use for the server"
	realm := 'Example Realm'.

	"Add a sample user (note: password is hashed, not stored verbatim)"
	server passwordAt: 'squeak' realm: realm put: 'squeak'.

	server listenOn: port.
	server addService: '/' action:[:req| 
		server 
			authenticate: req 
			realm: realm
			methods: #(digest basic) 
			do:[self browseRequest: req]].
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/20/2010 14:54'!
exampleBrowse	"WebServer exampleBrowse"
	"This example implements a simple http server allowing to view 
	and download files (like browsing ftp sites etc)."

	| server port |
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server addService: '/' action:[:req| self browseRequest: req].
! !
!WebServer class methodsFor: 'examples' stamp: 'HAW 5/6/2020 09:40:26'!
exampleDoIt		"WebServer exampleDoIt"
	"This example executes doIts from a POST request.
	It's the simplest possible RPC interface to Squeak."

	| server port |

	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server addService: '/' action:[:req| self doItFrom: req ].
		
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 7/29/2010 18:49'!
exampleSSL: certName

	"This example implements a simple https server allowing to view 
	and download files (like browsing ftp sites etc):

		WebServer exampleSSL: 'Internet Widgits Pty'.
		WebServer exampleSSL: '/home/andreas/certs/testcert.pem'.

	"

	| server port |
	port := 8443.
	server := WebServer reset default.
	server accessLog: Transcript.
	server certName: certName.
	server listenOn: port.
	server addService: '/' action:[:req| self browseRequest: req].
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/25/2010 03:28'!
exampleSession		"WebServer exampleSession"
	"This example uses a simple session cookie to avoid 
	authentication for every request."

	| server port realm |
	realm := 'Example Realm'.	"authentication realm"
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.

	"Add a sample user (note: password is hashed, not stored verbatim)"
	server passwordAt: 'squeak' realm: realm put: 'squeak'.

	"Register the login service (sets cookie when successful)"
	server addService: '/login' action:[:req| 
		server  authenticate: req  realm: realm methods: #(digest)  do:[ | id |
			"Set the cookie and redirect back to /"
			server sessionAt: (id := UUID new hex) put: ''.
			req send302Response: (req fields at: 'url' ifAbsent:['/'])
				do:[:resp| resp setCookie: 'session' value: id path: '/']]].

	"Register the normal browse service"
	server addService: '/' action:[:req|
		"Check if we have a valid session cookie. If not redirect to login."
		(server sessionAt: (req cookieAt: 'session')) notNil
			ifTrue:[self browseRequest: req]
			ifFalse:[req send302Response: '/login?url=', req url encodeForHTTP]].
! !
!WebServer class methodsFor: 'accessing' stamp: 'ar 2/23/2010 09:29'!
default
	"A default WebServer instance. Mostly for the examples."

	^Default ifNil:[Default := self new].! !
!WebServer class methodsFor: 'accessing' stamp: 'ar 2/23/2010 09:29'!
reset		"WebServer reset"
	"Reset the default WebServer instance."

	Default ifNotNil:[
		Default destroy.
		Default := nil.
	].! !
!WebServer class methodsFor: 'accessing' stamp: 'DSG 5/29/2012 17:57'!
serverDate
	"Returns the date string to be used in responses"
	
	"FIXME: check http spec for time format"

	| date |
	^String streamContents:[:s|
		date := DateAndTime now asUTC.
		s nextPutAll: date dayOfWeekAbbreviation, ', '.
		date printOn: s.
		s nextPutAll: ' GMT'.
	].! !
!WebServer class methodsFor: 'accessing' stamp: 'jmv 6/25/2017 20:15:47'!
serverString
	"Returns the server string to be used in responses"

	^'WebServer/1.5 (',
		SystemVersion current version,'-',
		SystemVersion current highestUpdate printString, '; ',
		WebUtils platformName,')'
! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59'!
forUrl: urlString
	"Answer the WebServer registered for a given URL string."

	^self forUrl: urlString ifAbsent:[self newForUrl: urlString]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59'!
forUrl: urlString ifAbsent: aBlock
	"Answer the WebServer registered for a given URL string.
	If no WebServer is registered, evaluate aBlock."

	^self registry at: urlString ifAbsent: aBlock! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 21:02'!
newForUrl: urlString
	"Create a new WebServer instance registered for a given URL string."

	| server |
	"Out with the old ...."
	server := self removeUrl: urlString.
	server ifNotNil:[server destroy].

	"... and in with the new."
	server := self new.
	server siteUrl: urlString.
	self registry at: urlString put: server.
	^server
! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 21:11'!
registry
	"Answer the WebServer site registry"

	^Registry ifNil:[Registry := Dictionary new]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59'!
removeUrl: urlString
	"Remove and answer the WebServer registered for a given URL string.
	If no WebServer was registered, return nil."

	^self removeUrl: urlString ifAbsent:[nil]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59'!
removeUrl: urlString ifAbsent: aBlock
	"Remove and answer the WebServer registered for a given URL string."

	^self registry removeKey: urlString ifAbsent: aBlock! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 11:41'!
handle: selector arguments: argList

	^self handle: selector arguments: argList ifAbsent:[nil]! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 11:41'!
handle: selector arguments: argList ifAbsent: aBlock

	^(handlers at: selector ifAbsent:[^aBlock value])
		valueWithPossibleArgs: argList.! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:47'!
handleClose
	"Handle a connection close"

	^self handle: 'close' arguments: (Array with: self)
! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:46'!
handleError: exception
	"Handle an error"

	^self handle: 'error' arguments: (Array with: exception with: self)! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:45'!
handleMessage: msgData type: msgType
	"Handle an incoming message of the given type"

	self handle: 'message' arguments: (Array with: msgData with: msgType with: self)! !
!WebSocket methodsFor: 'private' stamp: 'ar 7/8/2010 21:48' overrides: 16902975!
printOn: aStream
	"Print the receiver"

	aStream nextPutAll: self class name.
	aStream nextPutAll: '(', name, ')'.! !
!WebSocket methodsFor: 'initialize' stamp: 'ar 9/26/2011 13:06'!
close
	"Request graceful close"

	^self subclassResponsibility! !
!WebSocket methodsFor: 'initialize' stamp: 'ar 9/27/2011 13:42' overrides: 16920235!
initialize
	super initialize.
	handlers := Dictionary new.! !
!WebSocket methodsFor: 'initialize' stamp: 'DSG 3/28/2015 20:00'!
on: aStream
	"Create a new WebSocket instance using the given SocketStream"

	stream := aStream.
	name := String streamContents:[:s| 
		stream socket remoteAddress 
			do:[:b| s print: b] 
			separatedBy:[s nextPut: $.]].
	name := name, ':', stream socket remotePort asString.
	! !
!WebSocket methodsFor: 'running' stamp: 'ar 7/8/2010 20:00'!
fork
	"Fork the WebSocket's input process."

	process := [self run] newProcess.
	process resume.
! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:46'!
onClose: aBlock
	"Set the handler block to invoke when the socket is closed"

	handlers at: 'close' put: aBlock.! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:45'!
onError: aBlock
	"Set the handler block to invoke when an error occurs"

	handlers at: 'error' put: aBlock.! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:45'!
onMessage: aBlock
	"Set the handler block to invoke when a message is received"

	handlers at: 'message' put: aBlock.
! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:41'!
run
	"Run the WebSocket's input process."

	^self subclassResponsibility! !
!WebSocket methodsFor: 'read/write' stamp: 'ar 9/26/2011 10:42'!
send: aString
	"Writes one frame worth of data"

	^self subclassResponsibility! !
!WebSocket methodsFor: 'accessing' stamp: 'ar 7/8/2010 21:39'!
timeout
	"The underlying stream timeout"

	^stream timeout! !
!WebSocket methodsFor: 'accessing' stamp: 'ar 7/8/2010 21:40'!
timeout: seconds
	"Sets the underlying stream timeout"

	^stream timeout: seconds! !
!WebSocket class methodsFor: 'example' stamp: 'jmv 6/25/2017 20:16:51'!
example	"WebSocket example"

	"This is a very simple WebSocket example implementing a basic chat system.
	Each message sent by a client connection is broadcast to everyone."

	| mutex sockets |
	mutex := Mutex new.
	sockets := OrderedCollection new.
	WebServer reset default listenOn: 8080.

	WebServer default addService: '/' action:[:req|
		"Serves the main html chat page"
		req send200Response: self examplePage contentType: 'text/html'.
	].

	WebServer default addService: '/broadcast' action:[:req| | ws |
		"Implements the WebSocket broadcaster"
		ws := req asWebSocket.
		ws timeout: 300. "5 minutes timeout"
	
		"Transcript log: 'New ', ws requestLine."
		Transcript log: 'New '.
		
		ws onMessage:[:data|
			mutex critical:[sockets do:[:s| s send: data]].
		].
		ws onClose:[
			Transcript log: 'Closing ', ws requestLine.
			mutex critical:[sockets remove: ws ifAbsent:[]].
		].
		ws onError:[:ex|
			Transcript log: ws requestLine.
			Transcript log: ex description.
			Transcript log: ex signalerContext longStack.
		].
		mutex critical:[sockets add: ws].

		"We don't need to #fork here, in fact we shouldn't since it ensures
		that shutting down WebServer shuts down any WebSockets, too."
		ws run.
	].! !
!WebSocket class methodsFor: 'example' stamp: 'ar 7/8/2010 21:50'!
examplePage
	"The example HTML page for WebServer"

	^'<html>
<p id="status">WebSocket: Not connected</p> 
<form> 
    <input type="text" id="chat" placeholder="type and press enter to chat" /> 
</form> 
<p>To test, open two windows with Web Socket support, type a message above and press return.</p> 
<ul id="log"></ul> 

<script>

var conn = {};
var log = document.getElementById("log");
var chat = document.getElementById("chat");
var form = chat.form;
var state = document.getElementById("status"); 
 
if (window.WebSocket === undefined) {
  state.innerHTML = "(WebSockets not supported)";
} else {
    conn = new WebSocket("ws://localhost:8080/broadcast");
    conn.onopen = function () {
      state.innerHTML = "WebSocket: Connected";
    };
 
    conn.onmessage = function (event) {
      log.innerHTML = "<li>" + event.data + "</li>" + log.innerHTML;
    };
    
    conn.onclose = function (event) {
      state.innerHTML = "WebSocket: Closed";
    };

	form.addEventListener("submit", function (event) {
		event.preventDefault();
		if (conn.readyState === 1) {
			conn.send(chat.value);      
			chat.value = "";
		}
	}, false);
};
 
</script> 

</body>
</html>'! !
!WebSocket class methodsFor: 'instance creation' stamp: 'ar 7/8/2010 18:22'!
on: aStream
	"Create a new WebSocket instance using the given SocketStream"

	^self new on: aStream! !
!WebSocket00 methodsFor: 'running' stamp: 'jmv 9/5/2016 20:49:42' overrides: 50627691!
close
	"Request graceful close"

	stream isConnected ifTrue:[
		stream nextPut: (Character numericValue: 255).
		stream nextPutAll: (Character numericValue: 0).
		stream flush.
	].
! !
!WebSocket00 methodsFor: 'running' stamp: 'ar 7/8/2010 21:49' overrides: 50627735!
run
	"Run the WebSocket's input process."

	[[[stream isConnected] whileTrue:[
		self readMessage.
		"XXXX: Should this be moved into handleMessage:type: ???"
		frameType = 255 ifTrue:[stream close. ^self].
		self handleMessage: frameData type: frameType.
	]] on: Error do:[:ex| self handleError: ex]] ensure:[
		[stream socket destroy] on: Error do:[:ex|].
		self handleClose.
	].
! !
!WebSocket00 methodsFor: 'read/write' stamp: 'jmv 9/5/2016 22:30:06'!
readMessage
	"Reads one frame worth of data"

	| byte length |
	byte := stream next ifNil:[
		frameType := 255.
		^nil].
	frameType := byte numericValue.
	frameType < 128 ifTrue:[
		"Frame type < 128: UTF-8 encoded text with 0xFF frame delimiter"
		frameData := String fromUtf8: (stream upTo: 255 asCharacter) asByteArray.
	] ifFalse:[
		"Frame type >= 128: Binary data with length prefix"
		length := 0.
		[byte := stream next numericValue.
		length := (length * 128) + (byte bitClear: 128).
		byte >= 128] whileTrue.
		frameData := ByteArray new: length.
		stream nextInto: frameData.
	].
! !
!WebSocket00 methodsFor: 'read/write' stamp: 'ar 9/26/2011 12:03' overrides: 50627740!
send: aString
	"Writes one frame worth of data"

	^self send: aString type: 0! !
!WebSocket00 methodsFor: 'read/write' stamp: 'NR 11/4/2022 18:48:54'!
send: data type: type
	"Writes one frame worth of data using the given frame type"

	"Frame type"
	stream nextPut: (Character numericValue: type).
	type < 128 ifTrue:[
		"Frame type < 128: UTF-8 encoded text with 0xFF frame delimiter"
		stream nextPutAll: data asString asUtf8Bytes.
		stream nextPut: (Character numericValue: 255).
	] ifFalse:[ | prefix length |
		"Frame type >= 128: Binary data with length prefix"
		prefix := ByteArray new.
		length := data size.
		[length > 127]  whileTrue:[
			prefix := prefix copyWith: prefix \\ 128.
			length := length // 128.
		].
		prefix := prefix copyWith: length.
		stream nextPutAll: prefix reversed.
		stream nextPutAll: data.
		stream flush.
	].
	stream flush.
! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 13:06' overrides: 50627691!
close
	"Send a close control request"

	closing ifFalse:[
		closing := true.
		self send: #[] code: 8.
	].! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 13:07'!
handleClose: payload
	"Close is being sent by remote in process of shutting down connection"

	closing ifFalse:[^self close].

	"We're done. We've received the close and responded to it"
	stream close.

! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:37'!
handleControl: payload type: opcode
	"Handle a control opcode"

	opcode caseOf: {
		[8]	-> [self handleClose: payload].
		[9]	-> [self handlePing: payload].
		[10] -> [self handlePong: payload].
	} otherwise:[self error: 'Unknown control request: ', opcode].

! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:41'!
handlePing: payload

	self handle: 'ping' 
		arguments: (Array with: payload with: self)
		ifAbsent:[self pong: payload].
! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:40'!
handlePong: payload

	self handle: 'pong' arguments: (Array with: payload with: self).! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:49'!
onPing: aBlock
	"Set the handler block to invoke when a ping is received"

	handlers at: 'ping' put: aBlock.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:49'!
onPong: aBlock
	"Set the handler block to invoke when a pong is received"

	handlers at: 'pong' put: aBlock.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:03'!
ping: data
	"Send a ping control request"

	self send: data code: 9.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:03'!
pong: data
	"Send a pong control request"

	self send: data code: 10.! !
!WebSocket07 methodsFor: 'read/write' stamp: 'NR 11/4/2022 18:48:59'!
firstFragment: aStringOrBytes
	"Writes the first fragment of data"

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8Bytes code: 1 final: false]
		ifFalse:[^self send: aStringOrBytes code: 2 final: false].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'NR 11/4/2022 18:49:06'!
lastFragment: aStringOrBytes
	"Writes the last fragment of data.
	Note: Spec says that code is ZERO for final fragment."

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8Bytes code: 0 final: true]
		ifFalse:[^self send: aStringOrBytes code: 0 final: true].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'NR 11/4/2022 18:49:10'!
nextFragment: aStringOrBytes
	"Writes the first fragment of data
	Note: Spec says that code is ZERO for intermediate fragments."

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8Bytes code: 0 final: false]
		ifFalse:[^self send: aStringOrBytes code: 0 final: false].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/27/2011 13:31'!
readFrame
	"Reads one frame worth of data"

	^self readFrameFrom: stream! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 9/5/2016 22:30:33'!
readFrameFrom: aStream
	"Reads one frame worth of data"

	| byte length final mask opcode payload |
	byte := (aStream next ifNil:[^nil]) numericValue.

	final := byte anyMask: 128.
	opcode := byte bitAnd: 15.

	byte := (aStream next ifNil:[^nil]) numericValue.
	mask := byte anyMask: 128.
	length := byte bitAnd: 127.

	length = 126 ifTrue:[
		length := self nextNumber: 2 from: aStream.
	] ifFalse:[
		length = 127 ifTrue:[length := self nextNumber: 8 from: aStream].
	].

	mask 
		ifTrue:[mask := aStream next: 4] 
		ifFalse:[mask := nil].

	payload := ByteArray new: length.
	aStream next: length into: payload.

	"Unmask payload"
	mask ifNotNil:[self xor: payload with: mask].

	"First see if this is a control frame which can be inserted into fragmented messages."
	opcode >= 8 ifTrue:[^self handleControl: payload type: opcode].

	"Now see if this is a fragmented message"
	frameType ifNil:[
		frameType := opcode.
		frameData := Array with: payload.
	] ifNotNil:[
		frameData := frameData copyWith: payload.
	].

	final ifTrue:[
		"This was the final fragment"
		frameData size = 1 ifTrue:[
			payload := frameData first
		] ifFalse:[
			payload := frameData allButFirst 
							inject: frameData first 
							into:[:each :next| each, next].
		].
		frameType = 1 ifTrue:[payload := String fromUtf8: payload asByteArray].
		self handleMessage: payload type: frameType.
		frameType := frameData := nil.
	].
! !
!WebSocket07 methodsFor: 'read/write' stamp: 'NR 11/4/2022 18:49:14' overrides: 50627740!
send: aStringOrBytes
	"Writes one frame worth of data"

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asString asUtf8Bytes code: 1]
		ifFalse:[^self send: aStringOrBytes code: 2].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/26/2011 12:48'!
send: data code: opcode
	"Sends unfragmented data using the given opcode"

	^self send: data code: opcode final: true! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/27/2011 13:47'!
send: data code: opcode final: isFinal
	"Sends unfragmented data using the given opcode"

	^self send: data code: opcode final: isFinal mask: self masking! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 4/11/2019 15:34:42'!
send: data code: opcode final: isFinal mask: doMask
	"Sends unfragmented data using the given opcode"

	| byte1 byte2 mask xLength copy |
	byte1 := opcode. "FIN = 1, RSV1=RSV2=RSV3=0"
	isFinal ifTrue:[byte1 := byte1 bitOr: 128].
	data size > 125 ifTrue:[
		data size > 16rFFFF ifTrue:[
			byte2 := 127.
			xLength := ByteArray new: 8.
			(WriteStream on: xLength)
				nextUnsignedInt32Put: data size >> 32 bigEndian: true;
				nextUnsignedInt32Put: (data size bitAnd: 16rFFFFFFFF) bigEndian: true.
		] ifFalse:[
			byte2 := 126.
			xLength := ByteArray new: 2.
			(WriteStream on: xLength) nextUnsignedInt16Put: data size bigEndian: true.
		].
	] ifFalse:[
		byte2 := data size.
		xLength := #[].
	].
	doMask ifTrue:[
		byte2 := byte2 bitOr: 128. "Mask = 1"
		mask := ByteArray new: 4.
		1 to: 4 do:[:i| mask at: i put: 256 atRandom-1].
		copy := data copy.
		self xor: copy with: mask.
	] ifFalse:[
		copy := data.
	].
	stream nextPut: byte1.
	stream nextPut: byte2.
	stream nextPutAll: xLength.
	mask ifNotNil:[stream nextPutAll: mask].
	stream nextPutAll: copy.
	stream flush.! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/26/2011 13:09'!
xor: data with: mask
	"XOR all the data using the given mask bytes.

	WARNING: Does inplace reversal; do not call with literal data."

	"This would be much faster w/ BitBlt but data may not be 
	4-byte aligned and so BB will barf."
	1 to: data size do:[:i|
		data byteAt: i put: ((data byteAt: i) bitXor: (mask byteAt: i-1 \\ 4 + 1)).
	].
! !
!WebSocket07 methodsFor: 'initialize' stamp: 'klub 6/13/2012 17:00' overrides: 50627696!
initialize

	super initialize.
	closing := false.
	masking := true. " 	http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07#section-4.1 says:
   ''Frames sent from the client to the server are masked to
   avoid confusing network intermediaries, such as intercepting proxies.''"! !
!WebSocket07 methodsFor: 'accessing' stamp: 'ar 9/27/2011 13:47'!
masking
	"If true, outgoing frames are masked."

	^masking! !
!WebSocket07 methodsFor: 'accessing' stamp: 'ar 9/27/2011 13:47'!
masking: aBool
	"If true, outgoing frames are masked."

	masking := aBool! !
!WebSocket07 methodsFor: 'private' stamp: 'jmv 9/5/2016 21:35:24'!
nextNumber: n from: aStream
	"Answer the next n bytes as a positive Integer or LargePositiveInteger."
	| s |
	s := 0.
	1 to: n do: 
		[:i | s := (s bitShift: 8) bitOr: aStream next numericValue].
	^ s normalize! !
!WebSocket07 methodsFor: 'running' stamp: 'ar 9/26/2011 12:40' overrides: 50627735!
run
	"Run the WebSocket's input process."

	[[[stream isConnected] whileTrue:[
		self readFrame.
	]] on: Error do:[:ex| self handleError: ex]] ensure:[
		[stream socket destroy] on: Error do:[:ex|].
		self handleClose.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 6/25/2017 19:16:15'!
decodeMultipartForm: aStream boundary: boundary do: aBlock
	"Parse the contents of a multipart/form-data submission.

	Evaluate aBlock with three parts: The headers, the (parsed) form-data
	arguments and the (undecoded) contents of the part. The sender is
	expected to take care of other issues such as content-transfer-encoding
	and similar headers."

	| skip headers content disposition index params |
	aStream upToAll: '--', boundary.
	[aStream atEnd or:[(skip := aStream next: 2) = '--']] whileFalse:[
		skip = String crlfString ifFalse:[self error: 'Error decoding multipart/form-data fields'].
		headers := Dictionary new.
		(WebUtils readHeadersFrom: aStream) do:[:hdr| headers add: hdr].
		content := aStream upToAll: String crlfString, '--', boundary.
		params := Dictionary new.
		disposition := headers at: 'content-disposition' ifAbsent:[''].
		#(name filename) do:[:arg| | len val |
			len := arg size + 2.
			index := disposition findString: arg,'='.
			index > 0 ifTrue:[
				val := disposition copyFrom: index + len to: (disposition indexOf: $" startingAt: index+len) - 1.
				params at: arg put: val.
			].
		].
		aBlock value: headers value: params value: content.
	].! !
!WebUtils class methodsFor: 'decoding' stamp: 'ar 2/21/2010 09:54'!
decodeUrlEncodedForm: aString
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	^self decodeUrlEncodedForm: aString multipleValues: false! !
!WebUtils class methodsFor: 'decoding' stamp: 'DSG 5/24/2012 21:19'!
decodeUrlEncodedForm: aString do: aBlock
	"Decodes the fields embedded in the url ?var1=val1&var2=val2.
	Evaluates aBlock with the key/value pairs defined in the fields."

	| args keyval index key value |
	args := aString readStream.
	[args atEnd] whileFalse:[
		keyval := args upTo: $&.
		(index := keyval indexOf: $=) = 0 ifTrue:[
			key := keyval.
			value := ''.
		] ifFalse:[
			key := keyval copyFrom: 1 to: index-1.
			value := keyval copyFrom: index +1 to: keyval size.
		].
		key := key unescapePercents.
		value := value unescapePercents.
		aBlock value: key value: value.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'ar 7/20/2010 20:37'!
decodeUrlEncodedForm: aString multipleValues: aBool
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	| fields |
	fields := Dictionary new.
	self decodeUrlEncodedForm: aString do:[:key :value|
		aBool 
			ifTrue:[fields at: key put: (fields at: key ifAbsent:['']), value]
			ifFalse:[fields at: key put: value].
	].
	^fields! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 6/26/2017 19:54:45'!
encodeMultipartForm: fieldMap boundary: boundary
	"Encodes the fieldMap as multipart/form-data.

	The fieldMap may contain MIMEDocument instances to indicate the presence
	of a file to upload to the server. If the MIMEDocument is present, its
	content type and file name will be used for the upload.

	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	^String streamContents:[:stream|
		(fieldMap as: Dictionary) keysAndValuesDo:[:fieldName :fieldValue | | fieldContent |
			"Write multipart boundary and common headers"
			stream nextPutAll: '--', boundary; nextPutAll: String crlfString.
			stream nextPutAll: 'Content-Disposition: form-data; name="', fieldName, '"'.
			"Figure out if this is a file upload - This code was deleted. Cuis does not currently include MIMEDocument. See Squeak."
			fieldContent := fieldValue.
			stream nextPutAll: String crlfString; nextPutAll: String crlfString.
			stream nextPutAll: fieldContent asString.
			stream nextPutAll: String crlfString.
		].
		stream nextPutAll: '--', boundary, '--', String crlfString.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 5/19/2015 23:52'!
encodeUrlEncodedForm: fieldMap
	"Encodes the fieldsMap in the form of var1=val1&var2=val2.
	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	| associations |
	associations := (fieldMap isKindOf: Dictionary) ifTrue:[fieldMap associations] ifFalse:[fieldMap].
	^String streamContents:[:s|
		associations do:[:assoc|
			s nextPutAll: assoc key encodeForHTTP.
			assoc value ifNotNil:[
				s nextPutAll: '='.
				s nextPutAll: assoc value asString encodeForHTTP
			].
		] separatedBy:[s nextPutAll:'&'].
	].! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 5/19/2015 21:52'!
multipartBoundary
	"Answer a string to be used as multpart boundary in posts"

	^'----squeak-', Date today printString,'-', Time localMillisecondClock printString, '-webclient-----'.! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/24/2017 13:59:29'!
defaultProxyServer
	"Answer the default proxy server to use."
	^ currentProxyServer ! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/24/2017 14:00:05'!
defaultProxyServer: aString
	"Set the default proxy server to use."
	currentProxyServer _ aString ! !
!WebUtils class methodsFor: 'proxy' stamp: 'DSG 12/4/2013 23:03'!
proxyExceptionsDo: aBlock
	"Evaluate aBlock with all registered proxy exceptions. 
	Uses the information from HTTPSocket."

	"HTTPSocket httpProxyExceptions do: aBlock."! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/27/2017 12:06:52'!
proxyServerFor: serverName
	"Answer the proxy server to use for the given server:port
	Returns the proxy server:port to use or nil if no proxy is required."

	| domain |
	domain := serverName copyUpTo: $:.
	self proxyExceptionsDo:[:pattern| (pattern match: domain) ifTrue:[^nil]].
	^self defaultProxyServer! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 7/20/2010 20:38'!
extractWebSocketKey: field
	"Decodes a WebSocket key:

		Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8
		Sec-WebSocket-Key2: 1_ tx7X d  <  nw  334J702) 7]o}` 0

		For each of these fields, the server has to take the digits from the
		 value to obtain a number (in this case 1868545188 and 1733470270
		respectively), then divide that number by the number of spaces
		characters in the value (in this case 12 and 10) to obtain a 32-bit
		number (155712099 and 173347027).  These two resulting numbers are
		then used in the server handshake, as described below.
	"

	| digits spaces |
	digits := spaces := 0.
	field do:[:ch|
		ch isDigit ifTrue:[digits := digits * 10 + ch digitValue].
		ch = $ ifTrue:[spaces := spaces + 1].
	].
	^digits // spaces.
! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 7/8/2010 18:59'!
webSocketHandshake: key1 with: key2 with: data
	"Do the actual WebSocket handshake computation"

	| bytes |
	bytes := ByteArray new: 16.
	bytes longAt: 1 put: key1 bigEndian: true.
	bytes longAt: 5 put: key2 bigEndian: true.
	bytes replaceFrom: 9 to: 16 with: data.
	^(self md5HashStream: bytes readStream) reversed! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:30'!
webSocketHash07: key
	"Do the actual WebSocket hash computation"

	| uid |
	uid := '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'.
	^(ByteArray newFrom: (SecureHashAlgorithm new hashMessage: key, uid)) reversed base64Encoded! !
!WebUtils class methodsFor: 'auth' stamp: 'NR 11/4/2022 18:49:20'!
handleAuth: aBlock
	"Utility method to handle web authentication requests interactively.

	Use like here:
		| wc |
		wc := WebClient new.
		WebUtils handleAuth:[wc httpGet: 'http://some.auth.required'].
	"

	| user pass |
	^[aBlock value] on: WebAuthRequired do:[:ex|
		"Allow outer handlers to take over authentication"
		ex isNested ifFalse:[
			user := FillInTheBlankMorph request:  ex message, 
				'\Please enter your user name:' initialAnswer:''.
			user ifNotEmpty:[
				"Just a little obfuscation to avoid completely plain passwords"
				pass := (FillInTheBlankMorph request:
					'Please enter the password for "', user,'":') asUtf8Bytes base64Encoded.
				 ex username: user password: [String fromUtf8: pass base64Decoded]]].
		ex pass].! !
!WebUtils class methodsFor: 'oauth' stamp: 'DSG 3/28/2015 23:22'!
hmacSha1: message key: signKey
	"Compute the SHA1 HMAC for the given message"

	| blockSize key ipad opad |
	blockSize := 64. "SHA1 block size"
	key := signKey asByteArray.
	key size > blockSize ifTrue:[key := self sha1Hash: key].
	key size < blockSize ifTrue:[key := key, (ByteArray new: blockSize - key size)].
	ipad := ByteArray new: blockSize withAll: 16r36.
	opad := ByteArray new: blockSize withAll: 16r5C.
	^self sha1Hash: 
		(key with: opad collect:[:b1 :b2| b1 bitXor: b2]), 
		(self sha1Hash: (key with: ipad collect:[:b1 :b2| b1 bitXor: b2]), message)! !
!WebUtils class methodsFor: 'oauth' stamp: 'jmv 6/25/2017 19:16:16'!
oAuthSign: webRequest url: requestUrl extra: postFields using: params
	"Sign the given webRequest using the set of oauth parameters provided"

	| epoch timestamp nonce normalized baseString query signature key header extraKeys baseUrl |

	"Allow providing an oauth_timestamp; HOWEVER this is only useful for
	tests etc. For actual API calls the timestamp *must* match real-time closely
	or else the request will be rejected".

	timestamp := params at: 'oauth_timestamp' ifAbsent:[
		"Timestamp is relative to Jan. 1st 1970 GMT"
		epoch := DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0 
			offset: (Duration seconds: 0).
		(DateAndTime now asUTC - epoch) totalSeconds.
	].

	"Same for nonces (although nonces can be reused)"
	nonce := params at: 'oauth_nonce' ifAbsent:[UUID new hex].

	"Assemble the required parameters. Start with the (POST) body fields."
	normalized := (postFields as: Dictionary) associations asOrderedCollection.

	"If present, extract any (GET) fields from the URL"
	(requestUrl copyAfter: $?) ifNotEmpty:[:fields|
		self decodeUrlEncodedForm: fields do:[:fkey :fval| normalized add: fkey -> fval]].

	"Keep the extra argument keys so we can exclude them below"
	extraKeys := Set newFrom: (normalized collect:[:assoc| assoc key]).
	normalized add:('oauth_nonce' -> nonce).
	normalized add: ('oauth_timestamp' -> timestamp asString).
	
	normalized add: (params associationAt: 'oauth_consumer_key').
	normalized add: (params associationAt: 'oauth_signature_method').
	normalized add: (params associationAt: 'oauth_version').

	(params includesKey: 'oauth_callback') ifTrue:[
		normalized add: (params associationAt: 'oauth_callback').
	].
	(params includesKey: 'oauth_token') ifTrue:[
		normalized add: (params associationAt: 'oauth_token').
	].
	(params includesKey: 'oauth_verifier') ifTrue:[
		normalized add: (params associationAt: 'oauth_verifier').
	].

	normalized := normalized sort:[:a1 :a2| 
		a1 key = a2 key 
			ifTrue:[a1 value <= a2 value]
			ifFalse:[a1 key <= a2 key]].

	query := String streamContents:[:s|
		normalized do:[:assoc|
			s nextPutAll: assoc key.
			s nextPutAll: '='.
			s nextPutAll: assoc value encodeForHTTP.
		] separatedBy:[s nextPutAll: '&'].
	].

	baseUrl := (requestUrl copyUpTo: $?) copyUpTo: $#.
	baseString := webRequest method, 
		'&', baseUrl encodeForHTTP, 
		'&',  query encodeForHTTP.

	key := (params at: 'oauth_consumer_secret'), 
			'&', (params at: 'oauth_token_secret' ifAbsent:['']).
	(params at: 'oauth_signature_method') caseOf: {
		['HMAC-SHA1'] -> [
			signature := (WebUtils hmacSha1: baseString key: key) base64Encoded
		].
	} otherwise:[self error: 'Unsupported signature method'].

	header := String streamContents:[:s|
		s nextPutAll: 'OAuth '.
		"Even though we need to include the extra args in the computation,
		they do NOT go into the OAuth header field."
		normalized do:[:assoc|
			(extraKeys includes: assoc key) 
				ifFalse:[ s nextPutAll: assoc key, '="', assoc value encodeForHTTP, '",']].
		s nextPutAll: 'oauth_signature="', signature encodeForHTTP, '"'.
	].

	webRequest headerAt: 'Authorization' put: header.! !
!WebUtils class methodsFor: 'oauth' stamp: 'ar 8/23/2010 21:55'!
oAuthSign: webRequest url: requestUrl using: params
	"Sign the given webRequest using the set of oauth parameters provided"

	^self oAuthSign: webRequest url: requestUrl extra: #() using: params! !
!WebUtils class methodsFor: 'oauth' stamp: 'ar 8/12/2010 16:31'!
sha1Hash: message
	"Compute the SHA1 hash for the given message. Slightly different from 
	SecureHashAlgorithm to produce fixed-length byte arrays."

	| sha hash |
	sha := SecureHashAlgorithm new hashMessage: message.
	hash := ByteArray new: 20.
	1 to: 20 do:[:i| hash at: i put: (sha digitAt: 21-i)].
	^hash
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39'!
jsonArray: anArray on: stream
	"Encodes an array"

	stream nextPut: $[.
	anArray 
		do:[:each| self jsonObj: each on: stream]
		separatedBy:[stream nextPutAll:', '].
	stream nextPut:$].
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39'!
jsonChar: aCharacter on: stream
	"Writes a single encoded character"

	| ascii |
	ascii := aCharacter asciiValue.

	ascii < 32 ifTrue:["Control character"
		ascii caseOf: {
			[13]	-> [^stream nextPutAll: '\r'].
			[12]	-> [^stream nextPutAll: '\f'].
			[10]	-> [^stream nextPutAll: '\n'].
			[9]		-> [^stream nextPutAll: '\t'].
			[8]		-> [^stream nextPutAll: '\b'].
		} otherwise:[
			^stream nextPutAll: '\u'; nextPutAll: 
				((ascii printStringBase: 16) padded: #left to: 4 with: $0)
		].
	].

	(ascii >= 32 and:[ascii <=127]) ifTrue:["Ascii character"
		(ascii = 34 or:[ascii = 92 or:[ascii = 47]]) ifTrue:[stream nextPut: $\].
		^stream nextPut: aCharacter
	].

	"Encode other characters (control chars, accents, umlauts, unicode)"
	stream nextPutAll:  
		'\u', (((ascii bitAnd: 16rFFFF) printStringBase: 16) padded: #left to: 4 with: $0).
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:41'!
jsonEncode: anObject
	"Encode the given object as JSON"

	^String streamContents:[:s| self jsonObj: anObject on: s]! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:40'!
jsonMap: aDictionary on: stream
	"Encodes a dictionary"

	stream nextPut: ${.
	"Sorting keys ensures deterministic order"
	aDictionary keys asArray sort do:[:key|
		self jsonString: key on: stream.
		stream nextPutAll:': '.
		self jsonObj: (aDictionary at: key) on: stream.
	] separatedBy:[stream nextPutAll: ', '].
	stream nextPut: $}.! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:38'!
jsonNumber: aNumber on: stream
	"Encodes a number"

	| value |
	value := aNumber.
	value isInteger ifFalse:[value := aNumber asFloat].
	stream print: aNumber.
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'jmv 6/26/2017 19:34:55'!
jsonObj: anObject on: stream
	"Encode a generic object"

	anObject isString ifTrue:[^self jsonString: anObject on: stream].
	anObject isNumber ifTrue:[^self jsonNumber: anObject on: stream].
	anObject == nil ifTrue:[^stream nextPutAll: 'null'].
	anObject == true ifTrue:[^stream nextPutAll: 'true'].
	anObject == false ifTrue:[^stream nextPutAll: 'false'].
	anObject isArray ifTrue:[^self jsonArray: anObject on: stream].
	(anObject is: #Dictionary) ifTrue:[^self jsonMap: anObject on: stream].

	self error: 'Cannot encode: ', anObject! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39'!
jsonString: aString on: stream
	"Encodes a string"

	stream nextPut: $".
	aString do:[:ch| self jsonChar: ch on: stream].
	stream nextPut: $".
! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43'!
jsonArrayFrom: stream
	"Decodes a JSON [value, *] array from the stream"

	| ch result |
	(ch := stream next) = $[ ifFalse:[^self error: 'JSON Array expected'].
	stream skipSeparators.
	stream peek = $] ifTrue:[stream next. ^#()].
	result := WriteStream on: (Array new: 10).
	["Decode the next value"
	stream skipSeparators.
	result nextPut: (self jsonDecode: stream).
	stream skipSeparators.
	(ch := stream next) = $]] whileFalse:[
		ch = $, ifFalse:[^self error: 'Comma expected'].
	].

	^result contents! !
!WebUtils class methodsFor: 'json-decode' stamp: 'jmv 6/26/2017 19:52:56'!
jsonCharFrom: stream on: writeStream
	"Decodes a backslash-escaped character"

	| ch decoded |
	ch := stream next.
	ch = $u ifTrue: [
		String
			addUnicodeCodePoint: (Integer readFrom: (stream next: 4) readStream base: 16)
			to: writeStream
			hex: true.
		^ self ].
	decoded _ ch caseOf: {
		[$r] 	-> 	[Character cr].
		[$n] 	-> 	[Character lf].
		[$t] 	-> 	[Character tab].
		[$b] 	->	[Character backspace].
		[$f] 	->	[Character newPage].
	} otherwise: [ch].
	writeStream nextPut: decoded! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:48'!
jsonDecode: stream
	"Decodes an arbitrary JSON encoded value from the given stream"

	stream skipSeparators.
	^stream peek caseOf: {
		[$"]		->	[self jsonStringFrom: stream].
		[$t]		->	[self jsonTrueFrom: stream].
		[$f]		->	[self jsonFalseFrom: stream].
		[$n]		->	[self jsonNullFrom: stream].
		[${]		-> 	[self jsonMapFrom: stream].
		[$[]		->	[self jsonArrayFrom: stream].
	} otherwise:[self jsonNumberFrom: stream].
! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43'!
jsonFalseFrom: stream
	"Decodes 'false' from aStream"

	((stream next: 5) = 'false' 
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			ifFalse:[^self error: 'Expected ''false'''].
	^false! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:45'!
jsonMapFrom: stream
	"Decodes a JSON {key:value, *} object from the stream"

	| map ch key value |
	map := Dictionary new.
	(ch := stream next) = ${ ifFalse:[^self error: 'JSON Object expected'].
	stream skipSeparators.
	stream peek = $} ifTrue:[^map].

	["Decode the next key:value pair"
	stream skipSeparators.
	key := self jsonStringFrom: stream.
	stream skipSeparators.
	stream next = $: ifFalse:[^self error: 'Key-value pair expected'].
	value := self jsonDecode: stream.
	map at: key put: value.
	stream skipSeparators.
	(ch := stream next) = $}] whileFalse:[
		ch = $, ifFalse:[^self error: 'Comma expected'].
	].

	^map! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43'!
jsonNullFrom: stream
	"Decodes 'null' from aStream"

	((stream next: 4) = 'null'
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			ifFalse:[^self error: 'Expected ''null'''].
	^nil! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:44'!
jsonNumberFrom: stream
	"Decodes a JSON number from the stream"

	| ascii integer fraction scale sign expSign exponent value ch |
	integer := fraction := 0. sign := scale := exponent := expSign := 1.
	ascii := stream next asciiValue.
	ascii = 45 "$- asciiValue" ifTrue:[
		sign := -1.
		ascii := stream next asciiValue.
	].
	"JSON requires at least one digit"
	(ascii >= 48 and:[ascii <= 57]) ifFalse:[^self error: 'Digit expected'].

	"Read the integer part"
	integer := ascii - 48.
	[ch := stream next ifNil:[^integer * sign].
	ascii := ch asciiValue.
	ascii >= 48 and:[ascii <= 57]] whileTrue:[
		integer := (integer * 10) + (ascii - 48).
	].

	ascii = 46 "$. asciiValue" ifTrue:[
		"Read the fraction part"
		[ch := stream next ifNil:[^(integer * scale + fraction * sign) asFloat / scale].
		ascii := ch asciiValue.
		ascii >= 48 and:[ascii <= 57]] whileTrue:[
			fraction := (fraction * 10) + (ascii - 48).
			scale := scale * 10.
		].
		value := (integer * scale + fraction * sign) asFloat / scale asFloat.
	] ifFalse:[value := integer * sign].

	(ascii =  69 "$E asciiValue" or:[ascii =  101 "$e asciiValue"]) ifTrue:[
		"Read exponent"
		ascii := stream next asciiValue.
		ascii = $- ifTrue:[
			expSign := -1.
			ascii := stream next asciiValue.
		] ifFalse:[ascii = $+ ifTrue:[ascii := stream next asciiValue]].
		exponent := ascii - 48.
		[ch := stream next ifNil:[^value * (10 raisedTo: expSign * exponent)].
		ascii := ch asciiValue.
		ascii >= 48 and:[ascii <= 57]] whileTrue:[
			exponent := (exponent * 10) + (ascii - 48).			
		].
		exponent := exponent * expSign.
	].

	"Skip back before last character since number might be part of a sequence
	like 1, 2, 3, 4, etc (which would eat the trailing comma)"
	ch isAlphaNumeric ifTrue:[^self error: 'Delimiter expected'].
	stream skip: -1.

	exponent = 1 ifFalse:[
		exponent < 0 ifTrue:[value := value asFloat].
		value := value * (10 raisedTo: exponent).
	].
	^value! !
!WebUtils class methodsFor: 'json-decode' stamp: 'jmv 6/26/2017 19:49:10'!
jsonStringFrom: stream
	"Decodes a JSON encoded string"

	| ch result |
	(ch := stream next) = $" 
		ifFalse:[^self error: 'String expected'].
	result := WriteStream on: (String new: 20).
	[(ch := stream next) == nil] whileFalse:[
		ch = $" ifTrue:[^result contents].
		ch = $\
			ifTrue: [ self jsonCharFrom: stream on: result ]
			ifFalse: [ result nextPut: ch ].
	].
	^self error: 'Unterminated string'! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:46'!
jsonTrueFrom: stream
	"Decodes 'true' from aStream"

	((stream next: 4) = 'true'
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			 ifFalse:[^self error: 'Expected ''true'''].
	^true! !
!WebUtils class methodsFor: 'misc' stamp: 'DSG 3/28/2015 22:49'!
logEntryFor: request response: response
	"Create a log entry in common log format from the given request / response"

	| entry logdate logsize |

	"CLF prints date as [day/month/year:hour:min:sec zone]"
	logdate := String streamContents:[:s| | date |
		date := DateAndTime fromSeconds: Time localSecondClock.
		s nextPut: $[.
			date date printOn: s format: #( 1 2 3 $/ 2 1 2).
		s nextPut: $:.
			date time print24: true on: s.
		s nextPutAll:(' ',
			(date offset hours >= 0 ifTrue:['+'] ifFalse:['-']),
			(date offset hours abs asString padded: #left to: 2 with: $0),
			(date offset minutes abs asString padded: #left to: 2 with: $0)
		).
		s nextPut: $].
	].

	"CLF prints zero length as - "
	logsize := response contentLength ifNil:[0].
	logsize = 0 ifTrue:[logsize := '-'].

	entry := String streamContents:[:s|
		s 
			nextPutAll: (request remoteHost ifNil:[
				"Substitute with the host header"
				(request headerAt: 'host') copyUpTo: $:
			]);
			nextPutAll: ' -'; 	"RFC 1413 identity of client"
			nextPutAll: ' -';	"TODO: userid of authenticated user"
			nextPutAll: ' ', logdate;
			nextPutAll: ' "', request requestLine, '"';
			nextPutAll: ' ', response code asString;
			nextPutAll: ' ', logsize asString.
	].
	^entry
! !
!WebUtils class methodsFor: 'misc' stamp: 'pb 5/25/2016 01:29'!
logRequest: request response: response on: streamOrFilename
	"Log a request in common log format on the given stream / file."

	| entry |

	"Create the log entry for the request/response pair"
	entry := self logEntryFor: request response: response.

	"If the argument is a string, it represents the file name to log to"
	streamOrFilename isString
		ifTrue: [
			streamOrFilename asFileEntry appendStreamDo: [ :stream |
				stream nextPutAll: entry; newLine ]]
		ifFalse: [
			streamOrFilename nextPutAll: entry; newLine.
			streamOrFilename flush ]! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 7/21/2010 00:09'!
mcVersion
	"Answers the Monticello version of WebServer's MC package"

	| version |
	Smalltalk at: #MCWorkingCopy ifPresent:[:mc|
		mc managersForClass: self do:[:wc|
			wc ancestors ifNotEmpty:[:ancestry| version := ancestry first name]]].
	^version ifNil:[''].! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 11/17/2011 10:16'!
platformName
	"Return the name of the platform we're running on."

	^Smalltalk getSystemAttribute: 1001! !
!WebUtils class methodsFor: 'misc' stamp: 'DSG 3/28/2015 19:59'!
urlEncode: urlString
	"For backwards compatibility only. Use 'urlString urlEncoded' if you can."

	^urlString encodeForHTTP! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 11/17/2011 10:06'!
vmVersion	
	"Return a string identifying the interpreter version"

	^Smalltalk getSystemAttribute: 1004! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/20/2010 12:45'!
md5Digest: aStringOrByteArray
	"This creates a little endian hex string to be used with various auth methods
	This is the same as htdigest (apache) uses for its md5 digest auth db"

	^(self md5HashStream: (ReadStream on: aStringOrByteArray asByteArray)) reversed hex! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/25/2010 23:29'!
md5HashStream: aStream
	"self md5HashStream: (ReadStream on: 'foo')"

	| start buffer bytes sz n words hash |
	hash := WordArray 
		with: 16r67452301 
		with: 16rEFCDAB89 
		with: 16r98BADCFE 
		with: 16r10325476.
	words := WordArray new: 16.
	buffer := ByteArray new: 64.
	start := aStream position.
	[aStream atEnd] whileFalse: [
		bytes := aStream nextInto: buffer.
		(bytes size < 64 or:[aStream atEnd]) ifTrue:[
			sz := bytes size.
			buffer replaceFrom: 1 to: sz with: bytes startingAt: 1.
			buffer from: sz+1 to: buffer size put: 0.
			sz < 56 ifTrue:[
				buffer at: sz + 1 put: 128. "trailing bit"
			] ifFalse:[
				"not enough room for the length, so just pad this one, then..."
				sz < 64 ifTrue:[buffer at: sz + 1 put: 128].
				1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].
				self md5Transform: words hash: hash.
				"process one additional block of padding ending with the length"
				buffer atAllPut: 0.
				sz = 64 ifTrue: [buffer at: 1 put: 128].
			].
			"Fill in the final 8 bytes with the 64-bit length in bits."
			n := (aStream position - start) * 8.
			7 to: 0 by: -1 do:[:i| buffer at: (buffer size - i) put: ((n bitShift: 7 - i * -8) bitAnd: 255)].
		].
		1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].
		self md5Transform: words hash: hash.
	].
	bytes := ByteArray new: 16.
	bytes unsignedLongAt: 1 put: (hash at: 4) bigEndian: true.
	bytes unsignedLongAt: 5 put: (hash at: 3) bigEndian: true.
	bytes unsignedLongAt: 9 put: (hash at: 2) bigEndian: true.
	bytes unsignedLongAt: 13 put: (hash at: 1) bigEndian: true.
	^bytes
! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
md5Transform: in hash: hash
	"This adds the incoming words to the existing hash"

	| a b c d |
	<primitive: 'primitiveMD5Transform' module: 'CroquetPlugin'>
	a := hash at: 1.
	b := hash at: 2.
	c := hash at: 3.
	d := hash at: 4.

	a := self step1: a x: b y: c z: d data: (in at:  1) add: 16rD76AA478 shift: 7.
	d := self step1: d x: a y: b z: c data: (in at:  2) add: 16rE8C7B756 shift: 12.
	c := self step1: c x: d y: a z: b data: (in at:  3) add: 16r242070DB shift: 17.
	b := self step1: b x: c y: d z: a data: (in at:  4) add: 16rC1BDCEEE shift: 22.
	a := self step1: a x: b y: c z: d data: (in at:  5) add: 16rF57C0FAF shift:  7.
	d := self step1: d x: a y: b z: c data: (in at:  6) add: 16r4787C62A shift: 12.
	c := self step1: c x: d y: a z: b data: (in at:  7) add: 16rA8304613 shift: 17.
	b := self step1: b x: c y: d z: a data: (in at:  8) add: 16rFD469501 shift: 22.
	a := self step1: a x: b y: c z: d data: (in at:  9) add: 16r698098D8 shift:  7.
	d := self step1: d x: a y: b z: c data: (in at: 10) add: 16r8B44F7AF shift: 12.
	c := self step1: c x: d y: a z: b data: (in at: 11) add: 16rFFFF5BB1 shift: 17.
	b := self step1: b x: c y: d z: a data: (in at: 12) add: 16r895CD7BE shift: 22.
	a := self step1: a x: b y: c z: d data: (in at: 13) add: 16r6B901122 shift:  7.
	d := self step1: d x: a y: b z: c data: (in at: 14) add: 16rFD987193 shift: 12.
	c := self step1: c x: d y: a z: b data: (in at: 15) add: 16rA679438E shift: 17.
	b := self step1: b x: c y: d z: a data: (in at: 16) add: 16r49B40821 shift: 22.

	a := self step2: a x: b y: c z: d data: (in at:  2) add: 16rF61E2562 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at:  7) add: 16rC040B340 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at: 12) add: 16r265E5A51 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  1) add: 16rE9B6C7AA shift: 20.
	a := self step2: a x: b y: c z: d data: (in at:  6) add: 16rD62F105D shift:  5.
	d := self step2: d x: a y: b z: c data: (in at: 11) add: 16r02441453 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at: 16) add: 16rD8A1E681 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  5) add: 16rE7D3FBC8 shift: 20.
	a := self step2: a x: b y: c z: d data: (in at: 10) add: 16r21E1CDE6 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at: 15) add: 16rC33707D6 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at:  4) add: 16rF4D50D87 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  9) add: 16r455A14ED shift: 20.
	a := self step2: a x: b y: c z: d data: (in at: 14) add: 16rA9E3E905 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at:  3) add: 16rFCEFA3F8 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at:  8) add: 16r676F02D9 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at: 13) add: 16r8D2A4C8A shift: 20.

	a := self step3: a x: b y: c z: d data: (in at:  6) add: 16rFFFA3942 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  9) add: 16r8771F681 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at: 12) add: 16r6D9D6122 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at: 15) add: 16rFDE5380C shift: 23.
	a := self step3: a x: b y: c z: d data: (in at:  2) add: 16rA4BEEA44 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  5) add: 16r4BDECFA9 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at:  8) add: 16rF6BB4B60 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at: 11) add: 16rBEBFBC70 shift: 23.
	a := self step3: a x: b y: c z: d data: (in at: 14) add: 16r289B7EC6 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  1) add: 16rEAA127FA shift: 11.
	c := self step3: c x: d y: a z: b data: (in at:  4) add: 16rD4EF3085 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at:  7) add: 16r04881D05 shift: 23.
	a := self step3: a x: b y: c z: d data: (in at: 10) add: 16rD9D4D039 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at: 13) add: 16rE6DB99E5 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at: 16) add: 16r1FA27CF8 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at:  3) add: 16rC4AC5665 shift: 23.

	a := self step4: a x: b y: c z: d data: (in at:  1) add: 16rF4292244 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at:  8) add: 16r432AFF97 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at: 15) add: 16rAB9423A7 shift: 15.
	b := self step4: b x: c y: d z: a data: (in at:  6) add: 16rFC93A039 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at: 13) add: 16r655B59C3 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at:  4) add: 16r8F0CCC92 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at: 11) add: 16rFFEFF47D shift: 15.
	b := self step4: b x: c y: d z: a data: (in at:  2) add: 16r85845DD1 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at:  9) add: 16r6FA87E4F shift:  6.
	d := self step4: d x: a y: b z: c data: (in at: 16) add: 16rFE2CE6E0 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at:  7) add: 16rA3014314 shift: 15.
	b := self step4: b x: c y: d z: a data: (in at: 14) add: 16r4E0811A1 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at:  5) add: 16rF7537E82 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at: 12) add: 16rBD3AF235 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at:  3) add: 16r2AD7D2BB shift: 15.
	b := self step4: b x: c y: d z: a data: (in at: 10) add: 16rEB86D391 shift: 21.

	a := (a + (hash at: 1)) bitAnd: 16rFFFFFFFF. hash at: 1 put: a.
	b := (b + (hash at: 2)) bitAnd: 16rFFFFFFFF. hash at: 2 put: b.
	c := (c + (hash at: 3)) bitAnd: 16rFFFFFFFF. hash at: 3 put: c.
	d := (d + (hash at: 4)) bitAnd: 16rFFFFFFFF. hash at: 4 put: d.

	^hash! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
rotate: value by: amount
	"Rotate value left by amount"

	| lowMask highMask |
	lowMask := (1 bitShift: 32-amount) - 1.
	highMask := 16rFFFFFFFF - lowMask.
	^((value bitAnd: lowMask) bitShift: amount) + 
		((value bitAnd: highMask) bitShift: amount-32)! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
step1: w x: x y: y z: z data: data add: add shift: s
	"Step 1 in MD5 transformation"

	| f result |
	f := z bitXor: (x bitAnd: (y bitXor: z)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
step2: w x: x y: y z: z data: data add: add shift: s
	"Step 2 in MD5 transformation"

	| f result |
	f := y bitXor: (z bitAnd: (x bitXor: y)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
step3: w x: x y: y z: z data: data add: add shift: s
	"Step 3 in MD5 transformation"

	| f result |
	f := (x bitXor: y) bitXor: z.
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28'!
step4: w x: x y: y z: z data: data add: add shift: s
	"Step 4 in MD5 transformation"

	| f result |
	f := y bitXor: (x bitOr: (z  bitXor: 16rFFFFFFFF)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'auth utils' stamp: 'DSG 12/5/2013 17:20'!
parseAuthParams: authHeader
	"Parse the auth header to find authentication parameters"

	| authParams stream key value|
	authParams := Dictionary new.
	stream := ReadStream on: authHeader.
	authParams at: 'method' put: (stream upTo: Character space) asLowercase.
	[stream skipSeparators.
	stream atEnd] whileFalse:[
		key := stream upTo: $=.
		stream skipSeparators.
		stream peek = $" 
			ifTrue:[value := stream next; upTo: $". stream upTo: $,]
			ifFalse:[value := stream upToAny: ' ,' asCharacterSet].
		authParams at: key asLowercase put: value.
	].
	^authParams! !
!WebUtils class methodsFor: 'quoting' stamp: 'ar 3/31/2010 08:43'!
quote: aString
	"Quote the given string, escaping as necessary any embedded quotes"

	^'"', (aString copyReplaceAll: '"' with: '\"'), '"'
! !
!WebUtils class methodsFor: 'quoting' stamp: 'ar 3/31/2010 08:45'!
unquote: aString
	"Unquote the given string, unescaping as necessary any embedded quotes"

	(aString beginsWith: '"') ifFalse:[^aString].
	(aString endsWith: '"') ifFalse:[^aString].
	^(aString copyReplaceAll: '\"' with: '"') allButFirst allButLast! !
!WebUtils class methodsFor: 'headers' stamp: 'jmv 6/25/2017 19:36:55'!
readHeadersFrom: aStream
	"Parse http headers and answer a collection of key -> value pairs."

	| headers nextLine existing |
	headers := OrderedCollection new.
	[nextLine := aStream upToAll: String crlfString.
	nextLine isEmpty] whileFalse:[
		nextLine first isSeparator ifTrue:["Continuation as per HTTP 1.1 spec"
			existing := headers last.
			existing value: (existing value, String space, nextLine withBlanksTrimmed).
		] ifFalse:["Regular header"
			headers add: 
				(nextLine copyUpTo: $:) asLowercase ->
					(nextLine copyAfter: $:) withBlanksTrimmed.
		].
	].
	^headers! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 20:42'!
accept
	"Convenience API. Perform an SSL server handshake.
	Raises an error if something goes wrong."

	| inbuf outbuf count result |

	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.
	count := 0.

	[self isConnected] whileFalse:[
		"Read input"
		count := self readDataInto: inbuf.
		result := self accept: inbuf from: 1 to: count into: outbuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self writeData: outbuf count: result].
	].
! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:10'!
connect
	"Convenience API. Perform an SSL client handshake. 
	Raises an error if something goes wrong."

	| inbuf outbuf count result |

	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.
	count := 0.

	"Begin the SSL handshake"
	[result := self connect: inbuf from: 1 to: count into: outbuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self writeData: outbuf count: result].

		"Read more input and repeat"
		count := self readDataInto: inbuf.
	].! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 14:18'!
decrypt: data
	"Convenience API. Decrypt incoming data and return the result.

	Warning: This method may produce more or less results than expected
	unless called with exactly one SSL/TLS frame."

	| buf count |
	buf := data class new: 4096.
	count := self decrypt: data from: 1 to: data size into: buf.
	count < 0 ifTrue:[self error: 'Decryption failed, code: ', count].
	^buf copyFrom: 1 to: count! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 14:18'!
encrypt: data
	"Convenience API. Encrypt incoming data and return the result."

	| buf count |
	buf := data class new: data size + 100.
	count := self encrypt: data from: 1 to: data size into: buf.
	count < 0 ifTrue:[self error: 'Decryption failed, code: ', count].
	^buf copyFrom: 1 to: count! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:04'!
receiveData
	"Convenience API. Receive data and decrypt it."

	| inbuf outbuf count |
	inbuf := String new: 4096.
	outbuf := String new: 4096.

	^String streamContents:[:s|
		"Read the next input bytes"
		count := self readDataInto: inbuf.
		"Push the input bytes into the SSL"
		count := self decrypt: inbuf from: 1 to: count into: outbuf.
		"And keep draining as long as output is being produced"
		[count > 0] whileTrue:[
			s next: count putAll: outbuf.
			count := self decrypt: inbuf from: 1 to: 0 into: outbuf.
		].
	].! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:04'!
sendData: inbuf
	"Convenience API. Encrypt and send data"

	| outbuf count |
	outbuf := inbuf class new: inbuf size + 100.
	count := self encrypt: inbuf from: 1 to: inbuf size into: outbuf.
	^self writeData: outbuf count: count.! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 23:02'!
accept: srcBuf from: start to: stop into: dstBuf
	"Start or continue the server handshake using the given input token."

	^self primitiveSSL: handle accept: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'operations' stamp: 'eem 3/23/2016 16:55'!
connect: srcBuf from: start to: stop into: dstBuf
	"Start or continue the server handshake using the given input token."

	| r |
	r := self primitiveSSL: handle connect: srcBuf startingAt: start count: stop-start+1 into: dstBuf.
	r <= 0 ifTrue:
		[Processor yield].
	^r! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 21:58'!
decrypt: srcBuf from: start to: stop into: dstBuf
	"Decrypt the input in srcBuf into the provided output buffer.

	Clients are expected to adhere to the following rules:
		* The size of dstBuf must be large enough for the largest encrypted packet.
		* Clients must not call this method with a huge srcBuf (tens of kb of data)
		* After having called this method with new input, clients must call it 
		   with NO input until all data has been 'drained' for example:
			count := squeakSSL decrypt: srcBuf into: dstBuf.
			[count > 0] whileTrue:[
				count := squeakSSL decrypt: #[] into: dstBuf.
			].
	"

	^self primitiveSSL: handle decrypt: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 21:59'!
encrypt: srcBuf from: start to: stop into: dstBuf
	"Encrypt the input in srcBuf into the provided output buffer.
	The output buffer must be large enough to include the framing information."

	^self primitiveSSL: handle encrypt: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:31'!
certName
	"The name of the (local) certificate to provide to the remote peer."

	^self primitiveSSL: handle getStringProperty: 1! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 11/16/2011 16:48'!
certName: aString
	"Sets the name of the (local) certificate to provide to the remote peer.
	OpenSSL:
		The name is the full path to a .pem file.
	WinSSL:
		The name is matched against the 'friendly name' of a certificate in the cert store.
	"

	^self primitiveSSL: handle setStringProperty: 1 toValue: (aString ifNil:[''])! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27'!
certState
	"Returns the certificate verification bits. The returned value indicates
	whether the certificate is valid. The two standard values are:

		0 - The certificate is valid.
		-1 - No certificate has been provided by the peer.

	Otherwise, the result is a bit mask of the following values:

		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.

	"
	^self primitiveSSL: handle getIntProperty: 3! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:26'!
logLevel
	"Returns the log level of the ssl instance"

	^self primitiveSSL: handle getIntProperty: 1! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27'!
logLevel: aNumber
	"Sets the log level of the ssl instance"

	^self primitiveSSL: handle setIntProperty: 1 toValue: aNumber! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:31'!
peerName
	"Returns the certificate name of the remote peer.
	The method only returns a name if the certificate has been verified."

	^self primitiveSSL: handle getStringProperty: 0! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:25'!
pluginVersion
	"Returns the version of the plugin"

	^self primitiveSSL: handle getIntProperty: 0! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:16'!
readBlock
	"The block used to read data where required. The block takes one argument,
	the buffer to fill with data and is expected to return the number of bytes read."

	^readBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:16'!
readBlock: aBlock
	"The block used to read data where required. The block takes one argument,
	the buffer to fill with data and is expected to return the number of bytes read."

	readBlock := aBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ul 10/16/2014 10:35'!
serverName: aString
	"Sets the name to use with the Server Name Indication TLS extension. Which should be a valid FQDN. No WinSSL support yet."

	^[ self primitiveSSL: handle setStringProperty: 2 toValue: aString ]
		on: Error
		do: [ "nothing" ]! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27'!
sslState
	"Returns the current state of the SSL connection:
		0 - Unused.
		1 - In accept handshake.
		2 - In connect handshake.
		3 - Connected.
	"
	^self primitiveSSL: handle getIntProperty: 2
		! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:17'!
writeBlock
	"The block used to write data where required. The block takes two arguments,
	the buffer and the number of bytes to be written from the buffer."

	^writeBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:17'!
writeBlock: aBlock
	"The block used to write data where required. The block takes two arguments,
	the buffer and the number of bytes to be written from the buffer."

	writeBlock := aBlock! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/16/2010 22:01'!
destroy
	"Destroys the underlying platform handle"

	handle ifNotNil:[
		self primitiveSSLDestroy: handle.
		handle := nil.
	].! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/16/2010 23:10' overrides: 16920235!
initialize
	"Initialize the receiver"

	handle := self primitiveSSLCreate.
! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/18/2010 20:37'!
on: aSocket
	"Convenience API. Set up SqueakSSL to operate on a standard TCP socket.
	Generally not very useful for real applications (it lacks error handling etc) 
	but very helpful for debugging and other experiments."

	self readBlock:[:inbuf|
		aSocket waitForDataIfClosed:[].
		aSocket receiveDataInto: inbuf.
	].
	self writeBlock:[:outbuf :count|
		aSocket sendData: (outbuf copyFrom: 1 to: count).
	].! !
!SqueakSSL methodsFor: 'testing' stamp: 'ar 7/16/2010 22:37'!
isConnected
	"Returns true if the SSL handshake has been completed"

	^self sslState = 3! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:57'!
primitiveSSL: sslHandle accept: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Starts or continues a server handshake using the provided data.
	Will eventually produce output to be sent to the server.
	Returns:
		> 0	 - Number of bytes to be sent to the server
		0	 - Success. The connection is established.
		-1 	 - More input is required.
		< -1 - Other errors
	"
	<primitive: 'primitiveAccept' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:57'!
primitiveSSL: sslHandle connect: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Starts or continues a client handshake using the provided data.
	Will eventually produce output to be sent to the server.
	Returns:
		> 0	 - Number of bytes to be sent to the server
		0	 - Success. The connection is established.
		-1 	 - More input is required.
		< -1 - Other errors
	"
	<primitive: 'primitiveConnect' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:58'!
primitiveSSL: sslHandle decrypt: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Takes incoming data for decryption and continues to decrypt data.
	Returns the number of bytes produced in the output"

	<primitive: 'primitiveDecrypt' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:59'!
primitiveSSL: sslHandle encrypt: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Encrypts the incoming buffer into the result buffer.
	Returns the number of bytes produced as a result."

	<primitive: 'primitiveEncrypt' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:00'!
primitiveSSL: sslHandle getIntProperty: propID
	"Primitive. Returns a string property from an SSL session."

	<primitive: 'primitiveGetIntProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:59'!
primitiveSSL: sslHandle getStringProperty: propID
	"Primitive. Returns a string property from an SSL session."

	<primitive: 'primitiveGetStringProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 1/12/2011 09:40'!
primitiveSSL: sslHandle setIntProperty: propID toValue: anInteger
	"Primitive. Sets a string property in an SSL session."

	<primitive: 'primitiveSetIntProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:00'!
primitiveSSL: sslHandle setStringProperty: propID toValue: aString
	"Primitive. Sets a string property in an SSL session."

	<primitive: 'primitiveSetStringProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:01'!
primitiveSSLCreate
	"Primitive. Creates and returns a new SSL handle"

	<primitive: 'primitiveCreate' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:01'!
primitiveSSLDestroy: sslHandle
	"Primitive. Destroys the SSL session handle"

	<primitive: 'primitiveDestroy' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 7/15/2010 20:08'!
readDataInto: aBuffer
	"Private. Read actual data into the given buffer.
	Return the number of bytes read."

	^readBlock value: aBuffer! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 11/16/2011 16:31'!
setStringProperty: index to: aString
	"Private. Use with caution"

	^self primitiveSSL: handle setStringProperty: index toValue: aString! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 7/15/2010 20:08'!
writeData: aBuffer count: count
	"Private. Write actual data from the given buffer."

	writeBlock value: aBuffer value: count! !
!SqueakSSL class methodsFor: 'utilities' stamp: 'ar 8/7/2010 12:36'!
checkCert: certName
	"Attempt to verify the cert with the given name by performing 
	an SSL handshake. Raises an error if there is an issue with the cert,
	returns the peer name from the cert if successful."

	| sslClient sslServer inbuf outbuf result |
	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.

	["Perform the SSL handshake"
	sslClient := SqueakSSL new.
	sslServer := SqueakSSL new.
	sslServer certName: certName.

	result := 0.
	[result := sslClient connect: inbuf from: 1 to: result into: outbuf.
	result = 0] whileFalse:[
		result < -1 ifTrue:[^self error: 'SSL handshake failed (client code: ', result, ')'].
		result := sslServer accept: outbuf from: 1 to: result into: inbuf.
		result < -1 ifTrue:[^self error: 'SSL handshake failed (server code: ', result, ')'].
	].

	"Handshake complete. Check the cert status"
	sslClient certState = 0 ifFalse:[
		^self error: 'Certificate validation failed (code: ', sslClient certState, ')'.
	].

	"When successful, just return the peer name to the caller"
	^sslClient peerName
	
	] ensure:[
		sslClient ifNotNil:[sslClient destroy].
		sslServer ifNotNil:[sslServer destroy].
	].! !
!SqueakSSL class methodsFor: 'utilities' stamp: 'ar 11/17/2011 10:16'!
platformName
	"Return the name of the platform we're running on."

	^Smalltalk getSystemAttribute: 1001! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:58'!
ensureSampleCert
	"Ensure that we have a sample certificate for the tests"

	SqueakSSL platformName caseOf: {
		['unix'] -> [^self ensureSampleCertFile].
		['Win32'] -> [^self ensureSampleCertInStore].
	} otherwise: [^nil].
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:14:29'!
ensureSampleCertFile
	"On Unix, we can simply create a valid cert file"

	| certName file |
	SqueakSSL platformName = 'unix' ifFalse:[^self].
	certName := self name, 'Cert.pem'.
	file _ DirectoryEntry currentDirectory // certName.
	file exists ifFalse: [
		 file writeStreamDo: [ :stream |
			stream nextPutAll: self exampleCertFile ]].
	^file pathName! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57'!
ensureSampleCertInStore
	"Ensure that we have a valid certificate in the Windows certificate store"

	SqueakSSL platformName = 'Win32' ifFalse:[^self].
	"Undocumented. Allows importing a pfx w/o password.
	For the sole purpose of being able to run tests reliably"
	SqueakSSL new setStringProperty: 10001 to: self exampleCertPFX.
	^'testcert'. "Friendly name of test cert"
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57'!
exampleCertFile
^'-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDnCv/gxDCb2yq15qkNwYtdMOHfW609Ck7wfwjVgzSNg+Hw+1R4
+krWhYRsWoXZUcy9xPC9WhnFCFijcnROcWp7vByVukFkVPYgzk1OBFT484ZCLBme
08GqLSzZrjgu7c1Yu5M9MZQdZKObBvZzDFsnvFccfM7G5mX/FgATasYaLQIDAQAB
AoGBAMpUJ6B+LtNOKykAxir1w0Xo+OTRM/SwglC57tKMBAmp5MNUVbVb+w3B/yWk
YHLf35yQSwKHVOnnVThNkuzfBY+MBxnaZwCByKknB4viP1ihPmfwdtqW4QXt1CTH
53sc9BVPjs3Nn1eEVrc582RK0MhORmjvlz+GkTswXCiKD3tBAkEA+6/au8T8XUeM
y/KrtJ+U84seviw5nY93Yg7495n4ir1fojp4wFbWq1JTeM22zspZQOKzEsjxfHUi
UH3buH//OwJBAOsAlJdIZqTIJponBXho+jqLHqcZYXBz3znDzHZU1PLfyfq2DuVe
gt8UWa4VwlCZNtPi7g/iFPEcLOlf2XY3hbcCQFU7voVsNlKYknPW4JMwn87CREz+
yRw0o6dPjry7JdJGQ4a66n2oatZl8OKuN8Rb/lHc8+vepPkS6eX8WVZn8lUCQE2r
F3EYgLQdYoS4ONqe93S53hukC8w6v6A70iuZxfevdvXhjfLI1cAc3bbngh1ZRgGp
kry1H+7APSe0gg7MMukCQQD3jdsVoc4yhziMdpUMyw6R6vYCMJbMEr/tI6CJYBG4
lW+zdcLK2d6GNpZU80F49HOvxH4HMg1Qv+UUiuxT7jpG
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIICxTCCAi6gAwIBAgIJAN/0HUpkM5dvMA0GCSqGSIb3DQEBBQUAMEwxCzAJBgNV
BAYTAkdCMRIwEAYDVQQIEwlCZXJrc2hpcmUxEDAOBgNVBAcTB05ld2J1cnkxFzAV
BgNVBAoTDk15IENvbXBhbnkgTHRkMB4XDTExMDYwNjE0MzcyMFoXDTEyMDYwNTE0
MzcyMFowTDELMAkGA1UEBhMCR0IxEjAQBgNVBAgTCUJlcmtzaGlyZTEQMA4GA1UE
BxMHTmV3YnVyeTEXMBUGA1UEChMOTXkgQ29tcGFueSBMdGQwgZ8wDQYJKoZIhvcN
AQEBBQADgY0AMIGJAoGBAOcK/+DEMJvbKrXmqQ3Bi10w4d9brT0KTvB/CNWDNI2D
4fD7VHj6StaFhGxahdlRzL3E8L1aGcUIWKNydE5xanu8HJW6QWRU9iDOTU4EVPjz
hkIsGZ7TwaotLNmuOC7tzVi7kz0xlB1ko5sG9nMMWye8Vxx8zsbmZf8WABNqxhot
AgMBAAGjga4wgaswHQYDVR0OBBYEFGFwXmx2B6FB25yKMBm6g884lB2xMHwGA1Ud
IwR1MHOAFGFwXmx2B6FB25yKMBm6g884lB2xoVCkTjBMMQswCQYDVQQGEwJHQjES
MBAGA1UECBMJQmVya3NoaXJlMRAwDgYDVQQHEwdOZXdidXJ5MRcwFQYDVQQKEw5N
eSBDb21wYW55IEx0ZIIJAN/0HUpkM5dvMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcN
AQEFBQADgYEAbjMF7YzNQGovKD4NRjsnnKzQnUCTw6UquY2Oz/5SeLcPfLm8DudF
qppAjJjNpAgYC0yWoWcIxatYF/AsgGc2WL3hzI8oK7by6STfVi5RfLA6jS7lIDOv
4BUVsWZKADbEPsfiwed9b9MLLx8gpLLBrrr2rZpSyeDu4v16haV6wg8=
-----END CERTIFICATE-----
'! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57'!
exampleCertPFX
	^ #[48 130 7 50 2 1 3 48 130 6 248 6 9 42 134 72 134 247 13 1 7 1 160 130 6 233 4 130 6 229 48 130 6 225 48 130 3 191 6 9 42 134 72 134 247 13 1 7 6 160 130 3 176 48 130 3 172 2 1 0 48 130 3 165 6 9 42 134 72 134 247 13 1 7 1 48 28 6 10 42 134 72 134 247 13 1 12 1 6 48 14 4 8 88 63 142 234 51 170 181 1 2 2 8 0 128 130 3 120 247 113 35 203 188 93 48 77 162 13 174 138 246 211 61 198 135 133 35 173 48 145 17 17 215 165 194 254 211 158 248 98 76 208 35 117 179 66 160 245 118 213 71 174 220 87 29 165 94 87 52 172 173 229 251 165 205 43 242 114 250 65 123 9 113 132 130 241 182 211 44 155 163 177 90 52 4 72 47 37 0 101 149 229 33 113 144 29 160 38 44 28 178 1 193 134 122 194 233 165 233 236 242 121 119 47 72 143 91 146 148 29 155 94 202 17 124 77 21 110 194 197 228 149 28 9 129 74 139 76 1 180 245 235 1 191 177 175 158 159 16 12 52 96 80 243 34 26 155 45 210 192 183 217 230 122 13 19 197 214 172 29 151 24 153 136 8 203 72 220 199 79 22 79 251 248 83 204 246 117 242 216 219 53 20 182 121 148 173 221 177 210 171 107 56 101 159 63 110 23 37 168 47 25 252 163 244 206 125 220 122 108 251 223 93 219 129 242 137 229 199 216 254 230 235 62 33 236 39 211 255 184 37 134 152 51 188 182 195 242 18 43 29 134 16 183 48 35 0 100 231 121 145 91 99 171 183 225 246 126 56 190 198 188 79 227 107 211 1 65 113 64 71 9 120 185 75 138 171 220 155 182 35 226 180 121 108 83 253 1 232 183 151 97 160 73 117 218 140 182 224 58 227 40 171 59 143 213 187 41 57 174 185 115 190 81 111 110 81 149 122 114 170 14 10 168 113 248 120 13 247 231 160 162 14 4 227 41 48 249 153 2 107 130 176 16 144 160 116 41 25 241 225 126 110 24 7 69 221 205 108 141 73 164 61 76 219 248 94 142 69 171 109 44 45 75 34 179 205 40 62 161 191 222 79 131 239 230 86 201 124 48 226 212 13 178 187 248 29 191 81 98 229 199 91 204 153 220 112 227 71 116 233 131 134 160 244 78 77 84 128 144 63 123 210 148 221 133 201 44 41 218 89 64 253 172 106 220 127 130 151 11 88 155 57 172 192 196 165 93 177 197 139 128 45 223 88 64 196 6 15 153 160 156 168 3 202 102 129 134 25 75 61 51 190 216 218 178 101 250 91 255 169 245 170 55 228 47 111 197 10 145 196 180 96 217 97 49 104 134 62 228 86 203 242 207 75 246 77 115 20 81 40 173 107 113 251 9 172 18 21 10 102 117 86 63 252 91 190 64 190 140 1 146 70 75 130 110 94 129 107 155 24 253 117 204 162 32 30 102 75 62 42 204 19 159 205 62 23 26 192 23 79 128 205 18 72 198 84 83 107 16 234 121 61 33 101 48 72 32 197 119 216 2 24 213 8 133 63 181 65 15 192 138 240 203 219 69 207 68 66 233 168 195 13 212 235 34 22 142 226 141 25 131 250 123 202 13 163 142 214 170 179 240 5 21 201 143 103 4 70 139 84 104 115 140 248 163 15 71 220 197 222 251 170 15 158 82 26 214 186 154 139 37 245 77 174 37 29 218 103 99 14 230 36 75 72 140 186 89 146 99 10 10 94 68 150 159 234 64 234 32 254 117 187 160 102 46 25 25 77 184 134 151 2 236 109 63 58 186 148 239 251 122 59 123 200 29 42 70 51 118 54 71 184 71 0 111 178 10 81 141 247 59 254 67 191 214 239 78 238 217 142 184 87 107 111 14 102 97 61 229 94 118 187 52 204 25 52 233 177 250 17 62 113 22 163 2 250 13 5 238 103 80 143 201 25 73 33 93 212 81 126 207 29 138 72 191 60 182 132 255 76 97 254 188 96 81 72 73 43 118 191 106 118 41 112 45 96 255 148 59 79 111 89 61 199 106 75 199 154 21 60 25 124 156 168 42 233 7 102 203 120 161 126 125 118 110 114 229 174 26 31 215 140 120 85 171 146 207 176 159 100 102 215 83 142 39 61 255 84 12 19 235 207 44 199 229 220 98 38 167 113 24 88 66 31 115 135 184 70 133 129 3 57 44 202 230 225 37 70 222 228 126 130 216 185 247 48 130 3 26 6 9 42 134 72 134 247 13 1 7 1 160 130 3 11 4 130 3 7 48 130 3 3 48 130 2 255 6 11 42 134 72 134 247 13 1 12 10 1 2 160 130 2 166 48 130 2 162 48 28 6 10 42 134 72 134 247 13 1 12 1 3 48 14 4 8 157 82 4 247 110 231 147 241 2 2 8 0 4 130 2 128 81 141 63 61 170 27 13 87 195 101 166 17 185 109 40 123 79 40 85 18 112 106 87 142 32 19 113 12 131 155 36 149 204 92 237 1 142 195 36 34 134 117 241 52 38 4 223 121 9 207 149 114 168 232 16 31 38 128 191 205 129 96 20 210 13 246 170 175 72 206 132 163 135 42 227 200 61 4 223 65 246 136 48 139 206 95 243 12 78 111 152 17 172 160 235 19 185 107 248 215 171 69 17 108 110 12 143 48 163 35 112 60 104 210 180 61 97 35 132 190 185 52 214 94 137 51 90 103 115 176 108 81 179 254 43 128 230 0 178 229 102 142 136 122 52 213 218 150 93 29 251 227 151 124 220 211 152 14 214 57 253 134 5 216 20 70 142 9 67 253 187 20 45 239 144 60 149 38 118 94 5 240 92 240 11 163 131 39 237 219 228 68 198 176 184 23 155 181 19 149 188 2 73 215 118 95 52 169 186 179 142 106 201 222 98 38 7 72 12 167 242 23 217 58 8 48 98 75 203 68 202 230 50 109 112 231 34 77 8 212 132 34 53 120 195 211 170 209 138 45 25 22 249 200 39 170 102 104 35 23 165 199 0 180 149 231 66 55 227 101 212 227 111 140 202 218 21 211 142 227 95 228 34 59 29 23 212 43 142 132 36 100 19 58 38 124 136 77 192 186 174 111 82 162 61 13 207 31 123 138 16 236 169 94 182 156 137 71 11 3 223 81 146 185 230 164 108 87 82 126 167 121 216 202 201 21 197 50 204 62 46 30 80 245 60 157 124 81 50 79 225 144 130 55 141 182 176 61 62 128 88 105 3 206 168 97 81 180 145 20 211 135 252 195 71 185 42 209 139 98 27 47 3 181 252 89 41 67 246 238 34 71 224 211 65 165 130 115 138 102 130 153 126 248 225 200 42 33 247 34 83 47 161 223 179 49 244 240 108 184 244 229 129 42 34 208 77 62 142 125 57 121 39 2 223 123 75 83 35 184 136 71 228 58 15 61 16 21 111 21 72 84 107 99 66 51 251 47 132 92 62 85 53 197 90 170 118 254 28 232 170 69 119 55 25 30 210 189 113 231 121 214 151 141 218 11 54 90 17 40 94 143 41 72 221 16 204 7 126 200 220 28 157 75 159 142 181 56 44 244 2 206 93 230 121 110 124 181 108 157 161 2 131 121 119 22 99 4 194 228 137 124 193 89 196 239 216 79 206 88 233 84 70 205 120 107 79 1 95 117 198 73 112 207 18 52 174 188 81 59 75 238 227 184 57 166 66 12 188 200 97 251 40 146 239 27 44 6 104 216 90 153 8 161 189 194 32 200 124 180 43 124 169 200 80 238 28 234 114 46 216 243 192 75 180 149 181 215 39 214 64 69 183 205 159 252 238 50 141 132 214 2 245 5 251 219 32 217 37 146 78 226 201 81 209 79 74 174 108 65 49 70 48 31 6 9 42 134 72 134 247 13 1 9 20 49 18 30 16 0 116 0 101 0 115 0 116 0 99 0 101 0 114 0 116 48 35 6 9 42 134 72 134 247 13 1 9 21 49 22 4 20 161 19 18 59 76 168 198 72 97 179 205 74 244 65 111 116 223 140 145 154 48 49 48 33 48 9 6 5 43 14 3 2 26 5 0 4 20 182 216 177 70 221 73 183 142 238 169 97 22 175 148 97 145 207 223 75 54 4 8 178 120 42 60 194 226 96 245 2 2 8 0]! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:27:45'!
google: query
	"An example HTTPS query to encrypted.google.com.
	Example:
		SqueakSSL google: 'squeak'.
		SqueakSSL google: 'SqueakSSL'.
	"

	| hostName address socket ssl |

	"Change the host name to try an https request to some other host"
	hostName := 'encrypted.google.com'.

	address := NetNameResolver addressForName: hostName.
	socket := Socket newTCP.

	"Connect the TCP socket"
	socket connectTo: address port: 443.
	socket waitForConnectionFor: 10.

	"Set up SqueakSSL using the convenience APIs"
	ssl := SqueakSSL on: socket.

	["Let SqueakSSL handle the client handshake"
	ssl connect.

	"Verify that the cert is valid"
	ssl certState = 0 ifFalse:[
		self error: 'The certificate is invalid (code: ', ssl certState,')'.
	].

	"If the certificate is valid, make sure we're were we wanted to go"
	(ssl peerName match: hostName) ifFalse:[
		self error: 'Host name mismatch: ', ssl peerName.
	].

	"Send encrypted data"
	ssl sendData:
		'GET /search?q=', query,' HTTP/1.0', String crlfString,
		'Host: ', hostName, String crlfString,
		'Connection: close', String crlfString,
		String crlfString.

	"Wait for the response"
	^String streamContents:[:s|
		[socket isConnected | socket dataAvailable] 
			whileTrue:[s nextPutAll: ssl receiveData]].
	] ensure:[ssl destroy].
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:31:39'!
serverOn: port certName: certName
	"An HTTPS server example. Fires up a listener at the given port such that
	you can point a browser to that https url. Responds with a single line of text
	and closes the listener after the first connection.

		SqueakSSL 
			serverOn: 8443
			certName: 'Internet Widgits Pty'.

		SqueakSSL 
			serverOn: 8443 
			certName: '/home/andreas/certs/testcert.pem'.

	"
	| listener socket ssl |
	"Set up the listener socket"
	listener := Socket newTCP.
	listener listenOn: port backlogSize: 8.
	[socket := listener waitForAcceptFor: 30.
	socket == nil] whileTrue.
	listener destroy.

	"Set up SqueakSSL for the just accepted connection"
	[ssl := SqueakSSL on: socket.

	"The SSL needs the cert name."
	ssl certName: certName.

	"Let SqueakSSL do the server handshake"
	ssl accept.

	"Read out the HTTPS request"
	ssl receiveData.
	
	"And send the response"
	ssl sendData:
		'HTTP/1.0 200 OK', String crlfString,
		'Connection: close', String crlfString,
		'Content-Type: text/plain', String crlfString,
		'Server: SqueakSSL', String crlfString,
		String crlfString,
		'This is a successful SqueakSSL response.'.

	socket close.

	] ensure:[
		ssl destroy.
		socket destroy.
	].! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 7/16/2010 22:59'!
on: aSocket
	"Convenience API. Create a SqueakSSL operating on a standard TCP socket.
	Generally not very useful for real applications (it lacks error handling etc) 
	but very helpful for debugging and other experiments."

	^self new on: aSocket! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 6/17/2012 11:13'!
secureSocket
	"Answer the class to use as secure socket implementation.
	Provided here so that users only need a dependency on SqueakSSL."

	^SecureSocket! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 6/17/2012 11:25'!
secureSocketStream
	"Answer the class to use as secure socket stream implementation.
	Provided here so that users only need a dependency on SqueakSSL."

	^SecureSocketStream! !
!SmallInteger methodsFor: '*WebClient' stamp: 'jmv 9/19/2016 22:04:27'!
numericValue
	"Shouldn't be needed!!"! !
!String methodsFor: '*WebClient' stamp: 'jmv 6/26/2017 19:36:20'!
encodeForHTTP! !
!String methodsFor: '*WebClient' stamp: 'jmv 9/5/2016 20:49:10'!
unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"
	| ans c asciiVal pos oldPos specialChars |
	ans _ WriteStream on: String new.
	oldPos _ 1.
	specialChars _ '+%' asCharacterSet.

	[pos _ self indexOfAnyOf: specialChars startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
	whileTrue: [
		ans nextPutAll: (self copyFrom: oldPos to: pos - 1).
		c _ self at: pos.
		c = $+ ifTrue: [ans nextPut: $ ] ifFalse: [
			(c = $% and: [pos + 2 <= self size]) ifTrue: [
				asciiVal _ (self at: pos+1) asUppercase digitValue * 16 +
					(self at: pos+2) asUppercase digitValue.
				pos _ pos + 2.
				asciiVal > 255 ifTrue: [^self].	"not really an escaped string"
				ans nextPut: (Character numericValue: asciiVal)]
			ifFalse: [ans nextPut: c]].
		oldPos _ pos+1].
	ans nextPutAll: (self copyFrom: oldPos to: self size).
	^ ans contents! !

!classDefinition: #CartTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #CartTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:10'!
test01NewCartsAreCreatedEmpty

	self assert: testObjectsFactory createCart isEmpty! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:10'!
test02CanNotAddItemsThatDoNotBelongToStore

	| cart |
	
	cart := testObjectsFactory createCart.
	
	self 
		should: [ cart add: testObjectsFactory itemNotSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:10'!
test03AfterAddingAnItemTheCartIsNotEmptyAnymore

	| cart |
	
	cart := testObjectsFactory createCart.
	
	cart add: testObjectsFactory itemSellByTheStore.
	self deny: cart isEmpty ! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:10'!
test04CanNotAddNonPositiveNumberOfItems

	| cart |
	
	cart := testObjectsFactory createCart.
	
	self 
		should: [cart add: 0 of: testObjectsFactory itemSellByTheStore ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidQuantityErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:10'!
test05CanNotAddMoreThanOneItemNotSellByTheStore

	| cart |
	
	cart := testObjectsFactory createCart.
	
	self 
		should: [cart add: 2 of: testObjectsFactory itemNotSellByTheStore  ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = cart invalidItemErrorMessage.
			self assert: cart isEmpty ]! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:11'!
test06CartRemembersAddedItems

	| cart |
	
	cart := testObjectsFactory createCart.
	
	cart add: testObjectsFactory itemSellByTheStore.
	self assert: (cart includes: testObjectsFactory itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:11'!
test07CartDoesNotHoldNotAddedItems

	| cart |
	
	cart := testObjectsFactory createCart.
	
	self deny: (cart includes: testObjectsFactory itemSellByTheStore)! !
!CartTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/17/2013 18:11'!
test08CartRemembersTheNumberOfAddedItems

	| cart |
	
	cart := testObjectsFactory createCart.
	
	cart add: 2 of: testObjectsFactory itemSellByTheStore.
	self assert: (cart occurrencesOf: testObjectsFactory itemSellByTheStore) = 2! !
!CartTest methodsFor: 'setup' stamp: 'HernanWilkinson 6/17/2013 18:09' overrides: 16961394!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.! !

!classDefinition: #CashierTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #CashierTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:00'!
test01CanNotCheckoutAnEmptyCart

	| salesBook |
	
	salesBook := OrderedCollection new.
	self 
		should: [ Cashier 
			toCheckout: testObjectsFactory createCart 
			ownedBy: testObjectsFactory customer
			charging: testObjectsFactory notExpiredCreditCard 
			throught: self
			on: testObjectsFactory today
			registeringOn:  salesBook ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier cartCanNotBeEmptyErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:22'!
test02CalculatedTotalIsCorrect

	| cart cashier |
	
	cart := testObjectsFactory createCart.
	cart add: 2 of: testObjectsFactory itemSellByTheStore.
	
	cashier :=  Cashier
		toCheckout: cart 
		ownedBy: testObjectsFactory customer
		charging: testObjectsFactory notExpiredCreditCard 
		throught: self
		on: testObjectsFactory today 
		registeringOn: OrderedCollection new.
		
	self assert: cashier checkOut total = (testObjectsFactory itemSellByTheStorePrice * 2)! !
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:01'!
test03CanNotCheckoutWithAnExpiredCreditCart

	| cart salesBook |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
	
	self
		should: [ Cashier 
				toCheckout: cart 
				ownedBy: testObjectsFactory customer 
				charging: testObjectsFactory expiredCreditCard 
				throught: self
				on: testObjectsFactory today
				registeringOn: salesBook ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assert: anError messageText = Cashier canNotChargeAnExpiredCreditCardErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:23'!
test04CheckoutRegistersASale

	| cart cashier salesBook total |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart 
		ownedBy: testObjectsFactory customer 
		charging: testObjectsFactory notExpiredCreditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook.
		
	total := cashier checkOut total.
					
	self assert: salesBook size = 1.
	self assert: salesBook first total = total.! !
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:22'!
test05CashierChargesCreditCardUsingMerchantProcessor

	| cart cashier salesBook total creditCard debitedAmout debitedCreditCard  |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 
	cashier:= Cashier 
		toCheckout: cart
		ownedBy: testObjectsFactory customer 
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook.
		
	debitBehavior := [ :anAmount :aCreditCard | 
		debitedAmout := anAmount.
		debitedCreditCard := aCreditCard ].
	total := cashier checkOut total.
					
	self assert: debitedCreditCard = creditCard.
	self assert: debitedAmout = total.! !
!CashierTest methodsFor: 'tests' stamp: 'HernanWilkinson 6/22/2013 12:02'!
test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit

	| cart cashier salesBook creditCard |

	cart := testObjectsFactory createCart.
	cart add: testObjectsFactory itemSellByTheStore.
	creditCard := testObjectsFactory notExpiredCreditCard.
	salesBook := OrderedCollection new.
 	debitBehavior := [ :anAmount :aCreditCard | self error: Cashier creditCardHasNoCreditErrorMessage].
	
	cashier:= Cashier 
		toCheckout: cart 
		ownedBy: testObjectsFactory customer
		charging: creditCard
		throught: self
		on: testObjectsFactory today
		registeringOn: salesBook.
		
	self 
		should: [cashier checkOut ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anError messageText = Cashier creditCardHasNoCreditErrorMessage.
			self assert: salesBook isEmpty ]! !
!CashierTest methodsFor: 'setup' stamp: 'HernanWilkinson 6/17/2013 19:03' overrides: 16961394!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.
	debitBehavior := [ :anAmount :aCreditCard | ]! !
!CashierTest methodsFor: 'merchant processor protocol' stamp: 'HernanWilkinson 6/17/2013 19:02'!
debit: anAmount from: aCreditCard 

	^debitBehavior value: anAmount value: aCreditCard ! !

!classDefinition: #CreditCardTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #CreditCardTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:26:34'!
test01CreditCardNumberWithLessThan16DigitsIsNotValid

	self 
		should: [ CreditCard numbered: '123456789012345' ownedBy: self validOwnerName expiringOn: Month current ]
		raise: Error - MessageNotUnderstood 
		withMessageText: CreditCard invalidNumberErrorDescription! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:26:33'!
test02CreditCardNumberWithMoreThan16DigitsIsNotValid

	self 
		should: [ CreditCard numbered: '12345678901234567' ownedBy: self validOwnerName expiringOn: Month current ]
		raise: Error - MessageNotUnderstood 
		withMessageText: CreditCard invalidNumberErrorDescription! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:26:33'!
test03CreditCardNumberShouldBeDigitsOnly

	self 
		should: [ CreditCard numbered: 'a234567890123456' ownedBy: self validOwnerName expiringOn: Month current ]
		raise: Error - MessageNotUnderstood 
		withMessageText: CreditCard invalidNumberErrorDescription! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:27:23'!
test04NameCanNotBeEmpty

	self 
		should: [ CreditCard numbered: '1234567890123456' ownedBy: '' expiringOn: Month current ]
		raise: Error - MessageNotUnderstood 
		withMessageText: CreditCard invalidOwnerNameErrorDescription! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:32:08'!
test05IsExpiredOnNextExpirationMonth

	| expirationMonth expiredMonth creditCard |
	
	expirationMonth := Month month: #January year: 2020. 
	expiredMonth := expirationMonth next.
	creditCard := CreditCard 
		numbered: '1234567890123456' 
		ownedBy: self validOwnerName 
		expiringOn: expirationMonth.
		
	self assert: (creditCard isExpiredOn: expiredMonth)! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:32:30'!
test06IsNotExpiredOnExpirationMonth

	| expirationMonth creditCard |
	
	expirationMonth := Month month: #January year: 2020. 
	creditCard := CreditCard 
		numbered: '1234567890123456' 
		ownedBy: self validOwnerName 
		expiringOn: expirationMonth.
		
	self deny: (creditCard isExpiredOn: expirationMonth)! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:39:10'!
test07CanGetCreditCardInfoFromIt

	| expirationMonth creditCard creditCardNumber creditCardOwner |
	
	expirationMonth := Month month: #January year: 2020. 
	creditCardNumber := self validCreditCardNumber.
	creditCardOwner := self validOwnerName.
	
	creditCard := CreditCard 
		numbered: creditCardNumber 
		ownedBy: creditCardOwner 
		expiringOn: expirationMonth.
		
	self assert: creditCardNumber equals: creditCard number.
	self assert: creditCardOwner equals: creditCard ownerName.
	self assert: expirationMonth equals: creditCard expiration! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:33:46'!
validCreditCardNumber

	^ '1234567890123456'! !
!CreditCardTest methodsFor: 'tests' stamp: 'HAW 7/22/2020 14:28:21'!
validOwnerName
	
	^'Pepe Sanchez'! !

!classDefinition: #TusLibrosSystemFacadeTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #TusLibrosSystemFacadeTest
	instanceVariableNames: 'testObjectsFactory clock systemFacade merchantProcessorTransactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #TusLibrosSystemFacadeTest category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:37'!
TestCase subclass: #TusLibrosSystemFacadeTest
	instanceVariableNames: 'testObjectsFactory clock systemFacade merchantProcessorTransactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!TusLibrosSystemFacadeTest methodsFor: 'tests - add to cart' stamp: 'HAW 7/23/2020 15:59:09'!
test04CanAddItemsToACreatedCart

	| cartId cartContent |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 1 of: self validBook toCartIdentifiedAs: cartId.
	
	cartContent := systemFacade listCartIdentifiedAs: cartId.
	
	self assert: 1 equals: (cartContent occurrencesOf: self validBook).
	self assert: 1 equals: cartContent size! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - add to cart' stamp: 'HAW 7/23/2020 15:55:18'!
test05CanNotAddItemToNotCreatedCart

	self
		should: [systemFacade add: 1 of: self validBook toCartIdentifiedAs: self invalidCartId]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidCartIdErrorDescription ]
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - add to cart' stamp: 'HAW 7/23/2020 15:56:49'!
test06CanNotAddItemNotSellByTheStore

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	self
		should: [systemFacade add: 1 of: self invalidBook toCartIdentifiedAs: cartId ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidItemErrorMessage.
			self assertIsEmptyCartIdentifiedAs: cartId]
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - add to cart' stamp: 'HAW 7/23/2020 15:57:13'!
test17CanNotAddToCartWhenSessionIsExpired

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	self advanceTime: (systemFacade sessionDuration + 1 minutes) . 
	self 
		should: [systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade sessionHasExpiredErrorDescription.
			self revertTime: systemFacade sessionDuration.
			self assertIsEmptyCartIdentifiedAs: cartId ]
! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - performance' stamp: 'NR 6/9/2022 20:51:15'!
should: aBlock notTakeMoreThanMilliseconds: aTimeInMillis

	self assert: aBlock timeToRun <= aTimeInMillis! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - performance' stamp: 'NR 6/13/2022 09:05:18'!
test20BookPerformanceShouldNotTakeTooLong

	| cartId bookPerformance quantity total |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	cartId := systemFacade createCartFor: self anotherValidUser authenticatedWith: self anotherValidUserPassword.
	systemFacade add: 5 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	self should: [bookPerformance := systemFacade bookPerformance: self validBook ] 
		notTakeMoreThanMilliseconds: 1100.	

	quantity := bookPerformance at: 'quantity'.
	total := bookPerformance at: 'total'.
	self assert: 7 equals: quantity.
	self assert: (testObjectsFactory itemSellByTheStorePrice * 7) equals: total.
	self assert: 
		self validBook,' was selled ',quantity asString, ' times and raised a total amount of money equal to: ', total asString
		equals: (bookPerformance at: 'summary')
	! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - performance' stamp: 'NR 6/13/2022 08:00:04'!
test21StorePerformanceShouldNotTakeTooLong

	| cartId storePerformance quantity total |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade add: 1 of: self anotherValidBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
	
	cartId := systemFacade createCartFor: self anotherValidUser authenticatedWith: self anotherValidUserPassword.
	systemFacade add: 5 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade add: 10 of: self anotherValidBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
			
	self should: [storePerformance := systemFacade storePerformance] 
		notTakeMoreThanMilliseconds: 1100.	

	quantity := storePerformance at: 'quantity'.
	total := storePerformance at: 'total'.

	self assert: 18 equals: quantity.
	self assert: (testObjectsFactory itemSellByTheStorePrice * 7) + (testObjectsFactory anotherItemSellByTheStorePrice * 11) equals: total.
	self assert:
		'The store selled a total of ',quantity asString, ' books and raised a total amount of money equal to: ', total asString
		equals: (storePerformance at: 'summary')
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list purchases' stamp: 'HAW 7/23/2020 16:06:04'!
test14ListPurchasesIncludesBoughtItems

	| cartId purchases soldItems total |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade add: 1 of: self anotherValidBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	purchases := systemFacade listPurchasesOf: self validUser authenticatingWith: self validUserPassword.
	soldItems := purchases first.
	total := purchases second.

	self assert: 2 equals: (soldItems at: self validBook).
	self assert: 1 equals: (soldItems at: self anotherValidBook).
	self 
		assert: (testObjectsFactory itemSellByTheStorePrice * 2 + testObjectsFactory anotherItemSellByTheStorePrice)
		equals: total! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list purchases' stamp: 'HAW 7/23/2020 16:06:33'!
test15CanNotListPurchasesOfInvalidCustomer

	self 
		should: [systemFacade listPurchasesOf: self invalidUser authenticatingWith: self validUserPassword ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade invalidUserAndOrPasswordErrorDescription ]! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list purchases' stamp: 'HAW 7/23/2020 16:06:46'!
test16CanNotListPurchasesOfValidCustomerWithInvalidPassword

	self 
		should: [systemFacade listPurchasesOf: self validUser authenticatingWith: self invalidPassword ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade invalidUserAndOrPasswordErrorDescription ]! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - create cart' stamp: 'HAW 7/23/2020 15:56:11'!
test01CanCreateCartWithValidUserAndPassword

	| cartId |
	
	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	
	self assertIsEmptyCartIdentifiedAs: cartId ! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - create cart' stamp: 'HAW 7/23/2020 15:53:41'!
test02CanNotCreateCartWithInvalidUser

	self
		should: [ systemFacade createCartFor: self invalidUser authenticatedWith: self validUserPassword ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidUserAndOrPasswordErrorDescription ]! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - create cart' stamp: 'HAW 7/23/2020 15:54:39'!
test03CanNotCreateCartWithInvalidPassword

	self
		should: [ systemFacade createCartFor: self validUser authenticatedWith: self invalidPassword ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidUserAndOrPasswordErrorDescription ]! !
!TusLibrosSystemFacadeTest methodsFor: 'merchant processor protocol' stamp: 'HAW 7/23/2020 16:07:46'!
debit: anAmount from: aCreditCard 

	^merchantProcessorTransactionId ! !
!TusLibrosSystemFacadeTest methodsFor: 'setup' stamp: 'HernanWilkinson 6/22/2013 11:42'!
createSalesBook
	
	^OrderedCollection new! !
!TusLibrosSystemFacadeTest methodsFor: 'setup' stamp: 'HernanWilkinson 6/22/2013 11:47'!
merchantProcessor 

	^self! !
!TusLibrosSystemFacadeTest methodsFor: 'setup' stamp: 'HernanWilkinson 6/17/2015 20:53' overrides: 16961394!
setUp 

	testObjectsFactory := StoreTestObjectsFactory new.
	clock := ManualClock now: testObjectsFactory today.
	systemFacade := TusLibrosSystemFacade 
		authenticatingWith: self validUsersAndPasswords 
		acceptingItemsOf: testObjectsFactory defaultCatalog 
		registeringOn: self createSalesBook
		debitingThrought: self merchantProcessor 
		measuringTimeWith: clock
! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/22/2013 00:15'!
anotherValidBook
	
	^testObjectsFactory anotherItemSellByTheStore ! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'NR 6/9/2022 20:18:52'!
anotherValidUser
	
	^'anotherValidUser'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'NR 6/9/2022 20:19:12'!
anotherValidUserPassword
	
	^'anotherValidUserPassword'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 23:49'!
invalidBook

	^testObjectsFactory itemNotSellByTheStore ! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HAW 7/24/2020 11:08:48'!
invalidCartId
	
	"Devuelvo un objeto nuevo cada vez y de esa forma me aseguro que no pueda ser un id usado - Hernan"
	^Object new! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 23:06'!
invalidPassword
	
	^'invalidPassword'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 22:30'!
invalidUser

	^'invalidUser'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 23:50'!
validBook
	
	^testObjectsFactory itemSellByTheStore ! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 22:27'!
validUser
	
	^'validUser'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'HernanWilkinson 6/21/2013 22:28'!
validUserPassword
	
	^'validUserPassword'! !
!TusLibrosSystemFacadeTest methodsFor: 'test objects' stamp: 'NR 6/9/2022 20:20:12'!
validUsersAndPasswords
	
	^Dictionary new
		at: self validUser put: self validUserPassword;
		at: self anotherValidUser put: self anotherValidUserPassword;
		yourself! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:07:46'!
test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases

	| cartId  currentTransactionId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 1 of: testObjectsFactory itemSellByTheStore toCartIdentifiedAs: cartId.
	
	merchantProcessorTransactionId := Random new nextInteger: 1000.
	
	currentTransactionId := systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
	
	self assert: merchantProcessorTransactionId equals: currentTransactionId.
	self assertValidUserBougthOnlyItemSellByTheStore
	
	
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:03:56'!
test10_1_CanNotCheckoutAnAlreadyCheckedOutCart

	| cartId  |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 1 of: testObjectsFactory itemSellByTheStore toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
			
	self 
		should: [ 
			systemFacade 
				checkOutCartIdentifiedAs: cartId 
				withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
				ownedBy: testObjectsFactory validOwnerName 
				expiringOn: testObjectsFactory notExpiredMonthOfYear ]		
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidCartIdErrorDescription.
			self assertValidUserBougthOnlyItemSellByTheStore ]! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:04:14'!
test11CanNotCheckoutANotCreatedCart

	self
		should: [systemFacade 
			checkOutCartIdentifiedAs: self invalidCartId  
			withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
			ownedBy: testObjectsFactory validOwnerName 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade invalidCartIdErrorDescription ]
		
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:04:29'!
test12CanNotCheckoutAnEmptyCart

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	self
		should: [systemFacade 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
			ownedBy: testObjectsFactory validOwnerName 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade cartCanNotBeEmptyErrorMessage.
			self assertThereAreNoPurchasesForValidUser ]
		
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:08:24'!
test13CanNotCheckoutWithAnExpiredCreditCard

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 1 of: self validBook toCartIdentifiedAs: cartId.
	self
		should: [systemFacade 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
			ownedBy: testObjectsFactory validOwnerName 
			expiringOn: testObjectsFactory expiredMonthOfYear ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade canNotChargeAnExpiredCreditCardErrorMessage.
			self assertThereAreNoPurchasesForValidUser ]
		
		! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - checkout' stamp: 'HAW 7/23/2020 16:08:40'!
test19CanNotCheckOutCartWhenSessionIsExpired

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	self advanceTime: (systemFacade sessionDuration + 1 minutes). 
	
	self 
		should: [systemFacade 
			checkOutCartIdentifiedAs: cartId 
			withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
			ownedBy: testObjectsFactory validOwnerName 
			expiringOn: testObjectsFactory notExpiredMonthOfYear ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade sessionHasExpiredErrorDescription.
			self assertThereAreNoPurchasesForValidUser ].

	! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list cart' stamp: 'HAW 7/23/2020 15:58:09'!
test08CanNotListCartOfInvalidCartId

	self 
		should: [systemFacade listCartIdentifiedAs: self invalidCartId] 
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError | 
			self assertMessageTextOf: anError is: systemFacade invalidCartIdErrorDescription ]
	! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list cart' stamp: 'HAW 7/23/2020 16:00:20'!
test09ListCartReturnsTheRightNumberOfItems

	| cartId cartContent |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 1 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade add: 2 of: self anotherValidBook toCartIdentifiedAs: cartId.
	cartContent := systemFacade listCartIdentifiedAs: cartId.
	
	self assert: 1 equals: (cartContent occurrencesOf: self validBook). 
	self assert: 2 equals: (cartContent occurrencesOf: self anotherValidBook).
	self assert: 3 equals: cartContent size
! !
!TusLibrosSystemFacadeTest methodsFor: 'tests - list cart' stamp: 'HAW 7/23/2020 16:10:25'!
test18CanNotListCartWhenSessionIsExpired

	| cartId |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	self advanceTime: (systemFacade sessionDuration + 1 minutes).
	 
	self 
		should: [systemFacade listCartIdentifiedAs: cartId]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assertMessageTextOf: anError is: systemFacade sessionHasExpiredErrorDescription ].

! !
!TusLibrosSystemFacadeTest methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 12:53'!
advanceTime: aDuration 
	
	clock advanceTime: aDuration ! !
!TusLibrosSystemFacadeTest methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 13:07'!
revertTime: aDuration 
	
	clock revertTime: aDuration ! !
!TusLibrosSystemFacadeTest methodsFor: 'assertions' stamp: 'HAW 7/23/2020 15:55:56'!
assertIsEmptyCartIdentifiedAs: cartId

	^ self assert: (systemFacade listCartIdentifiedAs: cartId) isEmpty! !
!TusLibrosSystemFacadeTest methodsFor: 'assertions' stamp: 'HAW 7/23/2020 15:54:17'!
assertMessageTextOf: anError is: anExpectedMessageText 
	
	self assert: anExpectedMessageText equals: anError messageText! !
!TusLibrosSystemFacadeTest methodsFor: 'assertions' stamp: 'HAW 7/23/2020 15:47:06'!
assertThereAreNoPurchasesForValidUser

	| purchases soldItems total |
	
	purchases := systemFacade listPurchasesOf: self validUser authenticatingWith: self validUserPassword.
	soldItems := purchases first.
	total := purchases second.

	self assert: soldItems isEmpty.
	self assert: 0 equals: total.! !
!TusLibrosSystemFacadeTest methodsFor: 'assertions' stamp: 'HAW 7/23/2020 16:03:38'!
assertValidUserBougthOnlyItemSellByTheStore
	
	| purchases soldItems total |
	purchases := systemFacade listPurchasesOf: self validUser authenticatingWith: self validUserPassword.
	soldItems := purchases first.
	total := purchases second.
	
	self assert: 1 equals: (soldItems at: self validBook).
	self assert: 1 equals: soldItems size.
	self assert: testObjectsFactory itemSellByTheStorePrice equals: total.
! !

!classDefinition: 'TusLibrosSystemFacadeTest class' category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
TusLibrosSystemFacadeTest class
	instanceVariableNames: ''!

!classDefinition: 'TusLibrosSystemFacadeTest class' category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
TusLibrosSystemFacadeTest class
	instanceVariableNames: ''!
!TusLibrosSystemFacadeTest class methodsFor: 'fileOut' stamp: 'HAW 5/6/2020 14:06:42' overrides: 16810622!
fileOut

	"self fileOut"

	DirectoryEntry smalltalkImageDirectory // 'TusLibros.st' writeStreamDo: [ :fileStream |
		SystemOrganization fileOutCategory: 'TusLibros-Model' on: fileStream initializing: true.
		SystemOrganization fileOutCategory: 'TusLibros-Test' on: fileStream initializing: true ]! !

!classDefinition: #ManualClock category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
ProtoObject subclass: #ManualClock
	instanceVariableNames: 'now'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #ManualClock category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
ProtoObject subclass: #ManualClock
	instanceVariableNames: 'now'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!ManualClock methodsFor: 'time change' stamp: 'HernanWilkinson 6/22/2013 12:54'!
advanceTime: aDuration 
	
	now := now + aDuration ! !
!ManualClock methodsFor: 'time change' stamp: 'HernanWilkinson 6/22/2013 13:08'!
revertTime: aDuration 
	
	now := now + aDuration negated ! !
!ManualClock methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 12:56'!
now
	
	^ now! !
!ManualClock methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 12:53'!
today
	
	^now date! !
!ManualClock methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:52'!
initializeNow: aTime 

	now := aTime ! !

!classDefinition: 'ManualClock class' category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
ManualClock class
	instanceVariableNames: ''!

!classDefinition: 'ManualClock class' category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
ManualClock class
	instanceVariableNames: ''!
!ManualClock class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/22/2013 12:52'!
now: aTime 
	
	^self new initializeNow: aTime ! !

!classDefinition: #StoreTestObjectsFactory category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #StoreTestObjectsFactory category: 'TusLibros-Tests' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'HernanWilkinson 6/22/2013 00:16'!
anotherItemSellByTheStore
	
	^'anotherValidBook'! !
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'HernanWilkinson 6/22/2013 00:16'!
anotherItemSellByTheStorePrice
	
	^15! !
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'HernanWilkinson 6/17/2013 18:08'!
itemNotSellByTheStore
	
	^'invalidBook'! !
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'HernanWilkinson 6/17/2013 18:08'!
itemSellByTheStore
	
	^ 'validBook'! !
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'HernanWilkinson 6/17/2013 18:08'!
itemSellByTheStorePrice
	
	^10! !
!StoreTestObjectsFactory methodsFor: 'cart' stamp: 'HernanWilkinson 6/17/2013 18:08'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !
!StoreTestObjectsFactory methodsFor: 'cart' stamp: 'HernanWilkinson 6/22/2013 00:16'!
defaultCatalog
	
	^ Dictionary new
		at: self itemSellByTheStore put: self itemSellByTheStorePrice;
		at: self anotherItemSellByTheStore put: self anotherItemSellByTheStorePrice;
		yourself ! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HAW 7/22/2020 14:26:34'!
expiredCreditCard
	
	^CreditCard numbered: self validCreditCardNumber ownedBy: self validOwnerName expiringOn: self expiredMonthOfYear ! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HernanWilkinson 6/22/2013 11:24'!
expiredMonthOfYear 

	^ Month month: today monthIndex year: today yearNumber - 1! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HAW 7/22/2020 14:26:34'!
notExpiredCreditCard
	
	^CreditCard numbered: self validCreditCardNumber ownedBy: self validOwnerName expiringOn: self notExpiredMonthOfYear! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HernanWilkinson 6/22/2013 11:06'!
notExpiredMonthOfYear

	^ Month month: today monthIndex year: today yearNumber + 1! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HAW 7/23/2020 15:25:37'!
validCreditCardNumber
	
	^'1234567890123456'! !
!StoreTestObjectsFactory methodsFor: 'credit card' stamp: 'HAW 7/23/2020 15:25:51'!
validOwnerName
	
	^'Pepe Sanchez'! !
!StoreTestObjectsFactory methodsFor: 'initialization' stamp: 'HernanWilkinson 6/17/2013 18:37' overrides: 16920235!
initialize

	today := DateAndTime now! !
!StoreTestObjectsFactory methodsFor: 'date' stamp: 'HernanWilkinson 6/17/2013 18:37'!
today
	
	^ today! !
!StoreTestObjectsFactory methodsFor: 'customer' stamp: 'HernanWilkinson 6/22/2013 12:02'!
customer
	
	^'aCustomer'! !

!classDefinition: #Cart category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #Cart category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/21/2013 23:59'!
invalidItemErrorMessage
	
	^self class invalidItemErrorMessage ! !
!Cart methodsFor: 'error messages' stamp: 'HernanWilkinson 6/22/2013 00:00'!
invalidQuantityErrorMessage
	
	^self class invalidQuantityErrorMessage ! !
!Cart methodsFor: 'assertions' stamp: 'HernanWilkinson 6/22/2013 14:17'!
assertIsValidItem: anItem

	(catalog includesKey: anItem) ifFalse: [ self signalInvalidItem ]! !
!Cart methodsFor: 'assertions' stamp: 'HernanWilkinson 6/22/2013 14:18'!
assertIsValidQuantity: aQuantity

	aQuantity strictlyPositive ifFalse: [self signalInvalidQuantity ]! !
!Cart methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:29'!
initializeAcceptingItemsOf: aCatalog

	catalog := aCatalog.
	items := Bag new.! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
includes: anItem

	^items includes: anItem ! !
!Cart methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 17:44'!
isEmpty
	
	^items isEmpty ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/17/2013 17:44'!
add: anItem

	^ self add: 1 of: anItem ! !
!Cart methodsFor: 'adding' stamp: 'HernanWilkinson 6/22/2013 12:31'!
add: aQuantity of: anItem

	self assertIsValidQuantity: aQuantity.
	self assertIsValidItem: anItem.

	items add: anItem withOccurrences: aQuantity ! !
!Cart methodsFor: 'content' stamp: 'HernanWilkinson 6/22/2013 12:17'!
catalog
	
	^ catalog! !
!Cart methodsFor: 'content' stamp: 'HernanWilkinson 6/22/2013 12:30'!
content
	
	^items copy! !
!Cart methodsFor: 'content' stamp: 'HernanWilkinson 6/23/2013 12:10'!
itemsAndQuantitiesDo: aBlock
	
	^ items contents keysAndValuesDo: [ :anItem :aQuantity | aBlock value: anItem value: aQuantity ]! !
!Cart methodsFor: 'content' stamp: 'HernanWilkinson 6/17/2013 17:45'!
occurrencesOf: anItem

	^items occurrencesOf: anItem  ! !
!Cart methodsFor: 'error signal' stamp: 'HernanWilkinson 6/22/2013 14:18'!
signalInvalidItem 

	self error: self invalidItemErrorMessage! !
!Cart methodsFor: 'error signal' stamp: 'HernanWilkinson 6/22/2013 14:19'!
signalInvalidQuantity 

	self error: self invalidQuantityErrorMessage ! !

!classDefinition: 'Cart class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Cart class
	instanceVariableNames: ''!

!classDefinition: 'Cart class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Cart class
	instanceVariableNames: ''!
!Cart class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/17/2013 17:48'!
acceptingItemsOf: aCatalog

	^self new initializeAcceptingItemsOf: aCatalog ! !
!Cart class methodsFor: 'error messages' stamp: 'HernanWilkinson 6/21/2013 23:59'!
invalidItemErrorMessage
	
	^'Item is not in catalog'! !
!Cart class methodsFor: 'error messages' stamp: 'HernanWilkinson 6/22/2013 00:00'!
invalidQuantityErrorMessage
	
	^'Invalid number of items'! !

!classDefinition: #CartSession category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #CartSession
	instanceVariableNames: 'owner cart lastUsedTime systemFacade'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #CartSession category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #CartSession
	instanceVariableNames: 'owner cart lastUsedTime systemFacade'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!CartSession methodsFor: 'time/expiration' stamp: 'HernanWilkinson 6/17/2015 20:34'!
assertIsNotExpirtedAt: aTime

	(self isExpiredAt: aTime) ifTrue: [ self signalCartSessionExpired ]! !
!CartSession methodsFor: 'time/expiration' stamp: 'HernanWilkinson 6/17/2015 20:36'!
isExpiredAt: aTime 
	
	^ (lastUsedTime + systemFacade sessionDuration) < aTime! !
!CartSession methodsFor: 'time/expiration' stamp: 'HernanWilkinson 6/17/2015 20:36'!
now

	^systemFacade now! !
!CartSession methodsFor: 'time/expiration' stamp: 'HernanWilkinson 6/17/2015 20:37'!
today

	^systemFacade today! !
!CartSession methodsFor: 'session management' stamp: 'HernanWilkinson 6/17/2015 20:35'!
do: aBlock

	| now |

	now := self now.
	self assertIsNotExpirtedAt: now.
	
	^ [ aBlock value: self ] ensure: [ lastUsedTime := now  ]! !
!CartSession methodsFor: 'initialization' stamp: 'HernanWilkinson 6/17/2015 20:36'!
initializeOwnedBy: aCustomer with: aCart on: aSystemFacade

	owner := aCustomer.
	cart := aCart.
	systemFacade := aSystemFacade.
	lastUsedTime := self now.! !
!CartSession methodsFor: 'error signal' stamp: 'HernanWilkinson 6/17/2015 20:37'!
signalCartSessionExpired
	
	self error: systemFacade sessionHasExpiredErrorDescription ! !
!CartSession methodsFor: 'cart' stamp: 'HernanWilkinson 6/17/2015 20:34'!
addToCart: anAmount of: aBook

	^cart add: anAmount of: aBook! !
!CartSession methodsFor: 'cart' stamp: 'HernanWilkinson 6/17/2015 20:35'!
cartContent

	^cart content! !
!CartSession methodsFor: 'cart' stamp: 'HAW 7/23/2020 15:22:42'!
checkOutCartWithCreditCardNumbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear 

	^(Cashier 
		toCheckout: cart 
		ownedBy: owner
		charging: (CreditCard numbered: aCreditCartNumber ownedBy: anOwner expiringOn: anExpirationMonthOfYear) 
		throught: systemFacade merchantProcessor 
		on: self today 
		registeringOn: systemFacade salesBook) checkOut ! !

!classDefinition: 'CartSession class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
CartSession class
	instanceVariableNames: ''!

!classDefinition: 'CartSession class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
CartSession class
	instanceVariableNames: ''!
!CartSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/17/2015 20:37'!
ownedBy: aCustomer with: aCart on: aSystemFacade

	^self new initializeOwnedBy: aCustomer with: aCart on: aSystemFacade! !

!classDefinition: #Cashier category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard owner ticket'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #Cashier category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard owner ticket'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!Cashier methodsFor: 'checkout - private' stamp: 'HernanWilkinson 6/22/2013 12:17'!
createLineItemOf: anItem quantity: aQuantity 

	^LineItem of: anItem quantity: aQuantity total: (self totalOf: anItem quantity: aQuantity) ! !
!Cashier methodsFor: 'checkout - private' stamp: 'HernanWilkinson 6/22/2013 12:25'!
createSale

	^ Sale doneBy: owner certifiedWith: ticket
! !
!Cashier methodsFor: 'checkout - private' stamp: 'HernanWilkinson 6/22/2013 12:28'!
createTicket

	| lineItems |
	
	lineItems := OrderedCollection new.
	cart itemsAndQuantitiesDo: [ :anItem :aQuantity | 
		lineItems add: (self createLineItemOf: anItem quantity: aQuantity)].
	
	ticket := Ticket of: lineItems 
	! !
!Cashier methodsFor: 'checkout - private' stamp: 'HAW 5/5/2020 18:04:55'!
debitTotal

	| transactionId |
	
	transactionId := merchantProcessor debit: ticket total from: creditCard.
	ticket transactionId: transactionId! !
!Cashier methodsFor: 'checkout - private' stamp: 'HernanWilkinson 6/17/2013 19:06'!
registerSale

	salesBook add: self createSale! !
!Cashier methodsFor: 'checkout - private' stamp: 'HernanWilkinson 6/22/2013 12:17'!
totalOf: anItem quantity: aQuantity 

	^(cart catalog at: anItem) * aQuantity  ! !
!Cashier methodsFor: 'checkout' stamp: 'HernanWilkinson 6/22/2013 12:28'!
checkOut

	self createTicket.
	self debitTotal.
	self registerSale.

	^ ticket ! !
!Cashier methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:02'!
initializeToCheckout: aCart ownedBy: anOwner charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook
	
	cart := aCart.
	owner := anOwner.
	creditCard := aCreditCard.
	merchantProcessor := aMerchantProcessor.
	salesBook := aSalesBook! !

!classDefinition: 'Cashier class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'assertions' stamp: 'HernanWilkinson 6/22/2013 14:22'!
assertIsNotEmpty: aCart 
	
	aCart isEmpty ifTrue: [self signalCartCanNotBeEmpty ]! !
!Cashier class methodsFor: 'assertions' stamp: 'HernanWilkinson 6/22/2013 14:22'!
assertIsNotExpired: aCreditCard on: aDate
	
	(aCreditCard isExpiredOn: aDate) ifTrue: [self signalCanNotChargeAnExpiredCreditCard]! !
!Cashier class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/22/2013 12:00'!
toCheckout: aCart ownedBy: anOwner charging: aCreditCard throught: aMerchantProcessor on: aDate registeringOn: aSalesBook
	
	self assertIsNotEmpty: aCart.
	self assertIsNotExpired: aCreditCard on: aDate.
	
	^self new initializeToCheckout: aCart ownedBy: anOwner charging: aCreditCard throught: aMerchantProcessor registeringOn: aSalesBook! !
!Cashier class methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 18:21'!
canNotChargeAnExpiredCreditCardErrorMessage
	
	^'Can not charge an expired credit card'! !
!Cashier class methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 17:56'!
cartCanNotBeEmptyErrorMessage
	
	^'Can not check out an empty cart'! !
!Cashier class methodsFor: 'error messages' stamp: 'HernanWilkinson 6/17/2013 19:02'!
creditCardHasNoCreditErrorMessage
	
	^'Credit card has no credit'! !
!Cashier class methodsFor: 'error signal' stamp: 'HernanWilkinson 6/22/2013 14:22'!
signalCanNotChargeAnExpiredCreditCard

	 self error: self canNotChargeAnExpiredCreditCardErrorMessage ! !
!Cashier class methodsFor: 'error signal' stamp: 'HernanWilkinson 6/22/2013 14:22'!
signalCartCanNotBeEmpty

	self error: self cartCanNotBeEmptyErrorMessage! !

!classDefinition: #Clock category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Clock
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #Clock category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #Clock
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!Clock methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 14:23'!
now

	self subclassResponsibility ! !
!Clock methodsFor: 'time' stamp: 'HernanWilkinson 6/22/2013 14:23'!
today

	self subclassResponsibility ! !

!classDefinition: #CreditCard category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration number ownerName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #CreditCard category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:38'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration number ownerName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!CreditCard methodsFor: 'testing' stamp: 'HernanWilkinson 6/17/2013 18:39'!
isExpiredOn: aDate 
	
	^expiration start < (Month month: aDate monthIndex year: aDate yearNumber) start ! !
!CreditCard methodsFor: 'initialization' stamp: 'HAW 7/22/2020 14:39:22'!
initializeNumbered: aNumber ownedBy: anOwnerName expiringOn: aMonth 
	
	number := aNumber.
	ownerName := anOwnerName.
	expiration := aMonth ! !
!CreditCard methodsFor: 'accessing' stamp: 'HAW 7/22/2020 14:37:53'!
expiration
	
	^expiration ! !
!CreditCard methodsFor: 'accessing' stamp: 'HAW 7/22/2020 14:37:11'!
number
	
	^number! !
!CreditCard methodsFor: 'accessing' stamp: 'HAW 7/22/2020 14:39:22'!
ownerName
	
	^ownerName ! !

!classDefinition: 'CreditCard class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
CreditCard class
	instanceVariableNames: ''!

!classDefinition: 'CreditCard class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
CreditCard class
	instanceVariableNames: ''!
!CreditCard class methodsFor: 'instance creation' stamp: 'HAW 7/22/2020 14:40:01'!
numbered: aNumber ownedBy: anOwnerName expiringOn: aMonth 
	
	self assertIsValidNumber: aNumber.
	self assertIsValidOwnerName: anOwnerName.
	
	^self new initializeNumbered: aNumber ownedBy: anOwnerName expiringOn: aMonth! !
!CreditCard class methodsFor: 'exceptions' stamp: 'HAW 7/22/2020 14:19:45'!
invalidNumberErrorDescription
	
	^'Invalid credit card number. It must be 16 digits'! !
!CreditCard class methodsFor: 'exceptions' stamp: 'HAW 7/22/2020 14:27:09'!
invalidOwnerNameErrorDescription
	
	^'Owner name can not be empty'! !
!CreditCard class methodsFor: 'exceptions' stamp: 'HAW 7/22/2020 14:21:14'!
signalInvalidNumber
	
	self error: self invalidNumberErrorDescription ! !
!CreditCard class methodsFor: 'exceptions' stamp: 'HAW 7/22/2020 14:28:05'!
signalInvalidOwnerName
	
	self error: self invalidOwnerNameErrorDescription ! !
!CreditCard class methodsFor: 'assertions' stamp: 'HAW 7/22/2020 14:39:48'!
assertIsValidNumber: aNumber

	aNumber size = 16 ifFalse: [ self signalInvalidNumber ].
	(aNumber anySatisfy: [ :aCharacter | aCharacter isDigit not ]) ifTrue: [ self signalInvalidNumber ]! !
!CreditCard class methodsFor: 'assertions' stamp: 'HAW 7/22/2020 14:40:28'!
assertIsValidOwnerName: anOwnerName

	anOwnerName isEmpty ifTrue: [ self signalInvalidOwnerName ]! !

!classDefinition: #LineItem category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #LineItem
	instanceVariableNames: 'item quantity total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #LineItem category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #LineItem
	instanceVariableNames: 'item quantity total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!LineItem methodsFor: 'accessing' stamp: 'HernanWilkinson 6/22/2013 12:33'!
item
	
	^ item! !
!LineItem methodsFor: 'accessing' stamp: 'HAW 7/23/2020 15:33:00'!
quantity

	^quantity ! !
!LineItem methodsFor: 'accessing' stamp: 'HernanWilkinson 6/22/2013 12:21'!
total
	
	^ total! !
!LineItem methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:18'!
initializeOf: anItem quantity: aQuantity total: aTotal

	item := anItem.
	quantity := aQuantity.
	total := aTotal 

! !

!classDefinition: 'LineItem class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
LineItem class
	instanceVariableNames: ''!

!classDefinition: 'LineItem class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
LineItem class
	instanceVariableNames: ''!
!LineItem class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/22/2013 12:18'!
of: anItem quantity: aQuantity total: aTotal

	^self new initializeOf: anItem quantity: aQuantity total: aTotal

! !

!classDefinition: #MerchantProcessor category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #MerchantProcessor category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!MerchantProcessor methodsFor: 'debit' stamp: 'HernanWilkinson 6/22/2013 14:31'!
README

	"Aunque nadie subclasifica esta clase, esta para definir el protocolo que se espera que todo MerchantProcessor sepa responder - Hernan"! !
!MerchantProcessor methodsFor: 'debit' stamp: 'HernanWilkinson 6/22/2013 14:30'!
debit: anAmount from: aCreditCard 

	self subclassResponsibility ! !

!classDefinition: #Sale category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #Sale
	instanceVariableNames: 'customer ticket'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #Sale category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #Sale
	instanceVariableNames: 'customer ticket'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!Sale methodsFor: 'total' stamp: 'HernanWilkinson 6/22/2013 12:26'!
total
	
	^ ticket total! !
!Sale methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:26'!
initializeDoneBy: aCustomer certifiedWith: aTicket 

	customer := aCustomer.
	ticket := aTicket ! !
!Sale methodsFor: 'testing' stamp: 'HernanWilkinson 6/22/2013 12:06'!
wasDoneBy: aCustomer

	^customer = aCustomer ! !
!Sale methodsFor: 'line items' stamp: 'HernanWilkinson 6/22/2013 12:33'!
lineItemsDo: aBlock
	
	^ticket lineItemsDo: aBlock ! !

!classDefinition: 'Sale class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Sale class
	instanceVariableNames: ''!

!classDefinition: 'Sale class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Sale class
	instanceVariableNames: ''!
!Sale class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/22/2013 12:25'!
doneBy: aCustomer certifiedWith: aTicket 

	^self new initializeDoneBy: aCustomer certifiedWith: aTicket ! !

!classDefinition: #Ticket category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #Ticket
	instanceVariableNames: 'lineItems transactionId transactionIdSale transactionIdTaxes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #Ticket category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #Ticket
	instanceVariableNames: 'lineItems transactionId transactionIdSale transactionIdTaxes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!Ticket methodsFor: 'total' stamp: 'HernanWilkinson 6/17/2015 20:39'!
total
	
	^lineItems sum: [ :aLineItem | aLineItem total]! !
!Ticket methodsFor: 'initialization' stamp: 'HernanWilkinson 6/22/2013 12:20'!
initializeOf: aCollectionOfLineItems 

	lineItems := aCollectionOfLineItems ! !
!Ticket methodsFor: 'initialization' stamp: 'HAW 5/5/2020 18:06:16'!
transactionId

	^transactionId ! !
!Ticket methodsFor: 'initialization' stamp: 'NR 6/13/2022 07:21:08'!
transactionId: anId

	transactionId := anId! !
!Ticket methodsFor: 'line items' stamp: 'HernanWilkinson 6/22/2013 12:33'!
lineItemsDo: aBlock
	
	^lineItems do: aBlock ! !

!classDefinition: 'Ticket class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Ticket class
	instanceVariableNames: ''!

!classDefinition: 'Ticket class' category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Ticket class
	instanceVariableNames: ''!
!Ticket class methodsFor: 'instance creation' stamp: 'HernanWilkinson 6/22/2013 12:20'!
of: aCollectionOfLineItems

	^self new initializeOf: aCollectionOfLineItems ! !

!classDefinition: #TusLibrosSystemFacade category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #TusLibrosSystemFacade category: 'TusLibros-Model' stamp: 'VV 11/10/2022 00:44:39'!
Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!TusLibrosSystemFacade methodsFor: 'error messages' stamp: 'HernanWilkinson 6/22/2013 11:24'!
canNotChargeAnExpiredCreditCardErrorMessage
	
	^Cashier canNotChargeAnExpiredCreditCardErrorMessage ! !

----STARTUP---- (10 November 2022 00:44:41) as /home/vicente/Escritorio/linux64/CuisUniversity-5481.image!


----End fileIn of /home/vicente/Escritorio/linux64/TusLibros-Model Ejercicio it4.st----!

----End fileIn of /home/vicente/Escritorio/linux64/TusLibros-Tests Ejercicio it4.st----!

----End fileIn of /home/vicente/Escritorio/linux64/TusLibrosREST Ejercicio it4.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/System/Collections-CompactArrays.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Compression.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Sound.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Cryptography-DigitalSignatures.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/Features/Identities-UUID.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/Packages/System/Network-Kernel.pck.st----!

----End fileIn of /home/vicente/Escritorio/linux64/WebClient.pck.st----!

TestCase subclass: #FORKER_JOINER_UNLEASHED
	instanceVariableNames: 'numberOfRunningForks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #FORKER_JOINER_UNLEASHED category: 'TusLibros-Tests' stamp: 'MV 11/10/2022 00:46:33'!
TestCase subclass: #FORKER_JOINER_UNLEASHED
	instanceVariableNames: 'numberOfRunningForks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!
!FORKER_JOINER_UNLEASHED methodsFor: 'no messages' stamp: 'MV 11/10/2022 00:47:34'!
fork: aBlockClosure

	^[aBlockClosure value. numberOfRunningForks := numberOfRunningForks -1] fork.! !
!FORKER_JOINER_UNLEASHED methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 00:49:47' prior: 50671615!
fork: aBlockClosure
	
	numberOfRunningForks _ numberOfRunningForks + 1.
	[aBlockClosure value. numberOfRunningForks _ numberOfRunningForks -1] fork.
	! !
!FORKER_JOINER_UNLEASHED methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 00:50:07' overrides: 16920235!
initialize
	! !
!FORKER_JOINER_UNLEASHED methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 00:50:12' prior: 50671631 overrides: 16920235!
initialize
	numberOfRunningForks _ 0! !

----SNAPSHOT----(10 November 2022 00:50:34) CuisUniversity-5481.image priorSource: 7059698!
!FORKER_JOINER_UNLEASHED methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 00:51:06'!
join

	! !
!FORKER_JOINER_UNLEASHED methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 00:52:04' prior: 50671644!
join

	[numberOfRunningForks = 0] whileFalse: []

	! !

!classDefinition: #TusLibrosSystemFacade category: 'TusLibros-Model' stamp: 'MV 11/10/2022 00:53:12'!
Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions forkerJoiner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 00:53:10' prior: 50632910!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	
	forkerJoiner fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!

!classDefinition: #TusLibrosSystemFacade category: 'TusLibros-Model' stamp: 'MV 11/10/2022 00:53:26'!
Object subclass: #TusLibrosSystemFacade
	instanceVariableNames: 'validUsersAndPasswords catalog lastId merchantProcessor salesBook clock cartSessions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Model'!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 00:54:00' prior: 50671664!
bookPerformance: anItem

	| forkerJoiner bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkerJoiner _ FORKER_JOINER_UNLEASHED new.
	forkerJoiner fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:54:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 00:54:35'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 00:54:37'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 00:54:39'!
FAILURE!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 00:55:41' prior: 50632951!
storePerformance

	| totalMoney totalSales performance forkerJoiner|
	
	forkerJoiner _ FORKER_JOINER_UNLEASHED new.
	performance := Dictionary new.
	
	forkerJoiner fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkerJoiner join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'MV 11/10/2022 00:55:41'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 00:55:42'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 00:55:43'!
PASSED!

----SNAPSHOT----(10 November 2022 00:56:12) CuisUniversity-5481.image priorSource: 10879655!

TusLibrosClientRestInterface installForDefaultSystem !

 TusLibrosServerRestInterface installForDefaultSystem !

 TusLibrosServerRestInterface installForDefaultSystem !

d!

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 01:04:45' prior: 50634629!
addToCart

	|cartId bookIsbn |
	"forkerJoiner _ FORKER_JOINER_UNLEASHED new."
	
	[
	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]] fork.
! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 01:06:44' prior: 50634642!
createCart

	| newCartId |
	
	[newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived]fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 01:06:56' prior: 50634651!
listCart

	| cartId |
	
	[(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].] fork.! !

Object subclass: #FORKER_JOINER_UNLEASHED
	instanceVariableNames: 'numberOfRunningForks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!classDefinition: #FORKER_JOINER_UNLEASHED category: 'TusLibros-Tests' stamp: 'MV 11/10/2022 01:08:49'!
Object subclass: #FORKER_JOINER_UNLEASHED
	instanceVariableNames: 'numberOfRunningForks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros-Tests'!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'MV 11/10/2022 01:09:02'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 01:09:03'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 01:09:04'!
PASSED!

----STARTUP---- (10 November 2022 13:06:18) as /home/vicente/Escritorio/linux64/CuisUniversity-5481.image!


!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'MV 11/10/2022 13:06:53'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 13:06:54'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 13:06:55'!
PASSED!

!classDefinition: #MessageBroker category: 'TusLibrosREST' stamp: 'MV 11/10/2022 13:30:07'!
Object subclass: #MessageBroker
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'MV 11/10/2022 13:30:01' prior: 50634501!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| fieldDict resp messageBroker |
	
	messageBroker _ MessageBroker new.
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
	
	messageBroker send: [WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.]
	
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]w! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'MV 11/10/2022 13:30:45' prior: 50672069!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| id fieldDict resp messageBroker |
	
	messageBroker _ MessageBroker new.
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
	
	id _ messageBroker send: [WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.]
	
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]w! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'MV 11/10/2022 13:33:07' prior: 50672089!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| id fieldDict resp messageBroker |
	
	messageBroker _ MessageBroker new.
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	"resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict."
	
	id _ messageBroker send: [WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.].
	
	"
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]
	"! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'MV 11/10/2022 14:08:08' prior: 50672110!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| id fieldDict resp messageBroker |
	
	"messageBroker _ MessageBroker new."
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
	
	"id _ messageBroker send: [WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.]."
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]
	! !

!classDefinition: #TusLibrosClientTestWindowModel category: 'TusLibrosREST' stamp: 'MV 11/10/2022 14:42:28'!
Object subclass: #TusLibrosClientTestWindowModel
	instanceVariableNames: 'cartIds selectedCartIdsIndex selectedBookCatalogIndex currentSelectedCartContent restInterface forkPool'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:42:26' prior: 50634629!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		forkPool fork:[restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]]! !
!TusLibrosClientTestWindowModel methodsFor: 'initialization' stamp: 'MV 11/10/2022 14:43:05' prior: 50634671 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkPool := FORKER_JOINER_UNLEASHED new.! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:43:47' prior: 50634642!
createCart

	| newCartId |
	forkPool fork:[
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:43:59' prior: 50634651!
listCart

	| cartId |
	forkPool fork:[
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].]! !

!classRenamed: #FORKER_JOINER_UNLEASHED as: #ForkPool stamp: 'MV 11/10/2022 14:44:20'!
Smalltalk renameClassNamed: #FORKER_JOINER_UNLEASHED as: #ForkPool!
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:44:20' prior: 50671701!
bookPerformance: anItem

	| forkerJoiner bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkerJoiner _ ForkPool new.
	forkerJoiner fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:44:20' prior: 50672177 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkPool := ForkPool new.! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:44:20' prior: 50671806!
storePerformance

	| totalMoney totalSales performance forkerJoiner|
	
	forkerJoiner _ ForkPool new.
	performance := Dictionary new.
	
	forkerJoiner fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkerJoiner join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosClientTestWindow open !

!classRenamed: #ForkPool as: #ForkedBlocksPool stamp: 'MV 11/10/2022 14:54:17'!
Smalltalk renameClassNamed: #ForkPool as: #ForkedBlocksPool!
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:17' prior: 50672215!
bookPerformance: anItem

	| forkerJoiner bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkerJoiner _ ForkedBlocksPool new.
	forkerJoiner fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:17' prior: 50672237 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkPool := ForkedBlocksPool new.! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:17' prior: 50672248!
storePerformance

	| totalMoney totalSales performance forkerJoiner|
	
	forkerJoiner _ ForkedBlocksPool new.
	performance := Dictionary new.
	
	forkerJoiner fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkerJoiner join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!classRenamed: #ForkedBlocksPool as: #AsyncProcessPool stamp: 'MV 11/10/2022 14:54:48'!
Smalltalk renameClassNamed: #ForkedBlocksPool as: #AsyncProcessPool!
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:48' prior: 50672282!
bookPerformance: anItem

	| forkerJoiner bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkerJoiner _ AsyncProcessPool new.
	forkerJoiner fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:48' prior: 50672304 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkPool := AsyncProcessPool new.! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:54:48' prior: 50672316!
storePerformance

	| totalMoney totalSales performance forkerJoiner|
	
	forkerJoiner _ AsyncProcessPool new.
	performance := Dictionary new.
	
	forkerJoiner fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkerJoiner join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!AsyncProcessPool methodsFor: 'paralellizing' stamp: 'MV 11/10/2022 14:56:17'!
add: aBlockClosure
	
	numberOfRunningForks _ numberOfRunningForks + 1.
	[aBlockClosure value. numberOfRunningForks _ numberOfRunningForks -1] fork.
	! !

!methodRemoval: AsyncProcessPool #fork: stamp: 'MV 11/10/2022 14:56:17'!
fork: aBlockClosure
	
	numberOfRunningForks _ numberOfRunningForks + 1.
	[aBlockClosure value. numberOfRunningForks _ numberOfRunningForks -1] fork.
	!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:56:53' prior: 50672189!
createCart

	| newCartId |
	forkPool add:[
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:56:56' prior: 50672199!
listCart

	| cartId |
	forkPool add:[
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].]! !

TusLibrosClientTestWindow open !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 14:57:21' prior: 50672163!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		forkPool add:[restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]]! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:57:55' prior: 50672341!
bookPerformance: anItem

	| forkerJoiner bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkerJoiner _ AsyncProcessPool new.
	forkerJoiner add: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkerJoiner join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:58:00' prior: 50672375!
storePerformance

	| totalMoney totalSales performance forkerJoiner|
	
	forkerJoiner _ AsyncProcessPool new.
	performance := Dictionary new.
	
	forkerJoiner add: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkerJoiner join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:58:11' prior: 50672467!
storePerformance

	| totalMoney totalSales performance processPool|
	
	processPool _ AsyncProcessPool new.
	performance := Dictionary new.
	
	processPool add: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	processPool join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:58:18' prior: 50672446!
bookPerformance: anItem

	| processPool bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	processPool _ AsyncProcessPool new.
	processPool add: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	processPool join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!classRenamed: #AsyncProcessPool as: #ForkJoinPool stamp: 'MV 11/10/2022 14:58:47'!
Smalltalk renameClassNamed: #AsyncProcessPool as: #ForkJoinPool!
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:58:47' prior: 50672507!
bookPerformance: anItem

	| processPool bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	processPool _ ForkJoinPool new.
	processPool add: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	processPool join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:58:47' prior: 50672363 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkPool := ForkJoinPool new.! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 14:58:47' prior: 50672487!
storePerformance

	| totalMoney totalSales performance processPool|
	
	processPool _ ForkJoinPool new.
	performance := Dictionary new.
	
	processPool add: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	processPool join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!ForkJoinPool methodsFor: 'paralellizing' stamp: 'MV 11/10/2022 14:59:29'!
fork: aBlockClosure
	
	numberOfRunningForks _ numberOfRunningForks + 1.
	[aBlockClosure value. numberOfRunningForks _ numberOfRunningForks -1] fork.
	! !

!methodRemoval: ForkJoinPool #add: stamp: 'MV 11/10/2022 14:59:29'!
add: aBlockClosure
	
	numberOfRunningForks _ numberOfRunningForks + 1.
	[aBlockClosure value. numberOfRunningForks _ numberOfRunningForks -1] fork.
	!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:59:44' prior: 50672533!
bookPerformance: anItem

	| processPool bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	processPool _ ForkJoinPool new.
	processPool fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	processPool join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:59:53' prior: 50672567!
storePerformance

	| totalMoney totalSales performance processPool|
	
	processPool _ ForkJoinPool new.
	performance := Dictionary new.
	
	processPool fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	processPool join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 14:59:58' prior: 50672622!
storePerformance

	| totalMoney totalSales performance forkJoinPool|
	
	forkJoinPool _ ForkJoinPool new.
	performance := Dictionary new.
	
	forkJoinPool fork: [totalSales := self totalSales].
	totalMoney := self totalMoneyRaised.
	forkJoinPool join.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'MV 11/10/2022 15:00:04' prior: 50672601!
bookPerformance: anItem

	| forkJoinPool bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	forkJoinPool _ ForkJoinPool new.
	forkJoinPool fork: [totalSales := self totalSalesOf: anItem.].
	totalMoney := self totalMoneyRaisedBy: anItem.
	forkJoinPool join.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 15:00:21' prior: 50672433!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		forkPool fork:[restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 15:00:27' prior: 50672410!
createCart

	| newCartId |
	forkPool fork:[
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'MV 11/10/2022 15:00:53' prior: 50672420!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		forkPool fork:[
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].]! !

!classDefinition: #TusLibrosClientTestWindowModel category: 'TusLibrosREST' stamp: 'MV 11/10/2022 15:01:00'!
Object subclass: #TusLibrosClientTestWindowModel
	instanceVariableNames: 'cartIds selectedCartIdsIndex selectedBookCatalogIndex currentSelectedCartContent restInterface forkJoinPool'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibrosREST'!
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 15:01:00' prior: 50672698!
createCart

	| newCartId |
	forkJoinPool fork:[
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived]! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 15:01:00' prior: 50672684!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue:[
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		forkJoinPool fork:[restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)]]! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 15:01:00' prior: 50672555 overrides: 16920235!
initialize

	cartIds := OrderedCollection new.
	currentSelectedCartContent := OrderedCollection new.
	selectedCartIdsIndex := 0.
	selectedBookCatalogIndex := 0.
	restInterface := TusLibrosClientRestInterface new.
	forkJoinPool := ForkJoinPool new.! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'MV 11/10/2022 15:01:00' prior: 50672708!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		forkJoinPool fork:[
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ].]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'MV 11/10/2022 15:01:04'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 15:01:05'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'MV 11/10/2022 15:01:06'!
PASSED!

TusLibrosClientTestWindow open!

----SNAPSHOT----(10 November 2022 15:02:43) CuisUniversity-5481.image priorSource: 10888153!